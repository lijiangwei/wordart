(function e(t, n, r) {
	function s(o, u) {
		if (!n[o]) {
			if (!t[o]) {
				var a = typeof require == "function" && require;
				if (!u && a) return a(o, !0);
				if (i) return i(o, !0);
				var f = new Error("Cannot find module '" + o + "'");
				throw f.code = "MODULE_NOT_FOUND", f
			}
			var l = n[o] = {
				exports: {}
			};
			t[o][0].call(l.exports, function(e) {
				var n = t[o][1][e];
				return s(n ? n : e)
			}, l, l.exports, e, t, n, r)
		}
		return n[o].exports
	}
	var i = typeof require == "function" && require;
	for (var o = 0; o < r.length; o++) s(r[o]);
	return s
})({
	1: [function(require, module, exports) {
		(function(Buffer) {
			window.fontkit = require("fontkit/base");
			window.fontkit.registerFormat(require("fontkit/src/TTFFont"));
			window.Buffer = Buffer
		}).call(this, require("buffer").Buffer)
	}, {
		buffer: 116,
		"fontkit/base": 2,
		"fontkit/src/TTFFont": 26
	}],
	2: [function(require, module, exports) {
		(function() {
			var formats, fs, r;
			r = require("restructure");
			exports.logErrors = false;
			formats = [];
			exports.registerFormat = function(format) {
				formats.push(format);
				return exports[format.name] = format
			};
			exports.create = function(buffer, postscriptName) {
				var font, format, i, len;
				for (i = 0, len = formats.length; i < len; i++) {
					format = formats[i];
					if (format.probe(buffer)) {
						font = new format(new r.DecodeStream(buffer));
						if (postscriptName) {
							return font.getFont(postscriptName)
						}
						return font
					}
				}
				throw new Error("Unknown font format")
			}
		}).call(this)
	}, {
		restructure: 3
	}],
	3: [function(require, module, exports) {
		(function() {
			var key, val, _ref, _ref1;
			exports.EncodeStream = require("./src/EncodeStream");
			exports.DecodeStream = require("./src/DecodeStream");
			exports.Array = require("./src/Array");
			exports.LazyArray = require("./src/LazyArray");
			exports.Bitfield = require("./src/Bitfield");
			exports.Boolean = require("./src/Boolean");
			exports.Buffer = require("./src/Buffer");
			exports.Enum = require("./src/Enum");
			exports.Optional = require("./src/Optional");
			exports.Reserved = require("./src/Reserved");
			exports.String = require("./src/String");
			exports.Struct = require("./src/Struct");
			exports.VersionedStruct = require("./src/VersionedStruct");
			_ref = require("./src/Number");
			for (key in _ref) {
				val = _ref[key];
				exports[key] = val
			}
			_ref1 = require("./src/Pointer");
			for (key in _ref1) {
				val = _ref1[key];
				exports[key] = val
			}
		}).call(this)
	}, {
		"./src/Array": 4,
		"./src/Bitfield": 5,
		"./src/Boolean": 6,
		"./src/Buffer": 7,
		"./src/DecodeStream": 8,
		"./src/EncodeStream": 9,
		"./src/Enum": 10,
		"./src/LazyArray": 11,
		"./src/Number": 12,
		"./src/Optional": 13,
		"./src/Pointer": 14,
		"./src/Reserved": 15,
		"./src/String": 16,
		"./src/Struct": 17,
		"./src/VersionedStruct": 18
	}],
	4: [function(require, module, exports) {
		(function() {
			var ArrayT, NumberT, utils;
			NumberT = require("./Number").Number;
			utils = require("./utils");
			ArrayT = function() {
				function ArrayT(type, length, lengthType) {
					this.type = type;
					this.length = length;
					this.lengthType = lengthType != null ? lengthType : "count"
				}
				ArrayT.prototype.decode = function(stream, parent) {
					var ctx, i, length, pos, res, target, _i;
					pos = stream.pos;
					res = [];
					ctx = parent;
					if (this.length != null) {
						length = utils.resolveLength(this.length, stream, parent)
					}
					if (this.length instanceof NumberT) {
						Object.defineProperties(res, {
							parent: {
								value: parent
							},
							_startOffset: {
								value: pos
							},
							_currentOffset: {
								value: 0,
								writable: true
							},
							_length: {
								value: length
							}
						});
						ctx = res
					}
					if (length == null || this.lengthType === "bytes") {
						target = length != null ? stream.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream.length;
						while (stream.pos < target) {
							res.push(this.type.decode(stream, ctx))
						}
					} else {
						for (i = _i = 0; _i < length; i = _i += 1) {
							res.push(this.type.decode(stream, ctx))
						}
					}
					return res
				};
				ArrayT.prototype.size = function(array, ctx) {
					var item, size, _i, _len;
					if (!array) {
						return this.type.size(null, ctx) * utils.resolveLength(this.length, null, ctx)
					}
					size = 0;
					if (this.length instanceof NumberT) {
						size += this.length.size();
						ctx = {
							parent: ctx
						}
					}
					for (_i = 0, _len = array.length; _i < _len; _i++) {
						item = array[_i];
						size += this.type.size(item, ctx)
					}
					return size
				};
				ArrayT.prototype.encode = function(stream, array, parent) {
					var ctx, i, item, ptr, _i, _len;
					ctx = parent;
					if (this.length instanceof NumberT) {
						ctx = {
							pointers: [],
							startOffset: stream.pos,
							parent: parent
						};
						ctx.pointerOffset = stream.pos + this.size(array, ctx);
						this.length.encode(stream, array.length)
					}
					for (_i = 0, _len = array.length; _i < _len; _i++) {
						item = array[_i];
						this.type.encode(stream, item, ctx)
					}
					if (this.length instanceof NumberT) {
						i = 0;
						while (i < ctx.pointers.length) {
							ptr = ctx.pointers[i++];
							ptr.type.encode(stream, ptr.val)
						}
					}
				};
				return ArrayT
			}();
			module.exports = ArrayT
		}).call(this)
	}, {
		"./Number": 12,
		"./utils": 19
	}],
	5: [function(require, module, exports) {
		(function() {
			var Bitfield;
			Bitfield = function() {
				function Bitfield(type, flags) {
					this.type = type;
					this.flags = flags != null ? flags : []
				}
				Bitfield.prototype.decode = function(stream) {
					var flag, i, res, val, _i, _len, _ref;
					val = this.type.decode(stream);
					res = {};
					_ref = this.flags;
					for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
						flag = _ref[i];
						if (flag != null) {
							res[flag] = !!(val & 1 << i)
						}
					}
					return res
				};
				Bitfield.prototype.size = function() {
					return this.type.size()
				};
				Bitfield.prototype.encode = function(stream, keys) {
					var flag, i, val, _i, _len, _ref;
					val = 0;
					_ref = this.flags;
					for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
						flag = _ref[i];
						if (flag != null) {
							if (keys[flag]) {
								val |= 1 << i
							}
						}
					}
					return this.type.encode(stream, val)
				};
				return Bitfield
			}();
			module.exports = Bitfield
		}).call(this)
	}, {}],
	6: [function(require, module, exports) {
		(function() {}).call(this)
	}, {}],
	7: [function(require, module, exports) {
		(function() {
			var BufferT, NumberT, utils;
			utils = require("./utils");
			NumberT = require("./Number").Number;
			BufferT = function() {
				function BufferT(length) {
					this.length = length
				}
				BufferT.prototype.decode = function(stream, parent) {
					var length;
					length = utils.resolveLength(this.length, stream, parent);
					return stream.readBuffer(length)
				};
				BufferT.prototype.size = function(val, parent) {
					if (!val) {
						return utils.resolveLength(this.length, null, parent)
					}
					return val.length
				};
				BufferT.prototype.encode = function(stream, buf, parent) {
					if (this.length instanceof NumberT) {
						this.length.encode(stream, buf.length)
					}
					return stream.writeBuffer(buf)
				};
				return BufferT
			}();
			module.exports = BufferT
		}).call(this)
	}, {
		"./Number": 12,
		"./utils": 19
	}],
	8: [function(require, module, exports) {
		(function(Buffer) {
			(function() {
				var DecodeStream, iconv;
				try {
					iconv = require("iconv-lite")
				} catch (_error) {}
				DecodeStream = function() {
					var key;

					function DecodeStream(buffer) {
						this.buffer = buffer;
						this.pos = 0;
						this.length = this.buffer.length
					}
					DecodeStream.TYPES = {
						UInt8: 1,
						UInt16: 2,
						UInt24: 3,
						UInt32: 4,
						Int8: 1,
						Int16: 2,
						Int24: 3,
						Int32: 4,
						Float: 4,
						Double: 8
					};
					for (key in Buffer.prototype) {
						if (key.slice(0, 4) === "read") {
							(function(key) {
								var bytes;
								bytes = DecodeStream.TYPES[key.replace(/read|[BL]E/g, "")];
								return DecodeStream.prototype[key] = function() {
									var ret;
									ret = this.buffer[key](this.pos);
									this.pos += bytes;
									return ret
								}
							})(key)
						}
					}
					DecodeStream.prototype.readString = function(length, encoding) {
						var buf, byte, i, _i, _ref;
						if (encoding == null) {
							encoding = "ascii"
						}
						switch (encoding) {
							case "utf16le":
							case "ucs2":
							case "utf8":
							case "ascii":
								return this.buffer.toString(encoding, this.pos, this.pos += length);
							case "utf16be":
								buf = new Buffer(this.readBuffer(length));
								for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
									byte = buf[i];
									buf[i] = buf[i + 1];
									buf[i + 1] = byte
								}
								return buf.toString("utf16le");
							default:
								buf = this.readBuffer(length);
								if (iconv) {
									return iconv.decode(buf, encoding)
								}
								return buf
						}
					};
					DecodeStream.prototype.readBuffer = function(length) {
						return this.buffer.slice(this.pos, this.pos += length)
					};
					DecodeStream.prototype.readUInt24BE = function() {
						return (this.readUInt16BE() << 8) + this.readUInt8()
					};
					DecodeStream.prototype.readUInt24LE = function() {
						return this.readUInt16LE() + (this.readUInt8() << 16)
					};
					DecodeStream.prototype.readInt24BE = function() {
						return (this.readInt16BE() << 8) + this.readUInt8()
					};
					DecodeStream.prototype.readInt24LE = function() {
						return this.readUInt16LE() + (this.readInt8() << 16)
					};
					return DecodeStream
				}();
				module.exports = DecodeStream
			}).call(this)
		}).call(this, require("buffer").Buffer)
	}, {
		buffer: 116,
		"iconv-lite": undefined
	}],
	9: [function(require, module, exports) {
		(function(Buffer) {
			(function() {
				var DecodeStream, EncodeStream, iconv, stream, __hasProp = {}.hasOwnProperty,
					__extends = function(child, parent) {
						for (var key in parent) {
							if (__hasProp.call(parent, key)) child[key] = parent[key]
						}

						function ctor() {
							this.constructor = child
						}
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					};
				stream = undefined;
				DecodeStream = require("./DecodeStream");
				try {
					iconv = require("iconv-lite")
				} catch (_error) {}
			}).call(this)
		}).call(this, require("buffer").Buffer)
	}, {
		"./DecodeStream": 8,
		buffer: 116,
		"iconv-lite": undefined,
		stream: undefined
	}],
	10: [function(require, module, exports) {
		(function() {}).call(this)
	}, {}],
	11: [function(require, module, exports) {
		(function() {
			var ArrayT, LazyArray, LazyArrayT, NumberT, inspect, utils, __hasProp = {}.hasOwnProperty,
				__extends = function(child, parent) {
					for (var key in parent) {
						if (__hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				};
			ArrayT = require("./Array");
			NumberT = require("./Number").Number;
			utils = require("./utils");
			inspect = require("util").inspect;
			LazyArrayT = function(_super) {
				__extends(LazyArrayT, _super);

				function LazyArrayT() {
					return LazyArrayT.__super__.constructor.apply(this, arguments)
				}
				LazyArrayT.prototype.decode = function(stream, parent) {
					var length, pos, res;
					pos = stream.pos;
					length = utils.resolveLength(this.length, stream, parent);
					if (this.length instanceof NumberT) {
						parent = {
							parent: parent,
							_startOffset: pos,
							_currentOffset: 0,
							_length: length
						}
					}
					res = new LazyArray(this.type, length, stream, parent);
					stream.pos += length * this.type.size(null, parent);
					return res
				};
				LazyArrayT.prototype.size = function(val, ctx) {
					if (val instanceof LazyArray) {
						val = val.toArray()
					}
					return LazyArrayT.__super__.size.call(this, val, ctx)
				};
				LazyArrayT.prototype.encode = function(stream, val, ctx) {
					if (val instanceof LazyArray) {
						val = val.toArray()
					}
					return LazyArrayT.__super__.encode.call(this, stream, val, ctx)
				};
				return LazyArrayT
			}(ArrayT);
			LazyArray = function() {
				function LazyArray(type, length, stream, ctx) {
					this.type = type;
					this.length = length;
					this.stream = stream;
					this.ctx = ctx;
					this.base = this.stream.pos;
					this.items = []
				}
				LazyArray.prototype.get = function(index) {
					var pos;
					if (index < 0 || index >= this.length) {
						return void 0
					}
					if (this.items[index] == null) {
						pos = this.stream.pos;
						this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
						this.items[index] = this.type.decode(this.stream, this.ctx);
						this.stream.pos = pos
					}
					return this.items[index]
				};
				LazyArray.prototype.toArray = function() {
					var i, _i, _ref, _results;
					_results = [];
					for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 1) {
						_results.push(this.get(i))
					}
					return _results
				};
				LazyArray.prototype.inspect = function() {
					return inspect(this.toArray())
				};
				return LazyArray
			}();
			module.exports = LazyArrayT
		}).call(this)
	}, {
		"./Array": 4,
		"./Number": 12,
		"./utils": 19,
		util: 115
	}],
	12: [function(require, module, exports) {
		(function() {
			var DecodeStream, Fixed, NumberT, __hasProp = {}.hasOwnProperty,
				__extends = function(child, parent) {
					for (var key in parent) {
						if (__hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				};
			DecodeStream = require("./DecodeStream");
			NumberT = function() {
				function NumberT(type, endian) {
					this.type = type;
					this.endian = endian != null ? endian : "BE";
					this.fn = this.type;
					if (this.type[this.type.length - 1] !== "8") {
						this.fn += this.endian
					}
				}
				NumberT.prototype.size = function() {
					return DecodeStream.TYPES[this.type]
				};
				NumberT.prototype.decode = function(stream) {
					return stream["read" + this.fn]()
				};
				NumberT.prototype.encode = function(stream, val) {
					return stream["write" + this.fn](val)
				};
				return NumberT
			}();
			exports.Number = NumberT;
			exports.uint8 = new NumberT("UInt8");
			exports.uint16be = exports.uint16 = new NumberT("UInt16", "BE");
			exports.uint16le = new NumberT("UInt16", "LE");
			exports.uint24be = exports.uint24 = new NumberT("UInt24", "BE");
			exports.uint24le = new NumberT("UInt24", "LE");
			exports.uint32be = exports.uint32 = new NumberT("UInt32", "BE");
			exports.uint32le = new NumberT("UInt32", "LE");
			exports.int8 = new NumberT("Int8");
			exports.int16be = exports.int16 = new NumberT("Int16", "BE");
			exports.int16le = new NumberT("Int16", "LE");
			exports.int24be = exports.int24 = new NumberT("Int24", "BE");
			exports.int24le = new NumberT("Int24", "LE");
			exports.int32be = exports.int32 = new NumberT("Int32", "BE");
			exports.int32le = new NumberT("Int32", "LE");
			exports.floatbe = exports.float = new NumberT("Float", "BE");
			exports.floatle = new NumberT("Float", "LE");
			exports.doublebe = exports.double = new NumberT("Double", "BE");
			exports.doublele = new NumberT("Double", "LE");
			Fixed = function(_super) {
				__extends(Fixed, _super);

				function Fixed(size, endian, fracBits) {
					if (fracBits == null) {
						fracBits = size >> 1
					}
					Fixed.__super__.constructor.call(this, "Int" + size, endian);
					this._point = 1 << fracBits
				}
				Fixed.prototype.decode = function(stream) {
					return Fixed.__super__.decode.call(this, stream) / this._point
				};
				Fixed.prototype.encode = function(stream, val) {
					return Fixed.__super__.encode.call(this, stream, val * this._point | 0)
				};
				return Fixed
			}(NumberT);
			exports.Fixed = Fixed;
			exports.fixed16be = exports.fixed16 = new Fixed(16, "BE");
			exports.fixed16le = new Fixed(16, "LE");
			exports.fixed32be = exports.fixed32 = new Fixed(32, "BE");
			exports.fixed32le = new Fixed(32, "LE")
		}).call(this)
	}, {
		"./DecodeStream": 8
	}],
	13: [function(require, module, exports) {
		(function() {}).call(this)
	}, {}],
	14: [function(require, module, exports) {
		(function() {
			var Pointer, VoidPointer, utils;
			utils = require("./utils");
			Pointer = function() {
				function Pointer(offsetType, type, options) {
					var _base, _base1, _base2, _base3;
					this.offsetType = offsetType;
					this.type = type;
					this.options = options != null ? options : {};
					if (this.type === "void") {
						this.type = null
					}
					if ((_base = this.options).type == null) {
						_base.type = "local"
					}
					if ((_base1 = this.options).allowNull == null) {
						_base1.allowNull = true
					}
					if ((_base2 = this.options).nullValue == null) {
						_base2.nullValue = 0
					}
					if ((_base3 = this.options).lazy == null) {
						_base3.lazy = false
					}
					if (this.options.relativeTo) {
						this.relativeToGetter = new Function("ctx", "return ctx." + this.options.relativeTo)
					}
				}
				Pointer.prototype.decode = function(stream, ctx) {
					var c, decodeValue, offset, ptr, relative, val;
					offset = this.offsetType.decode(stream);
					if (offset === this.options.nullValue && this.options.allowNull) {
						return null
					}
					relative = function() {
						switch (this.options.type) {
							case "local":
								return ctx._startOffset;
							case "immediate":
								return stream.pos - this.offsetType.size();
							case "parent":
								return ctx.parent._startOffset;
							default:
								c = ctx;
								while (c.parent) {
									c = c.parent
								}
								return c._startOffset || 0
						}
					}.call(this);
					if (this.options.relativeTo) {
						relative += this.relativeToGetter(ctx)
					}
					ptr = offset + relative;
					if (this.type != null) {
						val = null;
						decodeValue = function(_this) {
							return function() {
								var pos;
								if (val != null) {
									return val
								}
								pos = stream.pos;
								stream.pos = ptr;
								val = _this.type.decode(stream, ctx);
								stream.pos = pos;
								return val
							}
						}(this);
						if (this.options.lazy) {
							return new utils.PropertyDescriptor({
								get: decodeValue
							})
						}
						return decodeValue()
					} else {
						return ptr
					}
				};
				Pointer.prototype.size = function(val, ctx) {
					var parent, type;
					parent = ctx;
					switch (this.options.type) {
						case "local":
						case "immediate":
							break;
						case "parent":
							ctx = ctx.parent;
							break;
						default:
							while (ctx.parent) {
								ctx = ctx.parent
							}
					}
					type = this.type;
					if (type == null) {
						if (!(val instanceof VoidPointer)) {
							throw new Error("Must be a VoidPointer")
						}
						type = val.type;
						val = val.value
					}
					if (val && ctx) {
						ctx.pointerSize += type.size(val, parent)
					}
					return this.offsetType.size()
				};
				Pointer.prototype.encode = function(stream, val, ctx) {
					var parent, relative, type;
					parent = ctx;
					if (val == null) {
						this.offsetType.encode(stream, this.options.nullValue);
						return
					}
					switch (this.options.type) {
						case "local":
							relative = ctx.startOffset;
							break;
						case "immediate":
							relative = stream.pos + this.offsetType.size(val, parent);
							break;
						case "parent":
							ctx = ctx.parent;
							relative = ctx.startOffset;
							break;
						default:
							relative = 0;
							while (ctx.parent) {
								ctx = ctx.parent
							}
					}
					if (this.options.relativeTo) {
						relative += this.relativeToGetter(parent.val)
					}
					this.offsetType.encode(stream, ctx.pointerOffset - relative);
					type = this.type;
					if (type == null) {
						if (!(val instanceof VoidPointer)) {
							throw new Error("Must be a VoidPointer")
						}
						type = val.type;
						val = val.value
					}
					ctx.pointers.push({
						type: type,
						val: val,
						parent: parent
					});
					return ctx.pointerOffset += type.size(val, parent)
				};
				return Pointer
			}();
			VoidPointer = function() {
				function VoidPointer(type, value) {
					this.type = type;
					this.value = value
				}
				return VoidPointer
			}();
			exports.Pointer = Pointer;
			exports.VoidPointer = VoidPointer
		}).call(this)
	}, {
		"./utils": 19
	}],
	15: [function(require, module, exports) {
		(function() {
			var Reserved, utils;
			utils = require("./utils");
			Reserved = function() {
				function Reserved(type, count) {
					this.type = type;
					this.count = count != null ? count : 1
				}
				Reserved.prototype.decode = function(stream, parent) {
					stream.pos += this.size(null, parent);
					return void 0
				};
				Reserved.prototype.size = function(data, parent) {
					var count;
					count = utils.resolveLength(this.count, null, parent);
					return this.type.size() * count
				};
				Reserved.prototype.encode = function(stream, val, parent) {
					return stream.fill(0, this.size(val, parent))
				};
				return Reserved
			}();
			module.exports = Reserved
		}).call(this)
	}, {
		"./utils": 19
	}],
	16: [function(require, module, exports) {
		(function(Buffer) {
			(function() {
				var NumberT, StringT, utils;
				NumberT = require("./Number").Number;
				utils = require("./utils");
				StringT = function() {
					function StringT(length, encoding) {
						this.length = length;
						this.encoding = encoding != null ? encoding : "ascii"
					}
					StringT.prototype.decode = function(stream, parent) {
						var buffer, encoding, length, pos, string;
						length = function() {
							if (this.length != null) {
								return utils.resolveLength(this.length, stream, parent)
							} else {
								buffer = stream.buffer, length = stream.length, pos = stream.pos;
								while (pos < length && buffer[pos] !== 0) {
									++pos
								}
								return pos - stream.pos
							}
						}.call(this);
						encoding = this.encoding;
						if (typeof encoding === "function") {
							encoding = encoding.call(parent) || "ascii"
						}
						string = stream.readString(length, encoding);
						if (this.length == null && stream.pos < stream.length) {
							stream.pos++
						}
						return string
					};
					StringT.prototype.size = function(val, parent) {
						var encoding, size;
						if (!val) {
							return utils.resolveLength(this.length, null, parent)
						}
						encoding = this.encoding;
						if (typeof encoding === "function") {
							encoding = encoding.call(parent != null ? parent.val : void 0) || "ascii"
						}
						if (encoding === "utf16be") {
							encoding = "utf16le"
						}
						size = Buffer.byteLength(val, encoding);
						if (this.length instanceof NumberT) {
							size += this.length.size()
						}
						if (this.length == null) {
							size++
						}
						return size
					};
					StringT.prototype.encode = function(stream, val, parent) {
						var encoding;
						encoding = this.encoding;
						if (typeof encoding === "function") {
							encoding = encoding.call(parent != null ? parent.val : void 0) || "ascii"
						}
						if (this.length instanceof NumberT) {
							this.length.encode(stream, Buffer.byteLength(val, encoding))
						}
						stream.writeString(val, encoding);
						if (this.length == null) {
							return stream.writeUInt8(0)
						}
					};
					return StringT
				}();
				module.exports = StringT
			}).call(this)
		}).call(this, require("buffer").Buffer)
	}, {
		"./Number": 12,
		"./utils": 19,
		buffer: 116
	}],
	17: [function(require, module, exports) {
		(function() {
			var Struct, utils;
			utils = require("./utils");
			Struct = function() {
				function Struct(fields) {
					this.fields = fields != null ? fields : {}
				}
				Struct.prototype.decode = function(stream, parent, length) {
					var res, _ref;
					if (length == null) {
						length = 0
					}
					res = this._setup(stream, parent, length);
					this._parseFields(stream, res, this.fields);
					if ((_ref = this.process) != null) {
						_ref.call(res, stream)
					}
					return res
				};
				Struct.prototype._setup = function(stream, parent, length) {
					var res;
					res = {};
					Object.defineProperties(res, {
						parent: {
							value: parent
						},
						_startOffset: {
							value: stream.pos
						},
						_currentOffset: {
							value: 0,
							writable: true
						},
						_length: {
							value: length
						}
					});
					return res
				};
				Struct.prototype._parseFields = function(stream, res, fields) {
					var key, type, val;
					for (key in fields) {
						type = fields[key];
						if (typeof type === "function") {
							val = type.call(res)
						} else {
							val = type.decode(stream, res)
						}
						if (val !== void 0) {
							if (val instanceof utils.PropertyDescriptor) {
								Object.defineProperty(res, key, val)
							} else {
								res[key] = val
							}
						}
						res._currentOffset = stream.pos - res._startOffset
					}
				};
				Struct.prototype.size = function(val, parent, includePointers) {
					var ctx, key, size, type, _ref;
					if (val == null) {
						val = {}
					}
					if (includePointers == null) {
						includePointers = true
					}
					ctx = {
						parent: parent,
						val: val,
						pointerSize: 0
					};
					size = 0;
					_ref = this.fields;
					for (key in _ref) {
						type = _ref[key];
						if (type.size != null) {
							size += type.size(val[key], ctx)
						}
					}
					if (includePointers) {
						size += ctx.pointerSize
					}
					return size
				};
				Struct.prototype.encode = function(stream, val, parent) {
					var ctx, i, key, ptr, type, _ref, _ref1;
					if ((_ref = this.preEncode) != null) {
						_ref.call(val, stream)
					}
					ctx = {
						pointers: [],
						startOffset: stream.pos,
						parent: parent,
						val: val,
						pointerSize: 0
					};
					ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
					_ref1 = this.fields;
					for (key in _ref1) {
						type = _ref1[key];
						if (type.encode != null) {
							type.encode(stream, val[key], ctx)
						}
					}
					i = 0;
					while (i < ctx.pointers.length) {
						ptr = ctx.pointers[i++];
						ptr.type.encode(stream, ptr.val, ptr.parent)
					}
				};
				return Struct
			}();
			module.exports = Struct
		}).call(this)
	}, {
		"./utils": 19
	}],
	18: [function(require, module, exports) {
		(function() {
			var Struct, VersionedStruct, __hasProp = {}.hasOwnProperty,
				__extends = function(child, parent) {
					for (var key in parent) {
						if (__hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				};
			Struct = require("./Struct");
			VersionedStruct = function(_super) {
				__extends(VersionedStruct, _super);

				function VersionedStruct(type, versions) {
					this.type = type;
					this.versions = versions != null ? versions : {};
					if (typeof this.type === "string") {
						this.versionGetter = new Function("parent", "return parent." + this.type);
						this.versionSetter = new Function("parent", "version", "return parent." + this.type + " = version")
					}
				}
				VersionedStruct.prototype.decode = function(stream, parent, length) {
					var fields, res, _ref;
					if (length == null) {
						length = 0
					}
					res = this._setup(stream, parent, length);
					if (typeof this.type === "string") {
						res.version = this.versionGetter(parent)
					} else {
						res.version = this.type.decode(stream)
					}
					if (this.versions.header) {
						this._parseFields(stream, res, this.versions.header)
					}
					fields = this.versions[res.version];
					if (fields == null) {
						throw new Error("Unknown version " + res.version)
					}
					if (fields instanceof VersionedStruct) {
						return fields.decode(stream, parent)
					}
					this._parseFields(stream, res, fields);
					if ((_ref = this.process) != null) {
						_ref.call(res, stream)
					}
					return res
				};
				VersionedStruct.prototype.size = function(val, parent, includePointers) {
					var ctx, fields, key, size, type, _ref;
					if (includePointers == null) {
						includePointers = true
					}
					if (!val) {
						throw new Error("Not a fixed size")
					}
					ctx = {
						parent: parent,
						val: val,
						pointerSize: 0
					};
					size = 0;
					if (typeof this.type !== "string") {
						size += this.type.size(val.version, ctx)
					}
					if (this.versions.header) {
						_ref = this.versions.header;
						for (key in _ref) {
							type = _ref[key];
							if (type.size != null) {
								size += type.size(val[key], ctx)
							}
						}
					}
					fields = this.versions[val.version];
					if (fields == null) {
						throw new Error("Unknown version " + val.version)
					}
					for (key in fields) {
						type = fields[key];
						if (type.size != null) {
							size += type.size(val[key], ctx)
						}
					}
					if (includePointers) {
						size += ctx.pointerSize
					}
					return size
				};
				VersionedStruct.prototype.encode = function(stream, val, parent) {
					var ctx, fields, i, key, ptr, type, _ref, _ref1;
					if ((_ref = this.preEncode) != null) {
						_ref.call(val, stream)
					}
					ctx = {
						pointers: [],
						startOffset: stream.pos,
						parent: parent,
						val: val,
						pointerSize: 0
					};
					ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
					if (typeof this.type !== "string") {
						this.type.encode(stream, val.version)
					}
					if (this.versions.header) {
						_ref1 = this.versions.header;
						for (key in _ref1) {
							type = _ref1[key];
							if (type.encode != null) {
								type.encode(stream, val[key], ctx)
							}
						}
					}
					fields = this.versions[val.version];
					for (key in fields) {
						type = fields[key];
						if (type.encode != null) {
							type.encode(stream, val[key], ctx)
						}
					}
					i = 0;
					while (i < ctx.pointers.length) {
						ptr = ctx.pointers[i++];
						ptr.type.encode(stream, ptr.val, ptr.parent)
					}
				};
				return VersionedStruct
			}(Struct);
			module.exports = VersionedStruct
		}).call(this)
	}, {
		"./Struct": 17
	}],
	19: [function(require, module, exports) {
		(function() {
			var NumberT, PropertyDescriptor;
			NumberT = require("./Number").Number;
			exports.resolveLength = function(length, stream, parent) {
				var res;
				if (typeof length === "number") {
					res = length
				} else if (typeof length === "function") {
					res = length.call(parent)
				} else if (parent && typeof length === "string") {
					res = parent[length]
				} else if (stream && length instanceof NumberT) {
					res = length.decode(stream)
				}
				if (isNaN(res)) {
					throw new Error("Not a fixed size")
				}
				return res
			};
			PropertyDescriptor = function() {
				function PropertyDescriptor(opts) {
					var key, val;
					if (opts == null) {
						opts = {}
					}
					this.enumerable = true;
					this.configurable = true;
					for (key in opts) {
						val = opts[key];
						this[key] = val
					}
				}
				return PropertyDescriptor
			}();
			exports.PropertyDescriptor = PropertyDescriptor
		}).call(this)
	}, {
		"./Number": 12
	}],
	20: [function(require, module, exports) {
		module.exports = {
			categories: ["Cc", "Zs", "Po", "Sc", "Ps", "Pe", "Sm", "Pd", "Nd", "Lu", "Sk", "Pc", "Ll", "So", "Lo", "Pi", "Cf", "No", "Pf", "Lt", "Lm", "Mn", "Me", "Mc", "Nl", "Zl", "Zp", "Cs", "Co"],
			combiningClasses: ["Not_Reordered", "Above", "Above_Right", "Below", "Attached_Above_Right", "Attached_Below", "Overlay", "Iota_Subscript", "Double_Below", "Double_Above", "Below_Right", "Above_Left", "CCC10", "CCC11", "CCC12", "CCC13", "CCC14", "CCC15", "CCC16", "CCC17", "CCC18", "CCC19", "CCC20", "CCC21", "CCC22", "CCC23", "CCC24", "CCC25", "CCC30", "CCC31", "CCC32", "CCC27", "CCC28", "CCC29", "CCC33", "CCC34", "CCC35", "CCC36", "Nukta", "Virama", "CCC84", "CCC91", "CCC103", "CCC107", "CCC118", "CCC122", "CCC129", "CCC130", "CCC132", "Attached_Above", "Below_Left", "Left", "Kana_Voicing", "CCC26", "Right"],
			scripts: ["Common", "Latin", "Bopomofo", "Inherited", "Greek", "Coptic", "Cyrillic", "Armenian", "Hebrew", "Arabic", "Syriac", "Thaana", "Nko", "Samaritan", "Mandaic", "Devanagari", "Bengali", "Gurmukhi", "Gujarati", "Oriya", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhala", "Thai", "Lao", "Tibetan", "Myanmar", "Georgian", "Hangul", "Ethiopic", "Cherokee", "Canadian_Aboriginal", "Ogham", "Runic", "Tagalog", "Hanunoo", "Buhid", "Tagbanwa", "Khmer", "Mongolian", "Limbu", "Tai_Le", "New_Tai_Lue", "Buginese", "Tai_Tham", "Balinese", "Sundanese", "Batak", "Lepcha", "Ol_Chiki", "Braille", "Glagolitic", "Tifinagh", "Han", "Hiragana", "Katakana", "Yi", "Lisu", "Vai", "Bamum", "Syloti_Nagri", "Phags_Pa", "Saurashtra", "Kayah_Li", "Rejang", "Javanese", "Cham", "Tai_Viet", "Meetei_Mayek", "null", "Linear_B", "Lycian", "Carian", "Old_Italic", "Gothic", "Old_Permic", "Ugaritic", "Old_Persian", "Deseret", "Shavian", "Osmanya", "Elbasan", "Caucasian_Albanian", "Linear_A", "Cypriot", "Imperial_Aramaic", "Palmyrene", "Nabataean", "Hatran", "Phoenician", "Lydian", "Meroitic_Hieroglyphs", "Meroitic_Cursive", "Kharoshthi", "Old_South_Arabian", "Old_North_Arabian", "Manichaean", "Avestan", "Inscriptional_Parthian", "Inscriptional_Pahlavi", "Psalter_Pahlavi", "Old_Turkic", "Old_Hungarian", "Brahmi", "Kaithi", "Sora_Sompeng", "Chakma", "Mahajani", "Sharada", "Khojki", "Multani", "Khudawadi", "Grantha", "Tirhuta", "Siddham", "Modi", "Takri", "Ahom", "Warang_Citi", "Pau_Cin_Hau", "Cuneiform", "Egyptian_Hieroglyphs", "Anatolian_Hieroglyphs", "Mro", "Bassa_Vah", "Pahawh_Hmong", "Miao", "Duployan", "SignWriting", "Mende_Kikakui"],
			eaw: ["N", "Na", "A", "W", "H", "F"]
		}
	}, {}],
	21: [function(require, module, exports) {
		(function(Buffer) {
			var CATEGORY_BITS, CATEGORY_MASK, CATEGORY_SHIFT, COMBINING_BITS, COMBINING_MASK, COMBINING_SHIFT, EAW_BITS, EAW_MASK, EAW_SHIFT, NUMBER_BITS, NUMBER_MASK, SCRIPT_BITS, SCRIPT_MASK, SCRIPT_SHIFT, UnicodeTrie, bits, data, fs, log2, trie;
			UnicodeTrie = require("unicode-trie");
			data = require("./data.json");
			trie = new UnicodeTrie(Buffer("ABEAAAAAAAAAEKiQ5ZlpWFPX2vd73lPrafWIdQBlirUqKggKIqOkWhVxgGJFZIyCiMgQIUCAQNIjRxEZoqIiQogaBgcGAZkhEZFEQIiMAQKJECHGEEIImciwX2x7TrGnp+u9ng/vl2dfXNlJdvZa6/7t//rf91pMDqHfPNNQBgL8sjccSNRdbRc9uWHX5MnvbXfYXDWY/3CyInqFXvTkQJk/Lf3j549vpiQStB13g03WhrM3LLJscN7NU6x2ssNko8yCPlOg8t3zg2vP9u3mOyqelpehLkSEi6dXxAvXyXP/ue/lhrwz71bdPN6781lk/Pu1a7LueJwcHLCxrq2JjfkS65ywd73fimPmEV8d2npe19PWgS33ZXfjRgxDHDed1T6xK3qZs2mYoe9Fof+2P2uKQq/uVw2QP4czqqdwLsxrV+788+Ykn1sbusdp/9HvD8s6UP/Rc1jwug3rN32z8dvCe3kPCu7nc76nP3/18vWLNmpnU2tLR/Ph6QTJl8lXnA62vtqy+dHDoHM8+RuLBRHi2EjIZHcY5fP7UctXfJ1x7cb1H//JJiN40b90SOf9vkNDPqhD8YeVv7b0wzHXnjfdovuBp874nT0d4M99+25sYnSjXDH7Z0P6CB3+e6CzS1OPvDZhC72I2X3RvzVU/I+fIaXmXLxx9e7l2+lau//67UqLJcZ6douNdKy0zJrM7rkc3Hdk76EDzr8wpCXl/uN6ctalW2mExIyU7KTMtzq9Rn8e0HIeKJ5LoHhUL+ZAEvr6jyMuCpnUz/Eetm/4nPLQ4Zuvd3y5Za3Noo2rLf++zQAW98WBT9SFOEIE0SgB0ch8A6LBB9HY+KeC+0jjGJBGEJBGKpDGCSCNQiANBoDGtfcgGquB2rgKpLERSKMcSGM/iEbpYxAN9x4QDeDM18yxIS+2zvfMhWOZyk74D5v5yXL5nzal/gvbVvrWvfoLEJnLQDI/Asnkg8gw+kFkgB4SBdRJHVAnu4E6IYNosL8D0UA+BNGwmpOKBWw3cuCUHBASFRjSSmBIj4AhAW0RCbTFapAtTv/1v7ie5jlSnYCs+rWrPaf//ucRU4KUVts/6Uo5wXb+fUgqL+5V8nUcgTFI7qS/Q3A9qkrFGxWMWLyAr9qviTL0U9oSr+EIOgNkMpuLYPdUlwqZCoZsQsBXIjWS3VJxVOie6ai051aMv8Sjil9IK9VnbxNxQuJztHTA5a3YshCCpnAWeOhsvwbSTAaHGcZ3UOAI1OTbYEO14q7xYgRqlM7wtpLfpWPJE0VNjIZZsaVsKXkik1hqc2ba0kV19qycUByudLLXjJCZaGUYW1BIQZa0yE19mhkSfSYjaq2CIVk9f14xf142f14yf148f/58/vwZk+ENh+7SkQiUVBXsS07oaBSXKiRSy6ROykTr/EVr6K4wDIEaUgWz6hI6js5f5Eotaa8pE9fnL+6A7mrNXyTP31md0DEyU6oYlFouVpZoNDKfbfI9Gq2D8kRyFLw87beHhXvjooobscJ3/UufOAFmIPejvNijUYmwkIR/7oPLjaZaDA//9nzJGWq4If/jw6PkVg+UhLBPU0YEv6ol6SRfS9Ev3vury40lxSv5t8LcexF4y6ptI1Yy3CuXOZmUwMNtJUJpTQ6filErqmi+u1k7lcOw8y/dYd+7YHdXcnc+gydzo9n2zpBE3BR9Zq4OzjQtQsismOrCe0oDg1xchPr4lMxgRJqA1ZVCa8crqW+TFD4r/qvvqE7DsVAE9NF8Rvv3fpwAc824OX3cRBTql8lWh6z7/WyDv9jx9S8NQleEc/Qm9K0XZZk/C5ndYLTgxxCc3dyO/Sh4Hnr/J3PLHZvEiK7/eRRbcEOsUqLnE9b8JFKsnC0lNvEVYXAyUwnNW8NB4u4XMIVFCSyoZcF0YRelfZyaCqOyiRaOsZ4SPZPT7P/rJOY1gipT0u88FtuLVnM/FN6plP48cniGfvN5wscHwWAMCYkX/WPsuRvlXVj2v6csfI4pKx4umVfMLFozN6+Ynt8XrtmVX/8BcE1VKcWF+dFOxExygppRrZbTULgRHFlgBLE0r99G6Tchx9UbAcP3ApVeD4E5ZBfQcL2AhksAGq4vyHCFwKocDarKp+1AKfUhsA7tBNLQAdJ4AqRxFEgDmH5kwPSDAZVe54Da8AXSQAJp4IE03IE0gFW5DFSVTy8GleXngNr4B4iGZh2IBu4piAZ8H4gGDFiVa4Gq8ukkkG+8B2rjayCNg0AaN4E0PIE0SCAa+D4QDf8/DBa6Uyqur/qtJ5ru3wBIwoFIYoBILgKRuIKQEPNASFxAi5PpQtB0eQ+cLif/IFa4tDBeYxE7tbArTlHGtStyWgKD/hTruaGfeOM6zoh2LKbo11K3Fp4BU1rF0X63Cad65LAERHsnkHYdkPb3QNqPALRPAZ06ELgUrADStgFqzxtIIxdIAwGigQCl8VPALK4D3DJIAZpTC5DGCiAN4CqSAlxFIkBp/FQ3iIY7cDvJGKgNNyCN80AaaUAawM01BCiNnwLaEgO41agH1EYakMYmII0KIA3g5hoblMZPdYFoVAN9gwnUhgGQxn/8J+M/aGQCaXgBaYDS+ClgFpcBfUMJ1IYaSOMvIBrQPRAN3EEQDXgRiAawwsMDfcMRqA1/II1wII1/AmkcA9IAbbaeAlb/LkDfCARqowJIwwZIowFIYw+IBgW42QqsN8yAvpEJ1IYxkIYbkMZdIA0fII37IBrAegMJ9I1qoDaYQBoGQBolQBouQBqlIBrAegMG9A0toDYcgTT8gTSSQTSg4yAauAIQDWC9QQT6hhlQG5lAGsZAGpVAGgeANJ6AaADrDTbQN4RAbWgBaTgCaWQAaXiAaEAPQDSA9QYF6BtsoDaEQBpaQBqFQBqHgTSKATTWyQ2bZBsAQHYDwzUB7ieeAIULzwaFSwQmDfrCpNEB9bDUL63jWLF+RikmN9zCnHJ8kFUZR9e3WWQIOmLQmMRF69ctdrX425vvpPeGP3+3ro362aJJ/a1Wf7WpeVfb21WrOBsn2xswdBn1JLGswP7Vi+826QXfTGt8dX9gZnLfq7gvVlp/98WrPYoZRN9hbY8NfNgTTyKCQ+ImEGUKiGymIPeNfEi0TkW+dNWnVXPsutJ8VdudH8DgacQWM7/lxBZEC8LxUa6GtBZPWu0yFtSwVhCjLXxZ35UMuimMfOzbuyJrT9GGXGp2V3qgyLlBj2B9pVl+QL8lPN6OvHLkfYsWZ8OcqEfuoVr/hchD5aaKuintxu3khD8bc7JPsyIZ0McIMVa24cuTRGnWVzny6Hijuq4UGNVpllMoqpDvXzpWIX8i528WFELnqJxzLRkxusgDdrktdqKwyLF1yzh64au88OcdXjxR/A0uiwmjrHbZxHQx4mX3cMbPO0w8WNE3kObZS/oaUwa7JM3VThVjjREr0aftMyfOOMyHSJqtnumL1KGq4YRZKJJZ6Htl37eUApmaEwLPDYGlzug1465vZrpchjI77av+Xso8YDii26rHsktzrS28dYDc5n+MbPHI7jHF4jWMAUmNBjXW2N2mzNcGopD7RodnrLZkhm/brTmThyqw5Dp9k1B+CudR66fH0Zj1IztuJuwaxEZXUYLmznRE7+JxWy/OtH+AexzTxOdmykTvbtjklLLHxd79kFvP0QmKrU90UcWD1yppxaIo7VteJwI9sqJojVNy7Vtrbb235zbbNHPYW3oRDbtx20Jus4ajymNynvS/C3DO9Ige2eZVIVF6zSoak/n9FMQyYQ1l6lB+ZYNF95285gbqu5Oke3fg9erOvWk2+bWRohizqp5ca2FwLDHb+pwkzNfOFnU51nHJTFLdSv4EooDyPD7LjQM70h0QVRCbv1HRYiuoVXcnORmZhiDJ/Y4Kfdu2hO1Hkxgtrp18hcY6/YCCYJFvr1zW/prW9a5uDSzYeSg2+kTVHWeltXOcT3PNZEwZJZZmdcrNLmWOYEAv3+HgZSzYJPD9xsehoBCVYGIYDMfaOpWOFXoxBh9jv2m8GyjbsHuzRBxr3pu1RpCJtS4TiEbOxvXVMQ2rI9ckhrAde9a8y4i7JuzeT6XZyfqtL/snVGwnJibTOKkyTH63HmpCzNJcCK/1U+zXrrQ6z28WSRc7UXRgLSmbIa1WfDVHLV9HthK5NlyZge2fEFO3d9jE2PGUGYIgRLPg9Iibq0ODnbESmR66vHima1FzYf0JRdAe1JjovecaJCw1oNFU0gS75clOwWvOHUcPSGvYE3nFzcW6DmalXlUWctLw13TxyBrHwakD8KFBoT1cyZp850GRaG5IYnBn64e3VqM/0Sxqu+Xani5xcek3+zNQqNbdO8gU7WG7nmDSsEH2hFY7Ge4eNsz+guESnpqBsWIKUmVbL3d1Bu7HDFBlufie0FdxzyoMSZFdUuWlBoXASrvX63Z6p1eQuVCsqcY1+rhwWR9CT7WiOR82w8Y1yYeO+1udd8UfmGzB3kzvpvWP63p/UDvdpaeVJZ7TjtQx/c5KwLqaGnBgjnKt+lV87UZJJ43dUH561qLfKxNlYZmmyYOiprqO+liaxtNMhnKnXBpfVfjY0Nch7SmTNoE88Zt73pErkswetaoc4hwG4VvuIJL2849Nj8WehqYns1DT1JdHRo5SrRocHOnj43scdEgLSDzKQDcPk9x9Mrs7f5gbsVmrR+0cHS8oC4EKis9j4hrWtFNVGdyMhoyLrKKKXV8FHxuGZhUtGu39ZVMPLLPXco6wx7udMUZbXdNGHu7frVumo3R9CMW8f/YMpRLL7R2SETTkvnSD1HaTKyfmDOyyJmGmkWWsEE15HKPysUBRZsI0FGjRoc1Q3il7KIAfcZrgkIC9PxxQFtKQua/2lhh26yE1rPeBYdpAinpzTr0fLBMf6DC0BR5tPgj3DiIP10lK/NyYLZz2ttwOSy4uB33sTf0pUd2RNp1OXJngyUvFGrry6Lse3OyTT0KWNW2USer8J/PYzhN9Wa8rMmYybUqrY36OGWuSmW7zc1N30EiqIr6TkVfDzqqHzLx6UhTtVJsedG1GxcJxHSQknla72NrRYLRSzk6sIRF9magMprrOOdxNDb5jau6F3YUjlPcIFA37x29LKjbjDHS4GPMuO6ZvvOrdC43rqMrsfP0AdTUp/uYn8VqrT3FjlputVxuYiGJuml4Nm2B3WBdSY5My75pVOBP4NcnSQG68dZas14k3ppsDI7KFJTVQvR3bLIoyo77EjyybHH0dU8ClZH/SbE2kPic6vaczfMimpDO0kCKy7HKhqF/Xw7MwcE7t6/isqA/etE0CM2O7NKwDRIs1shCbejZsMuJGnciB/BrHAyZoQ3pZudXYTtzxB7r1rilxO/3MpP4FaU+o69TLzFlNZ14nPovKUpjze2u1OrmYmF3sMlZqeJaYI1YmzreAaWdIZoJPRcdzE4za5r94uM8ymqQtOffSd5LGS4nX0FLkZ64F/iSXnJrC4K4p4/vu3txq5E8SNGe7pmafF5eTd22p7qy5KmpfJFNFdhyI4x6gxS1pM3lq3ZZvr3Dc+LhMr/Kh47dSP7h2an5tUUd+V5s3rIo1HN0kTMCFdCmMd5PzOqZqNAwKPLhAfXZeY6sWwFlz28BjlWCWkeuN7Il005Tf6c8qrX+tEvkpM9MCTiDD6t9qUeDmJQw74/qQBm5CJI0HhzRFTnoZm/Gsa8YkxL9FxjYdNhInRB1Y9tVdxoUfDhqRWXrZPM6R2gzRwiE6TB1Ph4TyNJkxDdqs4cuRHAoe2uFgWGCDZQXuUDefHrpqdGn2zNj0seaTbhMlHY5cPAXxQWW+tTlWc+pGp2JcFpg249JZjUOtJ64koaxHENaXFwnMdvhSJO3sS6I72r74/Cx+dGvZ4JyOMHGUrbPNlk5Z4+hBT+KceWAV6OqrEolFZd4/fqvzAXYbHwEtHNuxqtqXdf4EOCvbLvrYdjZ1ffuQZy/DNi4/xd+3W8agUxua5givK3Hbu4vt6zMv7zjKJd1hd9jar8o/ZhGE3iR0GXjsENL1063LZZuRrpoHce7FOMSwTMRmiFGIfi65BNLpGLz7rlF6hPXNiYG1x9ONf7OQ8LkHEarYBk3QuLw4xoy8lp0GowUtjVD13Im93ahpWNZfvvMxvebvgXymR8iK4g/Z4X/77Hljf04N1ktw/ttlwoPGua/tNegb9LhD+RO97PfHlTgLsn5wr5ehow35UYskzh9XNUc/q0PKrrMiWe36gKtzfkIifnxfHrT0GPpHsYSqbLye5i+b3tiTbb0lxCyifC8yDHMJp4wvHzF53ymAG+JF1XRIdSSounHlAvWcjJYeg6wl+B//4CWzz6zSvOQ+b7fFSJiAHBs96V369lwvzpiDX5AdghXyns7R3d2Ni/1rPJ74MTle7UJcTaRpcbwmvKuuq7MurL0G8m1qzUlR6NAQJnYI3BhF9bS3MzBMKTPDwqvQWhPS7O/Hu9hypoE6mXp+Ka7vV++MMseH3qEG0PqTSTdxB6ssNRtdHdqiViwYfHjWoPAtyRv9ff42/tmw6k0yb6uPf28HFGpGR8KuXpfaTLrT7Fc8v+b33NrwKtV41Nn2jmx9SNB+lAQpGyPgjLML/ECZaY/zrcBSmQ370LyyoMivIEr/GIQLuz8m6tZylCz2KPUwCpdfULvQjVB3iO6l13DlzzdAbM37bimXDq3jwhdklOt1HYf1i4wYU+uIRqTILMuhrGRP5Hq6dmXzNpstqSTr3L0aIrQ5Vycd/+H24coGeP+M5mS70j/3hwe/2ko32UvWR4nPnd0Qt9JoUWOt/3XJWs/VxZ6oA3YJI2ZGxrMnNt9UZlbAU4LxE3Yk+zmKZ+8BXHChbdyL4jRs38/TuaSSO2Sjh6zNmHNNPj95YNuHriuNA/hjRuPVpPp9qLxnbVc3Y4VLcWHdvFLRiEUmYishlb/NVVfN9OFelkyIL4emDgWtxt/6yt8rAv4ue9rB1vMe3LY/YTpd+2Tp6wn+AMWvkVmmrpxfXmQpI7oq3r3gwKha1NiR1ZKqMzyuG69ZXLsUgnfkh0IYt+5MC58AJidjWQ/pVm7x0xrWztt9dnCsnZqdKXJhnrzN0qjcO5Bug8KiC9AHemcwtvFyFCtLH1N4qmdOh7/Nl5HC6AiQMOwgrkSHQIuiwdOpX3R6bTu68wBk2nbSnyqXXdfLR76sdkTq5ndJVVjxkUdPE3JlPfJBD1yFrs6HW1/xaucvB87QmELnVe0OhFRBq7dm6/zqIB6TGWSS5R7kpFk0PkrRZeiqva6QBkJvpge3PnHUhbNS1KezRPICqhhz7MMyvjCvc5aNZz3EBj3rGxkIsfd95DEQVuSKTWDgKwKneMo5VUUMrqmsWyuwg7u6HT0x5CEXJ/JfNr2cZvMNkVZfxXKVhFbNce5eX/9ncGa/PC626nlTFvWiA57eltozKm7LWCKhK5EdqcGawG8Je3FiDrbuu3AsYa+6MFDwjBoLYabSEC8pyfCORnGQCjmoqZDjHniaGkD8PJwxj46ahNIoje62Grp/YIxw9xbJJw4lO6R2dEIky8jHPmixNkvsnBAbfOqxxhIvHb5WI1HgkuFM/JKfEYFIQWyiDK8ZgXok2WmjlDJsV9MibjBmO5eny0wpsiW/H6pzqhAHHanSC04PHilDJHjzg1Z1Uy/6py0K0OnzuUkxQWriPPpZY8HBsbDMysYQZ34JPQBVb4IjSBk+2e3SUv4mJgLd0V+M85p6TFSG9nGdnuzE9mcXWCk8ogZlL2odecqujQkVvDhkhTAUQWdWdYSbXQ0tpRVwGnkDH2JMGzCOv4R0F33pY0TunMpzVORL9hXKWkQ6Xabd0M6ukGqT9Z52T3N3WiV0HhBGyU6FabWpAl9U0SrOxz8ZPo5zN3AsU0VNVMbY61DcrbZZIaR1Yh+ZfZFXYFRtBzHTNFtWbv5khsusS7as/5JpSC/n4wYtd9Srl+ei3elKBwmllcs6igtDBNqjJQki85onsewj8OLuSTqi/xAj4Qt9jeG+ALlyVZmXpwqDKxyXtIeqh8PCutBjkduqZaja89QfOtbczreypJKG/jK9qFLNxr3VnLt1aAnFvyQ7DOPLRPQoK7RlAfrPpaFKNX8Xix12/mhJ1Vmm2qZ9Z1WC71S79QQNdWtH8Y/ckrGzSkF/7u6THBHasOj0a01CUeAltRsOHUxWPYhLOQLpa2rC0HnfNlrx3jStQAV4NaIyGi7JYh55zIZXR8aTEbzhw6Rw99uvC6+xSw3IvaYp2GK9jsPt3p4QnchupaBRHkWPoXKYkMsaKVBQvkXn7tLRz2b7jncsYoolhcri7nH49569WHRH+BElDuWERXXTR2il5xejx0yVc+vrS7kw8sGprYa3lu0yhyFMLW+wTdakU7Jnn6qeeEKTQnKRc2FC0VbZ2dOY40gj9QJDTuLIE6Vah3BvFNuDzBxM1K0MqOVVTePU/yGJcjT7i6H5dJsZ5G9eWhHrjMOKHmJfbbtDhemrT71z5RHK4tBjFyI15Ls3mVbkqfrBXE9V+qxLBH4Y3TIgpdzX7HeTawZjj9uWzJdy/gIhKdTHwl2taQjNpkbBV2ryIp5aJiv4Bf+q8Yz1vF2sQuSBx5NwhTyJulvkJfKNtyDrwVkwPJ/dvgaKtk/HwTWJcjsRjIpbBYU3aM7zam7NpskPqc6q+qcdBifmzGqQQuZcKafaggpt0ITZJ1eX90NB3ezkUiobj1sObc+lwq9CJiyM5IsJSd9cs6VGNaCx9j0re6v5KR/rZvf5Z//l+MmCT2vSGaqir/xvv/ifHs+PellpnNTT2pHIRz4fv5h6MUnHL/P15O8z4odTojLPpevnL30eV9dlUnMCM06K+2RVFX6CW0BCxGkTFt8xvD1X7NsN095Ji+Wvub0tqnr71NTAGf2RnB9NB3j9yoUrJsdHSjTGv1ZHx8NAOPxgSpca4FXr4FnrsMvFzr1IVp43Uht18ozriGSIotI3YIkU1lZpClUKh+2byij0snZM0pnl/9j4IlpFpAfKdG7VhhutbEwelTal1srzjttqrLEGhaL5VV7E+1Njog0++omzyoigzpNr0zKSmzNftkripfGN2U+69Ldm6goIC8v8Gb4wjdWxGWbaZWJtf9jINSxA9UlWNQ7GVMfpGOQYjyvKbqHeOA8ye5jPnR6pB/H99dGbujrlUF5EDPdqV+sAnfBytFnSw82wyXnd8cQqExdhyi3KED99FB7ZThiGL2hVaFIDFQr0x+O9e1OmbvhbtDneaqCcmNF4Brn/u/wyKYKnkoqYaobX2Bk/kcY2vIwYRY2IkCpiP12ZkV4o4Lq54gd93JhL7SUZiRdHNa3vhmxtjHtC7S+4xHF5b/YgpQMZrJm4lrq0bGiwMz5Hxk6bOAhX8tvFF0ooZRnJEy+nY9DrFXwH2oYvapdp1z7iuPMwnrg+UZ8wV0aTG1TZcf1qSUdZek8MSk5XKIVVR4U81g3BhKrRZ4qrXKgM9WEWvEqk+vL/XYnT5gM75x6hvKbKS+vNYYlUs39pf/FUBfW/3lXzANG3LHbNY+N0oqalpaFt9xqZz2ZkmXDOO469rc455lRBmSD86aDiLv7Eo4regh0HCbFLSDmieOFiTuQ2F6vNXtsFwR5YkbxcsNpzeKXQu/3oSynjs5/cDuUbNbuEEBUMX1omxmAKE+JQSAu/cAK611t/2zF/YqOn6MyzRhPbYlYEYXyuuCwcjnRusNshkD3mtYjocdVv7XFrdNrJtQfg37sYBRBzbZBC0RHYk06or2QJeXMn59ws24xbZ/u7LUyzzCG7hZLbi3FZMl8Q1MxOOqdyu3Necwkx6JsazjGuc6oSZ8uDeINDuxwpnjtGwm7n9msxuk2iGKYY4lLa7tmKttH+Vf5uWdn2vqkitTQmYvfS0tbEiobTOyuIT053Nr2aCz9+4Yfzq/hTBmETW6NKPhQot1ahR6pK67BWbsSkwNM7l5z1K/zFO/81P4JqI+eXP+QfbbHGrBQkFc2hhesm6rv404rPORqlP9BTj4pirpuP5yFfMkXY+OXsFPxlGqfn5qDT3C35iNwz3ljjoToTYz9RcOFpm5FjvoZWtrIyRuiVjzVi4UsTgnPQc03WuOkm+UCKFpWWaaCcTQwfGS0jkFC3bHrmxL5Qf03Hg9PK4taBidU0C5Nshb5Wgi4lPf6Dobe7jSDePDS42TLXQk+HiTlXxlNVI+Ua27QTDjpTnjuGBnHvS1ba6KAVNpgyKBWXEm2LoVVaJ+CE8sZSgY8++7H1ITtG5Fxxo+axeeLprP1dHSIMTygxPblKfXPkcji7o3sdU9YaX1TSM7x2UmIcPudXCsUu9TWpPaFN1VRgSlCllVIt2DPp7SMPhllI4b7f1qvyYDU/tvn9GRPZ4HwnWZmtm8Kf4UYJ4Zz3BS4/ZXbsgkNhH8SyKhLRQXuLIaVoOMFNX6yKT2EmepmnNmFRgU9x3snnc8gDcI39F6L1DmnHeIeTqt+fOlc4m8/5eYUW7qnpFnFdz+cPVxVdIZygGvQNEB628PTWYpaODTFwdpyaLS1S7Y5CgojGY67FLX3Q6zTo9bTHCS4sJK7Zt1HZ1zkcF0XuNTHIV/mcXOXIo2T7M3spASgRO2G+C7zSRiuDYzf4iQw+xBuWQu8O05AtGFGHfMqlk85dRzs8iNxvZxu+auQ9bZ1v3hEbnp4ougEGeykbI42K5DsDom9gN2KtyNrsqzht+FpDPKLgyEYekipsYXC0OEQaTAtPg66HQ/VyaOzwFgg9hh6jXIG2arLlhc07tMqXJZpJOlM3/TiQi+8qw9lugewandQojnm7DMm8JFpGk8PxtPjRAQqGbPHK84BlNGd2f2fU0rGWFEsH9he1SSdqdxoasCoJ3SSOLNowIAx/N//EzNSAM9+V/L3huN0G/3NGwojFwTdrTyMEt4ZwF0bjBoPgbTJHqiaaaphY7chBmlY6R3az289Fp3fkpx+T7jpCH+wi/fwEnOGvalP2NFw5ZhWAbLs4wCuA5h05B2umnuew7xExzmq0/H0gIWVXKgE7sbxvIK0Hb560Jn72/Rwdl5hKaB853zAzOR6er0D7Grb7F84eYtkhWjFcY8UUbjzm2uz+yWdtsTRjrkFpjqw+giVso/1aruiNx7tn4hHQIcUnmxENN5+tFrx/6RpJgtsbwgqLXcZcOD1r/l4kaXOa3cQbPfwQbYkT2QehHinEzLiNXNGtHJp7hCGqhPTL3l4C55cvEK2xr6OWs1OFVDxn5xc2mvVtxe5DQRWEXcz/eGmk/r3K/jIqJLDEf37p/Blh1ezEkZkksQpxGRXqrL+6ilaiS0gdrfJZMe5ckrEg3aJNa53TNVih91wdIm5JjkkrPod7f7ROP8Bn4Y74I0bO/DLdohPzLSPGCrXGS1ibT4zSs0tuXjyVd6/68k1lCmzbucJY135pA2sw6tgU1zZlwcbFqiFCKGVn/K6H+u6/lZycZ942Gntf9iN9ymphixWnXsSxTtuTTrmSVsLeQ0WtDCsvbp+P4quvYm0KE3NKw7Go+xUxkgu1PNH+8RN9PgGkuXZ4pqeN5sK4Db8v4yLLD9pK98Mp4rtm24vdxTmz53MzfDtQ3U9ineMs6U6lEza8PnujxrvcvJ8vYnhzlT2agdZX1sLpY9woHSH7mVsoHT/evSNwGy12vpJ5IVXopjI9GtiadljH61jFUK5JK2Invpas2YN8lFV1Qh+xmjCrfjo/wtvWW/JS2gLtZO5GDGpsfYdr3fo2wjBuYXXhHQEZ5OOT+Hn3rDjxWKPDbQF2wdiblvA2T3auYgc9vTS7IUkwD3JvmXd3ERRT7/G0i65sG/GGFjbiG6GW9bCbrweyi5ixtiO+69hfq3GV03aYs+o5D8qCRyoz86DwqevEdUsqEqRfOW+KWzLDnTF1+OutxZ/8jMZLccfD8c96TKw33/LFVAUQQrdm+gYvtE24c3vpuJpf2YBrvC0rZcxoJJ4sim+7khEcC8VtEyJKfUZlfr7tFtM6zwO6OsM/1gFbDj/oxhYj/l2AGKdva2cnuwlMt1qMIKp9y4Y7hRvVjeO0FOX+HqneJWxBwuptd+kq/QLaVVTWbUWPfKemn8llwvEuYwiX7vv4JQHsuRHGnFA9NVN5R6W6F9u0qUzAXzGVUZ/uPPexUK8pDVuf3r3ss8/80V+PzH3z2fPD3G4u0T4w9HCQXFaI+DQe7dR6m3LB+0BD5oV+CBqqP5cYtTaveLEAJr3dbusdub3QLtD7bMdmrQj1gd/uwm0nY10QDdH2V1w49DE6p0JO8T2imZoOLaKHEsXBjuJrsXql7NbmSEFwoVVhfVnphFLUdVX4ipl6ohOm1XyUQDnKZ7+UoHw16+Ly++kPbOKdre+iGOGfNUT2p4XiUQSbEIw+evL9mbweISHLhgXpBAac9ZabZvXxZk0tQyk9H3x2uk+UdOAD+dz3ziO++vkJ6xm9WV6+4sEBaaXE3GutXX53+CdPLZ9D50gIvy2e0ntOFpZuFE2mR069SrjjwtuYTT8at8uDGHhJ0H1RsF/ZojrK/fHu4UyPqPiueN8qcUVI2uHDM1a74fmYncR2KiJVuYuYKYizgIl3wMRZd6k+rwU8gw5eOfZ1j32HGEtH3Ul/4L21UjzFKtnHGmHGopHckUYCWhb97cwUq7MeoyRnGldmL/7suY6zcKO0vDOKgKqbUlCKwsQX+S8f1Jq0IxhRpB77z7/aVNYTZLjAJUi9NpPbKp2ftSVZaI+PFPjhegRjA7vW0gPEWUhMl61Ju9fNMFtN1JDXcVwGqiKMkO3JfJIr3M9veExkTkK2XVvhBrVx+vbbtRJUZvVHOZvm6sL0mEWUPvEPYTfTk6IXeBzcxF03O+jedXLVaVtaqIRCUPjalzINGWdRAxumJhxij+O7B9z8PGXf1HyQM7KgPn8mMeP5SEzgP0LxX/7EdKtb7B+TRf1yeyShJgzHMGivYqRnVwaFYBrMSEfH6kKRmBKmbzu/qkKgGOlTCeO80asZBvwqbtVIpcpNsPx/vnD8/3jsKncOwaT+7svn7UEZA9KToymv1Iv/8K4L9VWrmblWWkOa3Wv++pnWqxD9UE5X4RsrZsQPH/6i1RvF+ZNVxf+K49QZXabhH7P733JcwJkkQ7D/Cw==", "base64"));
			log2 = Math.log2 || function(n) {
				return Math.log(n) / Math.LN2
			};
			bits = function(n) {
				return log2(n) + 1 | 0
			};
			CATEGORY_BITS = bits(data.categories.length - 1);
			COMBINING_BITS = bits(data.combiningClasses.length - 1);
			SCRIPT_BITS = bits(data.scripts.length - 1);
			EAW_BITS = bits(data.eaw.length - 1);
			NUMBER_BITS = 10;
			CATEGORY_SHIFT = COMBINING_BITS + SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
			COMBINING_SHIFT = SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
			SCRIPT_SHIFT = EAW_BITS + NUMBER_BITS;
			EAW_SHIFT = NUMBER_BITS;
			CATEGORY_MASK = (1 << CATEGORY_BITS) - 1;
			COMBINING_MASK = (1 << COMBINING_BITS) - 1;
			SCRIPT_MASK = (1 << SCRIPT_BITS) - 1;
			EAW_MASK = (1 << EAW_BITS) - 1;
			NUMBER_MASK = (1 << NUMBER_BITS) - 1;
			exports.getCategory = function(codePoint) {
				var val;
				val = trie.get(codePoint);
				return data.categories[val >> CATEGORY_SHIFT & CATEGORY_MASK]
			};
			exports.getCombiningClass = function(codePoint) {
				var val;
				val = trie.get(codePoint);
				return data.combiningClasses[val >> COMBINING_SHIFT & COMBINING_MASK]
			};
			exports.getScript = function(codePoint) {
				var val;
				val = trie.get(codePoint);
				return data.scripts[val >> SCRIPT_SHIFT & SCRIPT_MASK]
			};
			exports.getEastAsianWidth = function(codePoint) {
				var val;
				val = trie.get(codePoint);
				return data.eaw[val >> EAW_SHIFT & EAW_MASK]
			};
			exports.getNumericValue = function(codePoint) {
				var denominator, exp, num, numerator, val;
				val = trie.get(codePoint);
				num = val & NUMBER_MASK;
				if (num === 0) {
					return null
				} else if (num <= 50) {
					return num - 1
				} else if (num < 480) {
					numerator = (num >> 4) - 12;
					denominator = (num & 15) + 1;
					return numerator / denominator
				} else if (num < 768) {
					val = (num >> 5) - 14;
					exp = (num & 31) + 2;
					while (exp > 0) {
						val *= 10;
						exp--
					}
					return val
				} else {
					val = (num >> 2) - 191;
					exp = (num & 3) + 1;
					while (exp > 0) {
						val *= 60;
						exp--
					}
					return val
				}
			};
			exports.isAlphabetic = function(codePoint) {
				var ref;
				return (ref = exports.getCategory(codePoint)) === "Lu" || ref === "Ll" || ref === "Lt" || ref === "Lm" || ref === "Lo" || ref === "Nl"
			};
			exports.isDigit = function(codePoint) {
				return exports.getCategory(codePoint) === "Nd"
			};
			exports.isPunctuation = function(codePoint) {
				var ref;
				return (ref = exports.getCategory(codePoint)) === "Pc" || ref === "Pd" || ref === "Pe" || ref === "Pf" || ref === "Pi" || ref === "Po" || ref === "Ps"
			};
			exports.isLowerCase = function(codePoint) {
				return exports.getCategory(codePoint) === "Ll"
			};
			exports.isUpperCase = function(codePoint) {
				return exports.getCategory(codePoint) === "Lu"
			};
			exports.isTitleCase = function(codePoint) {
				return exports.getCategory(codePoint) === "Lt"
			};
			exports.isWhiteSpace = function(codePoint) {
				var ref;
				return (ref = exports.getCategory(codePoint)) === "Zs" || ref === "Zl" || ref === "Zp"
			};
			exports.isBaseForm = function(codePoint) {
				var ref;
				return (ref = exports.getCategory(codePoint)) === "Nd" || ref === "No" || ref === "Nl" || ref === "Lu" || ref === "Ll" || ref === "Lt" || ref === "Lm" || ref === "Lo" || ref === "Me" || ref === "Mc"
			};
			exports.isMark = function(codePoint) {
				var ref;
				return (ref = exports.getCategory(codePoint)) === "Mn" || ref === "Me" || ref === "Mc"
			}
		}).call(this, require("buffer").Buffer)
	}, {
		"./data.json": 20,
		buffer: 116,
		"unicode-trie": 22
	}],
	22: [function(require, module, exports) {
		var UnicodeTrie, inflate;
		inflate = require("tiny-inflate");
		UnicodeTrie = function() {
			var DATA_BLOCK_LENGTH, DATA_GRANULARITY, DATA_MASK, INDEX_1_OFFSET, INDEX_2_BLOCK_LENGTH, INDEX_2_BMP_LENGTH, INDEX_2_MASK, INDEX_SHIFT, LSCP_INDEX_2_LENGTH, LSCP_INDEX_2_OFFSET, OMITTED_BMP_INDEX_1_LENGTH, SHIFT_1, SHIFT_1_2, SHIFT_2, UTF8_2B_INDEX_2_LENGTH, UTF8_2B_INDEX_2_OFFSET;
			SHIFT_1 = 6 + 5;
			SHIFT_2 = 5;
			SHIFT_1_2 = SHIFT_1 - SHIFT_2;
			OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
			INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
			INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
			INDEX_SHIFT = 2;
			DATA_BLOCK_LENGTH = 1 << SHIFT_2;
			DATA_MASK = DATA_BLOCK_LENGTH - 1;
			LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
			LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
			INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
			UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
			UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
			INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
			DATA_GRANULARITY = 1 << INDEX_SHIFT;

			function UnicodeTrie(data) {
				var isBuffer, uncompressedLength, view;
				isBuffer = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
				if (isBuffer || data instanceof Uint8Array) {
					if (isBuffer) {
						this.highStart = data.readUInt32BE(0);
						this.errorValue = data.readUInt32BE(4);
						uncompressedLength = data.readUInt32BE(8);
						data = data.slice(12)
					} else {
						view = new DataView(data.buffer);
						this.highStart = view.getUint32(0);
						this.errorValue = view.getUint32(4);
						uncompressedLength = view.getUint32(8);
						data = data.subarray(12)
					}
					data = inflate(data, new Uint8Array(uncompressedLength));
					data = inflate(data, new Uint8Array(uncompressedLength));
					this.data = new Uint32Array(data.buffer)
				} else {
					this.data = data.data, this.highStart = data.highStart, this.errorValue = data.errorValue
				}
			}
			UnicodeTrie.prototype.get = function(codePoint) {
				var index;
				if (codePoint < 0 || codePoint > 1114111) {
					return this.errorValue
				}
				if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
					index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
					return this.data[index]
				}
				if (codePoint <= 65535) {
					index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
					return this.data[index]
				}
				if (codePoint < this.highStart) {
					index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
					index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
					index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
					return this.data[index]
				}
				return this.data[this.data.length - DATA_GRANULARITY]
			};
			return UnicodeTrie
		}();
		module.exports = UnicodeTrie
	}, {
		"tiny-inflate": 23
	}],
	23: [function(require, module, exports) {
		var TINF_OK = 0;
		var TINF_DATA_ERROR = -3;

		function Tree() {
			this.table = new Uint16Array(16);
			this.trans = new Uint16Array(288)
		}

		function Data(source, dest) {
			this.source = source;
			this.sourceIndex = 0;
			this.tag = 0;
			this.bitcount = 0;
			this.dest = dest;
			this.destLen = 0;
			this.ltree = new Tree;
			this.dtree = new Tree
		}
		var sltree = new Tree;
		var sdtree = new Tree;
		var length_bits = new Uint8Array(30);
		var length_base = new Uint16Array(30);
		var dist_bits = new Uint8Array(30);
		var dist_base = new Uint16Array(30);
		var clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
		var code_tree = new Tree;
		var lengths = new Uint8Array(288 + 32);

		function tinf_build_bits_base(bits, base, delta, first) {
			var i, sum;
			for (i = 0; i < delta; ++i) bits[i] = 0;
			for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;
			for (sum = first, i = 0; i < 30; ++i) {
				base[i] = sum;
				sum += 1 << bits[i]
			}
		}

		function tinf_build_fixed_trees(lt, dt) {
			var i;
			for (i = 0; i < 7; ++i) lt.table[i] = 0;
			lt.table[7] = 24;
			lt.table[8] = 152;
			lt.table[9] = 112;
			for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
			for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
			for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
			for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;
			for (i = 0; i < 5; ++i) dt.table[i] = 0;
			dt.table[5] = 32;
			for (i = 0; i < 32; ++i) dt.trans[i] = i
		}
		var offs = new Uint16Array(16);

		function tinf_build_tree(t, lengths, off, num) {
			var i, sum;
			for (i = 0; i < 16; ++i) t.table[i] = 0;
			for (i = 0; i < num; ++i) t.table[lengths[off + i]]++;
			t.table[0] = 0;
			for (sum = 0, i = 0; i < 16; ++i) {
				offs[i] = sum;
				sum += t.table[i]
			}
			for (i = 0; i < num; ++i) {
				if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i
			}
		}

		function tinf_getbit(d) {
			if (!d.bitcount--) {
				d.tag = d.source[d.sourceIndex++];
				d.bitcount = 7
			}
			var bit = d.tag & 1;
			d.tag >>>= 1;
			return bit
		}

		function tinf_read_bits(d, num, base) {
			if (!num) return base;
			while (d.bitcount < 24) {
				d.tag |= d.source[d.sourceIndex++] << d.bitcount;
				d.bitcount += 8
			}
			var val = d.tag & 65535 >>> 16 - num;
			d.tag >>>= num;
			d.bitcount -= num;
			return val + base
		}

		function tinf_decode_symbol(d, t) {
			while (d.bitcount < 24) {
				d.tag |= d.source[d.sourceIndex++] << d.bitcount;
				d.bitcount += 8
			}
			var sum = 0,
				cur = 0,
				len = 0;
			var tag = d.tag;
			do {
				cur = 2 * cur + (tag & 1);
				tag >>>= 1;
				++len;
				sum += t.table[len];
				cur -= t.table[len]
			} while (cur >= 0);
			d.tag = tag;
			d.bitcount -= len;
			return t.trans[sum + cur]
		}

		function tinf_decode_trees(d, lt, dt) {
			var hlit, hdist, hclen;
			var i, num, length;
			hlit = tinf_read_bits(d, 5, 257);
			hdist = tinf_read_bits(d, 5, 1);
			hclen = tinf_read_bits(d, 4, 4);
			for (i = 0; i < 19; ++i) lengths[i] = 0;
			for (i = 0; i < hclen; ++i) {
				var clen = tinf_read_bits(d, 3, 0);
				lengths[clcidx[i]] = clen
			}
			tinf_build_tree(code_tree, lengths, 0, 19);
			for (num = 0; num < hlit + hdist;) {
				var sym = tinf_decode_symbol(d, code_tree);
				switch (sym) {
					case 16:
						var prev = lengths[num - 1];
						for (length = tinf_read_bits(d, 2, 3); length; --length) {
							lengths[num++] = prev
						}
						break;
					case 17:
						for (length = tinf_read_bits(d, 3, 3); length; --length) {
							lengths[num++] = 0
						}
						break;
					case 18:
						for (length = tinf_read_bits(d, 7, 11); length; --length) {
							lengths[num++] = 0
						}
						break;
					default:
						lengths[num++] = sym;
						break
				}
			}
			tinf_build_tree(lt, lengths, 0, hlit);
			tinf_build_tree(dt, lengths, hlit, hdist)
		}

		function tinf_inflate_block_data(d, lt, dt) {
			while (1) {
				var sym = tinf_decode_symbol(d, lt);
				if (sym === 256) {
					return TINF_OK
				}
				if (sym < 256) {
					d.dest[d.destLen++] = sym
				} else {
					var length, dist, offs;
					var i;
					sym -= 257;
					length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
					dist = tinf_decode_symbol(d, dt);
					offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
					for (i = offs; i < offs + length; ++i) {
						d.dest[d.destLen++] = d.dest[i]
					}
				}
			}
		}

		function tinf_inflate_uncompressed_block(d) {
			var length, invlength;
			var i;
			while (d.bitcount > 8) {
				d.sourceIndex--;
				d.bitcount -= 8
			}
			length = d.source[d.sourceIndex + 1];
			length = 256 * length + d.source[d.sourceIndex];
			invlength = d.source[d.sourceIndex + 3];
			invlength = 256 * invlength + d.source[d.sourceIndex + 2];
			if (length !== (~invlength & 65535)) return TINF_DATA_ERROR;
			d.sourceIndex += 4;
			for (i = length; i; --i) d.dest[d.destLen++] = d.source[d.sourceIndex++];
			d.bitcount = 0;
			return TINF_OK
		}

		function tinf_uncompress(source, dest) {
			var d = new Data(source, dest);
			var bfinal, btype, res;
			do {
				bfinal = tinf_getbit(d);
				btype = tinf_read_bits(d, 2, 0);
				switch (btype) {
					case 0:
						res = tinf_inflate_uncompressed_block(d);
						break;
					case 1:
						res = tinf_inflate_block_data(d, sltree, sdtree);
						break;
					case 2:
						tinf_decode_trees(d, d.ltree, d.dtree);
						res = tinf_inflate_block_data(d, d.ltree, d.dtree);
						break;
					default:
						res = TINF_DATA_ERROR
				}
				if (res !== TINF_OK) throw new Error("Data error")
			} while (!bfinal);
			if (d.destLen < d.dest.length) {
				if (typeof d.dest.slice === "function") return d.dest.slice(0, d.destLen);
				else return d.dest.subarray(0, d.destLen)
			}
			return d.dest
		}
		tinf_build_fixed_trees(sltree, sdtree);
		tinf_build_bits_base(length_bits, length_base, 4, 3);
		tinf_build_bits_base(dist_bits, dist_base, 2, 1);
		length_bits[28] = 0;
		length_base[28] = 258;
		module.exports = tinf_uncompress
	}, {}],
	24: [function(require, module, exports) {
		(function() {
			var CFFFont, CFFIndex, CFFPrivateDict, CFFTop, r, standardStrings;
			r = require("restructure");
			CFFIndex = require("./cff/CFFIndex");
			CFFTop = require("./cff/CFFTop");
			CFFPrivateDict = require("./cff/CFFPrivateDict");
			standardStrings = require("./cff/CFFStandardStrings");
			CFFFont = function() {
				var get;
				get = require("./get")(CFFFont);

				function CFFFont(stream1) {
					this.stream = stream1;
					this.decode()
				}
				CFFFont.decode = function(stream) {
					return new CFFFont(stream)
				};
				CFFFont.open = function(filename, name) {
					var contents;
					contents = typeof require === "function" ? require("fs").readFileSync(filename) : void 0;
					return new CFFFont(new r.DecodeStream(contents))
				};
				CFFFont.prototype.decode = function() {
					var key, start, top, val;
					start = this.stream.pos;
					top = CFFTop.decode(this.stream);
					for (key in top) {
						val = top[key];
						this[key] = val
					}
					if (this.topDictIndex.length !== 1) {
						throw new Error("Only a single font is allowed in CFF")
					}
					this.isCIDFont = this.topDict.ROS != null;
					return this
				};
				CFFFont.prototype.string = function(sid) {
					if (sid <= standardStrings.length) {
						return standardStrings[sid]
					}
					return this.stringIndex[sid - standardStrings.length]
				};
				get("topDict", function() {
					return this.topDictIndex[0]
				});
				get("postscriptName", function() {
					return this.nameIndex[0]
				});
				get("fullName", function() {
					return this.string(this.topDict.FullName)
				});
				get("familyName", function() {
					return this.string(this.topDict.FamilyName)
				});
				CFFFont.prototype.getCharString = function(glyph) {
					this.stream.pos = this.topDict.CharStrings[glyph].offset;
					return this.stream.readBuffer(this.topDict.CharStrings[glyph].length)
				};
				CFFFont.prototype.getGlyphName = function(gid) {
					var charset, i, len, range, ref;
					charset = this.topDict.charset;
					if (Array.isArray(charset)) {
						return charset[gid]
					}
					if (gid === 0) {
						return ".notdef"
					}
					gid -= 1;
					switch (charset.version) {
						case 0:
							return this.string(charset.glyphs[gid]);
						case 1:
						case 2:
							ref = charset.ranges;
							for (i = 0, len = ref.length; i < len; i++) {
								range = ref[i];
								if (range.offset <= gid && gid <= range.offset + range.nLeft) {
									return this.string(range.first + (gid - range.offset))
								}
							}
					}
					return null
				};
				CFFFont.prototype.fdForGlyph = function(gid) {
					var high, low, mid, ranges, ref;
					if (!this.topDict.FDSelect) {
						return null
					}
					switch (this.topDict.FDSelect.version) {
						case 0:
							return this.topDict.FDSelect.fds[gid];
						case 3:
							ranges = this.topDict.FDSelect.ranges;
							low = 0;
							high = ranges.length - 1;
							while (low <= high) {
								mid = low + high >> 1;
								if (gid < ranges[mid].first) {
									high = mid - 1
								} else if (gid > ((ref = ranges[mid + 1]) != null ? ref.first : void 0)) {
									low = mid + 1
								} else {
									return ranges[mid].fd
								}
							}
							break;
						default:
							throw new Error("Unknown FDSelect version: " + this.topDict.FDSelect.version)
					}
				};
				CFFFont.prototype.privateDictForGlyph = function(gid) {
					var fd, ref;
					if (this.topDict.FDSelect) {
						fd = this.fdForGlyph(gid);
						if (fd != null) {
							return (ref = this.topDict.FDArray[fd]) != null ? ref.Private : void 0
						} else {
							return null
						}
					}
					return this.topDict.Private
				};
				return CFFFont
			}();
			module.exports = CFFFont
		}).call(this)
	}, {
		"./cff/CFFIndex": 35,
		"./cff/CFFPrivateDict": 38,
		"./cff/CFFStandardStrings": 39,
		"./cff/CFFTop": 40,
		"./get": 41,
		fs: 115,
		restructure: 3
	}],
	25: [function(require, module, exports) {
		(function() {
			var CmapProcessor;
			CmapProcessor = function() {
				function CmapProcessor(cmapTable) {
					var cmap, j, k, len, len1, ref, ref1, ref2;
					this._characterSet = null;
					ref = cmapTable.tables;
					for (j = 0, len = ref.length; j < len; j++) {
						cmap = ref[j];
						if (cmap.platformID === 0 && ((ref1 = cmap.encodingID) === 4 || ref1 === 6) || cmap.platformID === 3 && cmap.encodingID === 10) {
							this.cmap = cmap.table;
							return
						}
					}
					ref2 = cmapTable.tables;
					for (k = 0, len1 = ref2.length; k < len1; k++) {
						cmap = ref2[k];
						if (cmap.platformID === 0 || cmap.platformID === 3 && cmap.encodingID === 1) {
							this.cmap = cmap.table;
							return
						}
					}
					throw new Error("Could not find a unicode cmap")
				}
				CmapProcessor.prototype.lookup = function(codepoint) {
					var cmap, gid, group, index, max, mid, min, rangeOffset;
					cmap = this.cmap;
					switch (cmap.version) {
						case 0:
							return cmap.codeMap.get(codepoint) || 0;
						case 4:
							min = 0;
							max = cmap.segCount - 1;
							while (min <= max) {
								mid = min + max >> 1;
								if (codepoint < cmap.startCode.get(mid)) {
									max = mid - 1
								} else if (codepoint > cmap.endCode.get(mid)) {
									min = mid + 1
								} else {
									rangeOffset = cmap.idRangeOffset.get(mid);
									if (rangeOffset === 0) {
										gid = codepoint + cmap.idDelta.get(mid)
									} else {
										index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
										gid = cmap.glyphIndexArray.get(index) || 0;
										if (gid !== 0) {
											gid += cmap.idDelta.get(mid)
										}
									}
									return gid & 65535
								}
							}
							return 0;
						case 8:
							throw new Error("TODO: cmap format 8");
							break;
						case 6:
						case 10:
							return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
						case 12:
						case 13:
							min = 0;
							max = cmap.nGroups - 1;
							while (min <= max) {
								mid = min + max >> 1;
								group = cmap.groups.get(mid);
								if (codepoint < group.startCharCode) {
									max = mid - 1
								} else if (codepoint > group.endCharCode) {
									min = mid + 1
								} else {
									if (cmap.version === 12) {
										return group.glyphID + (codepoint - group.startCharCode)
									} else {
										return group.glyphID
									}
								}
							}
							return 0;
						case 14:
							throw new Error("TODO: cmap format 14");
							break;
						default:
							throw new Error("Unknown cmap format " + cmap.version)
					}
				};
				CmapProcessor.prototype.getCharacterSet = function() {
					var cmap, group, i, j, k, l, len, len1, m, n, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, res, results, results1, results2, results3, start, tail;
					if (this._characterSet) {
						return this._characterSet
					}
					cmap = this.cmap;
					switch (cmap.version) {
						case 0:
							this._characterSet = function() {
								results = [];
								for (var j = 0, ref = cmap.codeMap.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
									results.push(j)
								}
								return results
							}.apply(this);
							break;
						case 4:
							res = [];
							ref1 = cmap.endCode.toArray();
							for (i = k = 0, len = ref1.length; k < len; i = ++k) {
								tail = ref1[i];
								start = cmap.startCode.get(i);
								res.push.apply(res, function() {
									results1 = [];
									for (var l = start; start <= tail ? l <= tail : l >= tail; start <= tail ? l++ : l--) {
										results1.push(l)
									}
									return results1
								}.apply(this))
							}
							this._characterSet = res;
							break;
						case 8:
							throw new Error("TODO: cmap format 8");
							break;
						case 6:
						case 10:
							this._characterSet = function() {
								results2 = [];
								for (var m = ref2 = cmap.firstCode, ref3 = cmap.firstCode + cmap.glyphIndices.length; ref2 <= ref3 ? m < ref3 : m > ref3; ref2 <= ref3 ? m++ : m--) {
									results2.push(m)
								}
								return results2
							}.apply(this);
							break;
						case 12:
						case 13:
							res = [];
							ref4 = cmap.groups.toArray();
							for (n = 0, len1 = ref4.length; n < len1; n++) {
								group = ref4[n];
								res.push.apply(res, function() {
									results3 = [];
									for (var o = ref5 = group.startCharCode, ref6 = group.endCharCode; ref5 <= ref6 ? o <= ref6 : o >= ref6; ref5 <= ref6 ? o++ : o--) {
										results3.push(o)
									}
									return results3
								}.apply(this))
							}
							this._characterSet = res;
							break;
						case 14:
							throw new Error("TODO: cmap format 14");
							break;
						default:
							throw new Error("Unknown cmap format " + cmap.version)
					}
					return this._characterSet
				};
				return CmapProcessor
			}();
			module.exports = CmapProcessor
		}).call(this)
	}, {}],
	26: [function(require, module, exports) {
		(function() {
			var BBox, CFFGlyph, CFFSubset, COLRGlyph, CmapProcessor, Directory, GlyphVariationProcessor, LayoutEngine, SBIXGlyph, TTFFont, TTFGlyph, TTFSubset, fontkit, r, tables;
			r = require("restructure");
			fontkit = require("../base");
			Directory = require("./tables/directory");
			tables = require("./tables");
			CmapProcessor = require("./CmapProcessor");
			LayoutEngine = require("./layout/LayoutEngine");
			TTFGlyph = require("./glyph/TTFGlyph");
			CFFGlyph = require("./glyph/CFFGlyph");
			SBIXGlyph = require("./glyph/SBIXGlyph");
			COLRGlyph = require("./glyph/COLRGlyph");
			GlyphVariationProcessor = require("./glyph/GlyphVariationProcessor");
			TTFSubset = require("./subset/TTFSubset");
			CFFSubset = require("./subset/CFFSubset");
			BBox = require("./glyph/BBox");
			TTFFont = function() {
				var get, getTable;
				get = require("./get")(TTFFont);
				TTFFont.probe = function(buffer) {
					var ref;
					return (ref = buffer.toString("ascii", 0, 4)) === "true" || ref === "OTTO" || ref === String.fromCharCode(0, 1, 0, 0)
				};

				function TTFFont(stream1, variationCoords) {
					var ref, table, tag;
					this.stream = stream1;
					if (variationCoords == null) {
						variationCoords = null
					}
					this._tables = {};
					this._glyphs = {};
					this._decodeDirectory();
					ref = this.directory.tables;
					for (tag in ref) {
						table = ref[tag];
						if (tables[tag] && table.length > 0) {
							Object.defineProperty(this, tag, {
								get: getTable.bind(this, table)
							})
						}
					}
					if (variationCoords) {
						this._variationProcessor = new GlyphVariationProcessor(this, variationCoords)
					}
				}
				getTable = function(table) {
					var e, error, pos;
					if (!(table.tag in this._tables)) {
						pos = this.stream.pos;
						this.stream.pos = table.offset;
						try {
							this._tables[table.tag] = this._decodeTable(table)
						} catch (error) {
							e = error;
							if (fontkit.logErrors) {
								console.error("Error decoding table " + table.tag);
								console.error(e.stack)
							}
						}
						this.stream.pos = pos
					}
					return this._tables[table.tag]
				};
				TTFFont.prototype._getTableStream = function(tag) {
					var table;
					table = this.directory.tables[tag];
					if (table) {
						this.stream.pos = table.offset;
						return this.stream
					}
					return null
				};
				TTFFont.prototype._decodeDirectory = function() {
					this._directoryPos = this.stream.pos;
					return this.directory = Directory.decode(this.stream, {
						_startOffset: 0
					})
				};
				TTFFont.prototype._decodeTable = function(table) {
					return tables[table.tag].decode(this.stream, this, table.length)
				};
				get("postscriptName", function() {
					var lang, name;
					name = this.name.records.postscriptName;
					lang = Object.keys(name)[0];
					return name[lang]
				});
				get("fullName", function() {
					var ref;
					return (ref = this.name.records.fullName) != null ? ref.English : void 0
				});
				get("familyName", function() {
					var ref;
					return (ref = this.name.records.fontFamily) != null ? ref.English : void 0
				});
				get("subfamilyName", function() {
					var ref;
					return (ref = this.name.records.fontSubfamily) != null ? ref.English : void 0
				});
				get("copyright", function() {
					var ref;
					return (ref = this.name.records.copyright) != null ? ref.English : void 0
				});
				get("version", function() {
					var ref;
					return (ref = this.name.records.version) != null ? ref.English : void 0
				});
				get("ascent", function() {
					return this.hhea.ascent
				});
				get("descent", function() {
					return this.hhea.descent
				});
				get("lineGap", function() {
					return this.hhea.lineGap
				});
				get("underlinePosition", function() {
					return this.post.underlinePosition
				});
				get("underlineThickness", function() {
					return this.post.underlineThickness
				});
				get("italicAngle", function() {
					return this.post.italicAngle
				});
				get("capHeight", function() {
					var ref;
					return ((ref = this["OS/2"]) != null ? ref.capHeight : void 0) || this.ascent
				});
				get("xHeight", function() {
					var ref;
					return ((ref = this["OS/2"]) != null ? ref.xHeight : void 0) || 0
				});
				get("numGlyphs", function() {
					return this.maxp.numGlyphs
				});
				get("unitsPerEm", function() {
					return this.head.unitsPerEm
				});
				get("bbox", function() {
					return this._bbox != null ? this._bbox : this._bbox = Object.freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax))
				});
				get("characterSet", function() {
					if (this._cmapProcessor == null) {
						this._cmapProcessor = new CmapProcessor(this.cmap)
					}
					return this._cmapProcessor.getCharacterSet()
				});
				TTFFont.prototype.hasGlyphForCodePoint = function(codePoint) {
					if (this._cmapProcessor == null) {
						this._cmapProcessor = new CmapProcessor(this.cmap)
					}
					return !!this._cmapProcessor.lookup(codePoint)
				};
				TTFFont.prototype.glyphForCodePoint = function(codePoint) {
					if (this._cmapProcessor == null) {
						this._cmapProcessor = new CmapProcessor(this.cmap)
					}
					return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint])
				};
				TTFFont.prototype.glyphsForString = function(string) {
					var code, glyphs, idx, len, next;
					glyphs = [];
					len = string.length;
					idx = 0;
					while (idx < len) {
						code = string.charCodeAt(idx++);
						if (55296 <= code && code <= 56319 && idx < len) {
							next = string.charCodeAt(idx);
							if (56320 <= next && next <= 57343) {
								idx++;
								code = ((code & 1023) << 10) + (next & 1023) + 65536
							}
						}
						glyphs.push(this.glyphForCodePoint(code))
					}
					return glyphs
				};
				TTFFont.prototype.layout = function(string, userFeatures, script, language) {
					if (this._layoutEngine == null) {
						this._layoutEngine = new LayoutEngine(this)
					}
					return this._layoutEngine.layout(string, userFeatures, script, language)
				};
				get("availableFeatures", function() {
					if (this._layoutEngine == null) {
						this._layoutEngine = new LayoutEngine(this)
					}
					return this._layoutEngine.getAvailableFeatures()
				});
				TTFFont.prototype.widthOfString = function(string, features, script, language) {
					if (this._layoutEngine == null) {
						this._layoutEngine = new LayoutEngine(this)
					}
					return this._layoutEngine.layout(string, features, script, language).advanceWidth
				};
				TTFFont.prototype._getBaseGlyph = function(glyph, characters) {
					if (characters == null) {
						characters = []
					}
					if (!this._glyphs[glyph]) {
						if (this.directory.tables.glyf != null) {
							this._glyphs[glyph] = new TTFGlyph(glyph, characters, this)
						} else if (this.directory.tables["CFF "] != null) {
							this._glyphs[glyph] = new CFFGlyph(glyph, characters, this)
						}
					}
					return this._glyphs[glyph] || null
				};
				TTFFont.prototype.getGlyph = function(glyph, characters) {
					if (characters == null) {
						characters = []
					}
					if (!this._glyphs[glyph]) {
						if (this.directory.tables.sbix != null) {
							this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this)
						} else if (this.directory.tables.COLR != null && this.directory.tables.CPAL != null) {
							this._glyphs[glyph] = new COLRGlyph(glyph, characters, this)
						} else {
							this._getBaseGlyph(glyph, characters)
						}
					}
					return this._glyphs[glyph] || null
				};
				TTFFont.prototype.createSubset = function() {
					if (this.directory.tables["CFF "] != null) {
						return new CFFSubset(this)
					}
					return new TTFSubset(this)
				};
				get("variationAxes", function() {
					var axis, j, len1, ref, res;
					res = {};
					if (!this.fvar) {
						return res
					}
					ref = this.fvar.axis;
					for (j = 0, len1 = ref.length; j < len1; j++) {
						axis = ref[j];
						res[axis.axisTag] = {
							name: axis.name,
							min: axis.minValue,
							default: axis.defaultValue,
							max: axis.maxValue
						}
					}
					return res
				});
				get("namedVariations", function() {
					var axis, i, instance, j, k, len1, len2, ref, ref1, res, settings;
					res = {};
					if (!this.fvar) {
						return res
					}
					ref = this.fvar.instance;
					for (j = 0, len1 = ref.length; j < len1; j++) {
						instance = ref[j];
						settings = {};
						ref1 = this.fvar.axis;
						for (i = k = 0, len2 = ref1.length; k < len2; i = ++k) {
							axis = ref1[i];
							settings[axis.axisTag] = instance.coord[i]
						}
						res[instance.name] = settings
					}
					return res
				});
				TTFFont.prototype.getVariation = function(settings) {
					var axis, coords, font, i, stream;
					if (!(this.directory.tables.fvar && this.directory.tables.gvar && this.directory.tables.glyf)) {
						throw new Error("Variations require a font with the fvar, gvar, and glyf tables.")
					}
					if (typeof settings === "string") {
						settings = this.namedVariations[settings]
					}
					if (typeof settings !== "object") {
						throw new Error("Variation settings must be either a variation name or settings object.")
					}
					coords = function() {
						var j, len1, ref, results;
						ref = this.fvar.axis;
						results = [];
						for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
							axis = ref[i];
							if (axis.axisTag in settings) {
								results.push(Math.max(axis.minValue, Math.min(axis.maxValue, settings[axis.axisTag])))
							} else {
								results.push(axis.defaultValue)
							}
						}
						return results
					}.call(this);
					stream = new r.DecodeStream(this.stream.buffer);
					stream.pos = this._directoryPos;
					font = new TTFFont(stream, coords);
					font._tables = this._tables;
					return font
				};
				TTFFont.prototype.getFont = function(name) {
					return this.getVariation(name)
				};
				return TTFFont
			}();
			module.exports = TTFFont
		}).call(this)
	}, {
		"../base": 2,
		"./CmapProcessor": 25,
		"./get": 41,
		"./glyph/BBox": 42,
		"./glyph/CFFGlyph": 43,
		"./glyph/COLRGlyph": 44,
		"./glyph/GlyphVariationProcessor": 46,
		"./glyph/SBIXGlyph": 48,
		"./glyph/TTFGlyph": 50,
		"./layout/LayoutEngine": 53,
		"./subset/CFFSubset": 67,
		"./subset/TTFSubset": 69,
		"./tables": 101,
		"./tables/directory": 90,
		restructure: 3
	}],
	27: [function(require, module, exports) {
		(function() {
			var AATFeatureMap;
			AATFeatureMap = function() {
				var AATMapping, OTMapping, aat, feature, features, i, j, mapFeatureStrings, name1, ot;

				function AATFeatureMap() {}
				features = {
					allTypographicFeatures: {
						code: 0,
						exclusive: false,
						allTypeFeatures: 0
					},
					ligatures: {
						code: 1,
						exclusive: false,
						requiredLigatures: 0,
						commonLigatures: 2,
						rareLigatures: 4,
						rebusPictures: 8,
						diphthongLigatures: 10,
						squaredLigatures: 12,
						abbrevSquaredLigatures: 14,
						symbolLigatures: 16,
						contextualLigatures: 18,
						historicalLigatures: 20
					},
					cursiveConnection: {
						code: 2,
						exclusive: true,
						unconnected: 0,
						partiallyConnected: 1,
						cursive: 2
					},
					letterCase: {
						code: 3,
						exclusive: true
					},
					verticalSubstitution: {
						code: 4,
						exclusive: false,
						substituteVerticalForms: 0
					},
					linguisticRearrangement: {
						code: 5,
						exclusive: false,
						linguisticRearrangement: 0
					},
					numberSpacing: {
						code: 6,
						exclusive: true,
						monospacedNumbers: 0,
						proportionalNumbers: 1,
						thirdWidthNumbers: 2,
						quarterWidthNumbers: 3
					},
					smartSwash: {
						code: 8,
						exclusive: false,
						wordInitialSwashes: 0,
						wordFinalSwashes: 2,
						nonFinalSwashes: 8
					},
					diacritics: {
						code: 9,
						exclusive: true,
						showDiacritics: 0,
						hideDiacritics: 1,
						decomposeDiacritics: 2
					},
					verticalPosition: {
						code: 10,
						exclusive: true,
						normalPosition: 0,
						superiors: 1,
						inferiors: 2,
						ordinals: 3,
						scientificInferiors: 4
					},
					fractions: {
						code: 11,
						exclusive: true,
						noFractions: 0,
						verticalFractions: 1,
						diagonalFractions: 2
					},
					overlappingCharacters: {
						code: 13,
						exclusive: false,
						preventOverlap: 0
					},
					typographicExtras: {
						code: 14,
						exclusive: false,
						slashedZero: 4
					},
					mathematicalExtras: {
						code: 15,
						exclusive: false,
						mathematicalGreek: 10
					},
					ornamentSets: {
						code: 16,
						exclusive: true,
						noOrnaments: 0,
						dingbats: 1,
						piCharacters: 2,
						fleurons: 3,
						decorativeBorders: 4,
						internationalSymbols: 5,
						mathSymbols: 6
					},
					characterAlternatives: {
						code: 17,
						exclusive: true,
						noAlternates: 0
					},
					designComplexity: {
						code: 18,
						exclusive: true,
						designLevel1: 0,
						designLevel2: 1,
						designLevel3: 2,
						designLevel4: 3,
						designLevel5: 4
					},
					styleOptions: {
						code: 19,
						exclusive: true,
						noStyleOptions: 0,
						displayText: 1,
						engravedText: 2,
						illuminatedCaps: 3,
						titlingCaps: 4,
						tallCaps: 5
					},
					characterShape: {
						code: 20,
						exclusive: true,
						traditionalCharacters: 0,
						simplifiedCharacters: 1,
						JIS1978Characters: 2,
						JIS1983Characters: 3,
						JIS1990Characters: 4,
						traditionalAltOne: 5,
						traditionalAltTwo: 6,
						traditionalAltThree: 7,
						traditionalAltFour: 8,
						traditionalAltFive: 9,
						expertCharacters: 10,
						JIS2004Characters: 11,
						hojoCharacters: 12,
						NLCCharacters: 13,
						traditionalNamesCharacters: 14
					},
					numberCase: {
						code: 21,
						exclusive: true,
						lowerCaseNumbers: 0,
						upperCaseNumbers: 1
					},
					textSpacing: {
						code: 22,
						exclusive: true,
						proportionalText: 0,
						monospacedText: 1,
						halfWidthText: 2,
						thirdWidthText: 3,
						quarterWidthText: 4,
						altProportionalText: 5,
						altHalfWidthText: 6
					},
					transliteration: {
						code: 23,
						exclusive: true,
						noTransliteration: 0
					},
					annotation: {
						code: 24,
						exclusive: true,
						noAnnotation: 0,
						boxAnnotation: 1,
						roundedBoxAnnotation: 2,
						circleAnnotation: 3,
						invertedCircleAnnotation: 4,
						parenthesisAnnotation: 5,
						periodAnnotation: 6,
						romanNumeralAnnotation: 7,
						diamondAnnotation: 8,
						invertedBoxAnnotation: 9,
						invertedRoundedBoxAnnotation: 10
					},
					kanaSpacing: {
						code: 25,
						exclusive: true,
						fullWidthKana: 0,
						proportionalKana: 1
					},
					ideographicSpacing: {
						code: 26,
						exclusive: true,
						fullWidthIdeographs: 0,
						proportionalIdeographs: 1,
						halfWidthIdeographs: 2
					},
					unicodeDecomposition: {
						code: 27,
						exclusive: false,
						canonicalComposition: 0,
						compatibilityComposition: 2,
						transcodingComposition: 4
					},
					rubyKana: {
						code: 28,
						exclusive: false,
						rubyKana: 2
					},
					CJKSymbolAlternatives: {
						code: 29,
						exclusive: true,
						noCJKSymbolAlternatives: 0,
						CJKSymbolAltOne: 1,
						CJKSymbolAltTwo: 2,
						CJKSymbolAltThree: 3,
						CJKSymbolAltFour: 4,
						CJKSymbolAltFive: 5
					},
					ideographicAlternatives: {
						code: 30,
						exclusive: true,
						noIdeographicAlternatives: 0,
						ideographicAltOne: 1,
						ideographicAltTwo: 2,
						ideographicAltThree: 3,
						ideographicAltFour: 4,
						ideographicAltFive: 5
					},
					CJKVerticalRomanPlacement: {
						code: 31,
						exclusive: true,
						CJKVerticalRomanCentered: 0,
						CJKVerticalRomanHBaseline: 1
					},
					italicCJKRoman: {
						code: 32,
						exclusive: false,
						CJKItalicRoman: 2
					},
					caseSensitiveLayout: {
						code: 33,
						exclusive: false,
						caseSensitiveLayout: 0,
						caseSensitiveSpacing: 2
					},
					alternateKana: {
						code: 34,
						exclusive: false,
						alternateHorizKana: 0,
						alternateVertKana: 2
					},
					stylisticAlternatives: {
						code: 35,
						exclusive: false,
						noStylisticAlternates: 0,
						stylisticAltOne: 2,
						stylisticAltTwo: 4,
						stylisticAltThree: 6,
						stylisticAltFour: 8,
						stylisticAltFive: 10,
						stylisticAltSix: 12,
						stylisticAltSeven: 14,
						stylisticAltEight: 16,
						stylisticAltNine: 18,
						stylisticAltTen: 20,
						stylisticAltEleven: 22,
						stylisticAltTwelve: 24,
						stylisticAltThirteen: 26,
						stylisticAltFourteen: 28,
						stylisticAltFifteen: 30,
						stylisticAltSixteen: 32,
						stylisticAltSeventeen: 34,
						stylisticAltEighteen: 36,
						stylisticAltNineteen: 38,
						stylisticAltTwenty: 40
					},
					contextualAlternates: {
						code: 36,
						exclusive: false,
						contextualAlternates: 0,
						swashAlternates: 2,
						contextualSwashAlternates: 4
					},
					lowerCase: {
						code: 37,
						exclusive: true,
						defaultLowerCase: 0,
						lowerCaseSmallCaps: 1,
						lowerCasePetiteCaps: 2
					},
					upperCase: {
						code: 38,
						exclusive: true,
						defaultUpperCase: 0,
						upperCaseSmallCaps: 1,
						upperCasePetiteCaps: 2
					},
					languageTag: {
						code: 39,
						exclusive: true
					},
					CJKRomanSpacing: {
						code: 103,
						exclusive: true,
						halfWidthCJKRoman: 0,
						proportionalCJKRoman: 1,
						defaultCJKRoman: 2,
						fullWidthCJKRoman: 3
					}
				};
				feature = function(name, selector) {
					return [features[name].code, features[name][selector]]
				};
				OTMapping = {
					rlig: feature("ligatures", "requiredLigatures"),
					clig: feature("ligatures", "contextualLigatures"),
					dlig: feature("ligatures", "rareLigatures"),
					hlig: feature("ligatures", "historicalLigatures"),
					liga: feature("ligatures", "commonLigatures"),
					hist: feature("ligatures", "historicalLigatures"),
					smcp: feature("lowerCase", "lowerCaseSmallCaps"),
					pcap: feature("lowerCase", "lowerCasePetiteCaps"),
					frac: feature("fractions", "diagonalFractions"),
					dnom: feature("fractions", "diagonalFractions"),
					numr: feature("fractions", "diagonalFractions"),
					afrc: feature("fractions", "verticalFractions"),
					case: feature("caseSensitiveLayout", "caseSensitiveLayout"),
					ccmp: feature("unicodeDecomposition", "canonicalComposition"),
					cpct: feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
					valt: feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
					swsh: feature("contextualAlternates", "swashAlternates"),
					cswh: feature("contextualAlternates", "contextualSwashAlternates"),
					curs: feature("cursiveConnection", "cursive"),
					c2pc: feature("upperCase", "upperCasePetiteCaps"),
					c2sc: feature("upperCase", "upperCaseSmallCaps"),
					init: feature("smartSwash", "wordInitialSwashes"),
					fin2: feature("smartSwash", "wordFinalSwashes"),
					medi: feature("smartSwash", "nonFinalSwashes"),
					med2: feature("smartSwash", "nonFinalSwashes"),
					fin3: feature("smartSwash", "wordFinalSwashes"),
					fina: feature("smartSwash", "wordFinalSwashes"),
					fwid: feature("kanaSpacing", "fullWidthKana"),
					pkna: feature("kanaSpacing", "proportionalKana"),
					half: feature("textSpacing", "halfWidthText"),
					halt: feature("textSpacing", "altHalfWidthText"),
					hwid: feature("textSpacing", "halfWidthText"),
					hkna: feature("alternateKana", "alternateHorizKana"),
					vkna: feature("alternateKana", "alternateVertKana"),
					ital: feature("italicCJKRoman", "CJKItalicRoman"),
					lnum: feature("numberCase", "upperCaseNumbers"),
					onum: feature("numberCase", "lowerCaseNumbers"),
					mgrk: feature("mathematicalExtras", "mathematicalGreek"),
					calt: feature("contextualAlternates", "contextualAlternates"),
					vrt2: feature("verticalSubstitution", "substituteVerticalForms"),
					vert: feature("verticalSubstitution", "substituteVerticalForms"),
					tnum: feature("numberSpacing", "monospacedNumbers"),
					pnum: feature("numberSpacing", "proportionalNumbers"),
					sups: feature("verticalPosition", "superiors"),
					subs: feature("verticalPosition", "inferiors"),
					ordn: feature("verticalPosition", "ordinals"),
					pwid: feature("textSpacing", "proportionalText"),
					hwid: feature("textSpacing", "halfWidthText"),
					qwid: feature("textSpacing", "quarterWidthText"),
					twid: feature("textSpacing", "thirdWidthText"),
					fwid: feature("textSpacing", "proportionalText"),
					palt: feature("textSpacing", "altProportionalText"),
					trad: feature("characterShape", "traditionalCharacters"),
					smpl: feature("characterShape", "simplifiedCharacters"),
					jp78: feature("characterShape", "JIS1978Characters"),
					jp83: feature("characterShape", "JIS1983Characters"),
					jp90: feature("characterShape", "JIS1990Characters"),
					jp04: feature("characterShape", "JIS2004Characters"),
					expt: feature("characterShape", "expertCharacters"),
					hojo: feature("characterShape", "hojoCharacters"),
					nlck: feature("characterShape", "NLCCharacters"),
					tnam: feature("characterShape", "traditionalNamesCharacters"),
					ruby: feature("rubyKana", "rubyKana"),
					titl: feature("styleOptions", "titlingCaps"),
					zero: feature("typographicExtras", "slashedZero"),
					ss01: feature("stylisticAlternatives", "stylisticAltOne"),
					ss02: feature("stylisticAlternatives", "stylisticAltTwo"),
					ss03: feature("stylisticAlternatives", "stylisticAltThree"),
					ss04: feature("stylisticAlternatives", "stylisticAltFour"),
					ss05: feature("stylisticAlternatives", "stylisticAltFive"),
					ss06: feature("stylisticAlternatives", "stylisticAltSix"),
					ss07: feature("stylisticAlternatives", "stylisticAltSeven"),
					ss08: feature("stylisticAlternatives", "stylisticAltEight"),
					ss09: feature("stylisticAlternatives", "stylisticAltNine"),
					ss10: feature("stylisticAlternatives", "stylisticAltTen"),
					ss11: feature("stylisticAlternatives", "stylisticAltEleven"),
					ss12: feature("stylisticAlternatives", "stylisticAltTwelve"),
					ss13: feature("stylisticAlternatives", "stylisticAltThirteen"),
					ss14: feature("stylisticAlternatives", "stylisticAltFourteen"),
					ss15: feature("stylisticAlternatives", "stylisticAltFifteen"),
					ss16: feature("stylisticAlternatives", "stylisticAltSixteen"),
					ss17: feature("stylisticAlternatives", "stylisticAltSeventeen"),
					ss18: feature("stylisticAlternatives", "stylisticAltEighteen"),
					ss19: feature("stylisticAlternatives", "stylisticAltNineteen"),
					ss20: feature("stylisticAlternatives", "stylisticAltTwenty")
				};
				for (i = j = 1; j <= 99; i = ++j) {
					OTMapping["cv" + ("00" + i).slice(-2)] = [features.characterAlternatives.code, i]
				}
				AATMapping = {};
				for (ot in OTMapping) {
					aat = OTMapping[ot];
					if (AATMapping[name1 = aat[0]] == null) {
						AATMapping[name1] = {}
					}
					AATMapping[aat[0]][aat[1]] = ot
				}
				AATFeatureMap.mapOTToAAT = function(features) {
					var k, len, name2, r, res;
					res = {};
					for (k = 0, len = features.length; k < len; k++) {
						feature = features[k];
						if (r = OTMapping[feature]) {
							if (res[name2 = r[0]] == null) {
								res[name2] = {}
							}
							res[r[0]][r[1]] = true
						}
					}
					return res
				};
				mapFeatureStrings = function(f) {
					var ref, ref1, setting, settingCode, type, typeCode;
					type = f[0], setting = f[1];
					if (isNaN(type)) {
						typeCode = (ref = features[type]) != null ? ref.code : void 0
					} else {
						typeCode = type
					}
					if (isNaN(setting)) {
						settingCode = (ref1 = features[type]) != null ? ref1[setting] : void 0
					} else {
						settingCode = setting
					}
					return [typeCode, settingCode]
				};
				AATFeatureMap.mapAATToOT = function(features) {
					var f, k, len, r, ref, ref1, res, setting, type, v;
					res = {};
					if (Array.isArray(features)) {
						for (k = 0, len = features.length; k < len; k++) {
							feature = features[k];
							f = mapFeatureStrings(feature);
							if (r = (ref = AATMapping[f[0]]) != null ? ref[f[1]] : void 0) {
								res[r] = true
							}
						}
					} else if (typeof features === "object") {
						for (type in features) {
							feature = features[type];
							for (setting in feature) {
								v = feature[setting];
								f = mapFeatureStrings([type, setting]);
								if (v && (r = (ref1 = AATMapping[f[0]]) != null ? ref1[f[1]] : void 0)) {
									res[r] = true
								}
							}
						}
					}
					return Object.keys(res)
				};
				return AATFeatureMap
			}();
			module.exports = AATFeatureMap
		}).call(this)
	}, {}],
	28: [function(require, module, exports) {
		(function() {
			var AATFeatureMap, AATLayoutEngine, AATMorxProcessor, Script;
			AATFeatureMap = require("./AATFeatureMap");
			AATMorxProcessor = require("./AATMorxProcessor");
			Script = require("../layout/Script");
			AATLayoutEngine = function() {
				function AATLayoutEngine(font) {
					this.font = font;
					this.morxProcessor = new AATMorxProcessor(this.font)
				}
				AATLayoutEngine.prototype.substitute = function(glyphs, features, script, language) {
					var isRTL;
					isRTL = Script.direction(script) === "rtl";
					if (isRTL) {
						glyphs.reverse()
					}
					this.morxProcessor.process(glyphs, AATFeatureMap.mapOTToAAT(features));
					return glyphs
				};
				AATLayoutEngine.prototype.getAvailableFeatures = function(script, language) {
					return AATFeatureMap.mapAATToOT(this.morxProcessor.getSupportedFeatures())
				};
				return AATLayoutEngine
			}();
			module.exports = AATLayoutEngine
		}).call(this)
	}, {
		"../layout/Script": 54,
		"./AATFeatureMap": 27,
		"./AATMorxProcessor": 30
	}],
	29: [function(require, module, exports) {
		(function() {
			var AATLookupTable;
			AATLookupTable = function() {
				function AATLookupTable(table) {
					this.table = table
				}
				AATLookupTable.prototype.lookup = function(glyph) {
					var max, mid, min, seg;
					switch (this.table.version) {
						case 0:
							return this.table.values.getItem(glyph);
						case 2:
						case 4:
							min = 0;
							max = this.table.binarySearchHeader.nUnits - 1;
							while (min <= max) {
								mid = min + max >> 1;
								seg = this.table.segments[mid];
								if (seg.firstGlyph === 65535) {
									return null
								}
								if (glyph < seg.firstGlyph) {
									max = mid - 1
								} else if (glyph > seg.lastGlyph) {
									min = mid + 1
								} else {
									if (this.table.version === 2) {
										return seg.value
									} else {
										return seg.values[glyph - seg.firstGlyph]
									}
								}
							}
							break;
						case 6:
							min = 0;
							max = this.table.binarySearchHeader.nUnits - 1;
							while (min <= max) {
								mid = min + max >> 1;
								seg = this.table.segments[mid];
								if (seg.glyph === 65535) {
									return null
								}
								if (glyph < seg.glyph) {
									max = mid - 1
								} else if (glyph > seg.glyph) {
									min = mid + 1
								} else {
									return seg.value
								}
							}
							break;
						case 8:
							return this.table.values[glyph - this.table.firstGlyph];
						default:
							throw new Error("Unknown lookup table format: " + this.table.version)
					}
					return null
				};
				return AATLookupTable
			}();
			module.exports = AATLookupTable
		}).call(this)
	}, {}],
	30: [function(require, module, exports) {
		(function() {
			var AATLookupTable, AATMorxProcessor, AATStateMachine, bind = function(fn, me) {
					return function() {
						return fn.apply(me, arguments)
					}
				},
				slice = [].slice;
			AATStateMachine = require("./AATStateMachine");
			AATLookupTable = require("./AATLookupTable");
			AATMorxProcessor = function() {
				var CURRENT_INSERT_BEFORE, CURRENT_INSERT_COUNT, CURRENT_IS_KASHIDA_LIKE, HORIZONTAL_AND_VERTICAL, LAST_MASK, MARKED_INSERT_BEFORE, MARKED_INSERT_COUNT, MARKED_IS_KASHIDA_LIKE, MARK_FIRST, MARK_LAST, OFFSET_MASK, PERFORM_ACTION, REVERSE_DIRECTION, SET_COMPONENT, SET_MARK, STORE_MASK, VERB, VERTICAL_ONLY, reorderGlyphs, swap;
				MARK_FIRST = 32768;
				MARK_LAST = 8192;
				VERB = 15;
				SET_MARK = 32768;
				SET_COMPONENT = 32768;
				PERFORM_ACTION = 8192;
				LAST_MASK = 2147483648;
				STORE_MASK = 1073741824;
				OFFSET_MASK = 1073741823;
				VERTICAL_ONLY = 8388608;
				REVERSE_DIRECTION = 4194304;
				HORIZONTAL_AND_VERTICAL = 2097152;
				CURRENT_IS_KASHIDA_LIKE = 8192;
				MARKED_IS_KASHIDA_LIKE = 4096;
				CURRENT_INSERT_BEFORE = 2048;
				MARKED_INSERT_BEFORE = 1024;
				CURRENT_INSERT_COUNT = 992;
				MARKED_INSERT_COUNT = 31;

				function AATMorxProcessor(font) {
					this.font = font;
					this.processGlyphInsertion = bind(this.processGlyphInsertion, this);
					this.processNoncontextualSubstitutions = bind(this.processNoncontextualSubstitutions, this);
					this.processLigature = bind(this.processLigature, this);
					this.processContextualSubstitution = bind(this.processContextualSubstitution, this);
					this.processIndicRearragement = bind(this.processIndicRearragement, this);
					this.morx = this.font.morx
				}
				AATMorxProcessor.prototype.process = function(glyphs, features) {
					var chain, f, feature, flags, i, index, j, k, len, len1, len2, ref, ref1, ref2, subtable;
					if (features == null) {
						features = {}
					}
					ref = this.morx.chains;
					for (i = 0, len = ref.length; i < len; i++) {
						chain = ref[i];
						flags = chain.defaultFlags;
						ref1 = chain.features;
						for (j = 0, len1 = ref1.length; j < len1; j++) {
							feature = ref1[j];
							if ((f = features[feature.featureType]) && f[feature.featureSetting]) {
								flags &= feature.disableFlags;
								flags |= feature.enableFlags
							}
						}
						ref2 = chain.subtables;
						for (index = k = 0, len2 = ref2.length; k < len2; index = ++k) {
							subtable = ref2[index];
							if (subtable.subFeatureFlags & flags) {
								this.processSubtable(subtable, glyphs)
							}
						}
					}
					index = glyphs.length - 1;
					while (index >= 0) {
						if (glyphs[index].id === 65535) {
							glyphs.splice(index, 1)
						}
						index--
					}
					return glyphs
				};
				AATMorxProcessor.prototype.processSubtable = function(subtable1, glyphs1) {
					var process, reverse, stateMachine;
					this.subtable = subtable1;
					this.glyphs = glyphs1;
					if (this.subtable.type === 4) {
						this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
						return
					}
					this.ligatureStack = [];
					this.markedGlyph = null;
					this.firstGlyph = null;
					this.lastGlyph = null;
					this.markedIndex = null;
					stateMachine = new AATStateMachine(this.subtable.table.stateTable);
					process = function() {
						switch (this.subtable.type) {
							case 0:
								return this.processIndicRearragement;
							case 1:
								return this.processContextualSubstitution;
							case 2:
								return this.processLigature;
							case 5:
								return this.processGlyphInsertion;
							default:
								throw new Error("Invalid morx subtable type: " + this.subtable.type)
						}
					}.call(this);
					reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);
					return stateMachine.process(this.glyphs, reverse, process)
				};
				AATMorxProcessor.prototype.processIndicRearragement = function(glyph, entry, index) {
					if (entry.flags & MARK_FIRST) {
						this.firstGlyph = index
					}
					if (entry.flags & MARK_LAST) {
						this.lastGlyph = index
					}
					reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph)
				};
				swap = function(glyphs, rangeA, rangeB, reverseA, reverseB) {
					var end, start;
					if (reverseA == null) {
						reverseA = false
					}
					if (reverseB == null) {
						reverseB = false
					}
					end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
					if (reverseB) {
						end.reverse()
					}
					start = glyphs.splice.apply(glyphs, [rangeA[0], rangeA[1]].concat(slice.call(end)));
					if (reverseA) {
						start.reverse()
					}
					return glyphs.splice.apply(glyphs, [rangeB[0] - (rangeA[1] - 1), 0].concat(slice.call(start)))
				};
				reorderGlyphs = function(glyphs, verb, firstGlyph, lastGlyph) {
					var length;
					length = lastGlyph - firstGlyph + 1;
					switch (verb) {
						case 0:
							break;
						case 1:
							swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);
							break;
						case 2:
							swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);
							break;
						case 3:
							swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);
							break;
						case 4:
							swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);
							break;
						case 5:
							swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);
							break;
						case 6:
							swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);
							break;
						case 7:
							swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);
							break;
						case 8:
							swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);
							break;
						case 9:
							swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);
							break;
						case 10:
							swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);
							break;
						case 11:
							swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);
							break;
						case 12:
							swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);
							break;
						case 13:
							swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);
							break;
						case 14:
							swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);
							break;
						case 15:
							swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);
							break;
						default:
							throw new Error("Unknown verb: " + verb)
					}
					return glyphs
				};
				AATMorxProcessor.prototype.processContextualSubstitution = function(glyph, entry, index) {
					var gid, lookup, lookupTable, subsitutions;
					subsitutions = this.subtable.table.substitutionTable.items;
					if (entry.markIndex !== 65535) {
						lookup = subsitutions.getItem(entry.markIndex);
						lookupTable = new AATLookupTable(lookup);
						glyph = this.glyphs[this.markedGlyph];
						gid = lookupTable.lookup(glyph.id);
						if (gid) {
							this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints)
						}
					}
					if (entry.currentIndex !== 65535) {
						lookup = subsitutions.getItem(entry.currentIndex);
						lookupTable = new AATLookupTable(lookup);
						glyph = this.glyphs[index];
						gid = lookupTable.lookup(glyph.id);
						if (gid) {
							this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints)
						}
					}
					if (entry.flags & SET_MARK) {
						this.markedGlyph = index
					}
				};
				AATMorxProcessor.prototype.processLigature = function(glyph, entry, index) {
					var action, actionIndex, actions, codePoints, component, componentGlyph, components, last, ligatureEntry, ligatureGlyphs, ligatureIndex, ligatureList, offset, ref, store;
					if (entry.flags & SET_COMPONENT) {
						this.ligatureStack.push(index)
					}
					if (entry.flags & PERFORM_ACTION) {
						actions = this.subtable.table.ligatureActions;
						components = this.subtable.table.components;
						ligatureList = this.subtable.table.ligatureList;
						actionIndex = entry.action;
						last = false;
						ligatureIndex = 0;
						codePoints = [];
						ligatureGlyphs = [];
						while (!last) {
							componentGlyph = this.ligatureStack.pop();
							codePoints.unshift.apply(codePoints, this.glyphs[componentGlyph].codePoints);
							action = actions.getItem(actionIndex++);
							last = !!(action & LAST_MASK);
							store = !!(action & STORE_MASK);
							offset = (action & OFFSET_MASK) << 2 >> 2;
							offset += this.glyphs[componentGlyph].id;
							component = components.getItem(offset);
							ligatureIndex += component;
							if (last || store) {
								ligatureEntry = ligatureList.getItem(ligatureIndex);
								this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
								ligatureGlyphs.push(componentGlyph);
								ligatureIndex = 0;
								codePoints = []
							} else {
								this.glyphs[componentGlyph] = this.font.getGlyph(65535)
							}
						}(ref = this.ligatureStack).push.apply(ref, ligatureGlyphs)
					}
				};
				AATMorxProcessor.prototype.processNoncontextualSubstitutions = function(subtable, glyphs, index) {
					var gid, glyph, i, len, lookupTable;
					lookupTable = new AATLookupTable(subtable.table.lookupTable);
					for (index = i = 0, len = glyphs.length; i < len; index = ++i) {
						glyph = glyphs[index];
						if (!(glyph.id !== 65535)) {
							continue
						}
						gid = lookupTable.lookup(glyph.id);
						if (gid) {
							glyphs[index] = this.font.getGlyph(gid, glyph.codePoints)
						}
					}
				};
				AATMorxProcessor.prototype._insertGlyphs = function(glyphIndex, insertionActionIndex, count, isBefore) {
					var gid, insertions, ref;
					insertions = function() {
						var results;
						results = [];
						while (count--) {
							gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
							results.push(this.font.getGlyph(gid))
						}
						return results
					}.call(this);
					if (!isBefore) {
						glyphIndex++
					}(ref = this.glyphs).splice.apply(ref, [glyphIndex, 0].concat(slice.call(insertions)))
				};
				AATMorxProcessor.prototype.processGlyphInsertion = function(glyph, entry, index) {
					var count, isBefore;
					if (entry.flags & SET_MARK) {
						this.markedIndex = index
					}
					if (entry.markedInsertIndex !== 65535) {
						count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;
						isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);
						this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore)
					}
					if (entry.currentInsertIndex !== 65535) {
						count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;
						isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);
						this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore)
					}
				};
				AATMorxProcessor.prototype.getSupportedFeatures = function() {
					var chain, feature, features, i, j, len, len1, ref, ref1;
					features = [];
					ref = this.morx.chains;
					for (i = 0, len = ref.length; i < len; i++) {
						chain = ref[i];
						ref1 = chain.features;
						for (j = 0, len1 = ref1.length; j < len1; j++) {
							feature = ref1[j];
							features.push([feature.featureType, feature.featureSetting])
						}
					}
					return features
				};
				return AATMorxProcessor
			}();
			module.exports = AATMorxProcessor
		}).call(this)
	}, {
		"./AATLookupTable": 29,
		"./AATStateMachine": 31
	}],
	31: [function(require, module, exports) {
		(function() {
			var AATLookupTable, AATStateMachine;
			AATLookupTable = require("./AATLookupTable");
			AATStateMachine = function() {
				var DELETED_GLYPH_CLASS, DONT_ADVANCE, END_OF_LINE_CLASS, END_OF_TEXT_CLASS, OUT_OF_BOUNDS_CLASS, START_OF_LINE_STATE, START_OF_TEXT_STATE;

				function AATStateMachine(stateTable) {
					this.stateTable = stateTable;
					this.lookupTable = new AATLookupTable(this.stateTable.classTable)
				}
				START_OF_TEXT_STATE = 0;
				START_OF_LINE_STATE = 1;
				END_OF_TEXT_CLASS = 0;
				OUT_OF_BOUNDS_CLASS = 1;
				DELETED_GLYPH_CLASS = 2;
				END_OF_LINE_CLASS = 3;
				DONT_ADVANCE = 16384;
				AATStateMachine.prototype.process = function(glyphs, reverse, processEntry) {
					var classCode, currentState, dir, entry, entryIndex, glyph, index, row, shouldAdvance;
					currentState = START_OF_TEXT_STATE;
					index = reverse ? glyphs.length - 1 : 0;
					dir = reverse ? -1 : 1;
					while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {
						glyph = null;
						classCode = OUT_OF_BOUNDS_CLASS;
						shouldAdvance = true;
						if (index === glyphs.length || index === -1) {
							classCode = END_OF_TEXT_CLASS
						} else {
							glyph = glyphs[index];
							if (glyph.id === 65535) {
								classCode = DELETED_GLYPH_CLASS
							} else {
								classCode = this.lookupTable.lookup(glyph.id);
								if (classCode == null) {
									classCode = OUT_OF_BOUNDS_CLASS
								}
							}
						}
						row = this.stateTable.stateArray.getItem(currentState);
						entryIndex = row[classCode];
						entry = this.stateTable.entryTable.getItem(entryIndex);
						if (classCode !== END_OF_TEXT_CLASS && classCode !== DELETED_GLYPH_CLASS) {
							processEntry(glyph, entry, index);
							shouldAdvance = !(entry.flags & DONT_ADVANCE)
						}
						currentState = entry.newState;
						if (shouldAdvance) {
							index += dir
						}
					}
					return glyphs
				};
				return AATStateMachine
			}();
			module.exports = AATStateMachine
		}).call(this)
	}, {
		"./AATLookupTable": 29
	}],
	32: [function(require, module, exports) {
		(function() {
			exports.ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
			exports.ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
			exports.ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"]
		}).call(this)
	}, {}],
	33: [function(require, module, exports) {
		(function() {
			var CFFDict, CFFOperand, PropertyDescriptor, isEqual, r;
			isEqual = require("deep-equal");
			r = require("restructure");
			CFFOperand = require("./CFFOperand");
			PropertyDescriptor = require("restructure/src/utils").PropertyDescriptor;
			CFFDict = function() {
				var decodeOperands, encodeOperands;

				function CFFDict(ops) {
					var field, j, key, len1, ref;
					this.ops = ops != null ? ops : [];
					this.fields = {};
					ref = this.ops;
					for (j = 0, len1 = ref.length; j < len1; j++) {
						field = ref[j];
						key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
						this.fields[key] = field
					}
				}
				decodeOperands = function(type, stream, ret, operands) {
					var i, j, len1, op, results;
					if (Array.isArray(type)) {
						results = [];
						for (i = j = 0, len1 = operands.length; j < len1; i = ++j) {
							op = operands[i];
							results.push(decodeOperands(type[i], stream, ret, [op]))
						}
						return results
					} else if (type.decode != null) {
						return type.decode(stream, ret, operands)
					} else {
						switch (type) {
							case "number":
							case "offset":
							case "sid":
								return operands[0];
							case "boolean":
								return !!operands[0];
							default:
								return operands
						}
					}
				};
				encodeOperands = function(type, stream, ctx, operands) {
					var i, j, len1, op, results;
					if (Array.isArray(type)) {
						results = [];
						for (i = j = 0, len1 = operands.length; j < len1; i = ++j) {
							op = operands[i];
							results.push(encodeOperands(type[i], stream, ctx, op)[0])
						}
						return results
					} else if (type.encode != null) {
						return type.encode(stream, operands, ctx)
					} else if (typeof operands === "number") {
						return [operands]
					} else if (typeof operands === "boolean") {
						return [+operands]
					} else if (Array.isArray(operands)) {
						return operands
					} else {
						return [operands]
					}
				};
				CFFDict.prototype.decode = function(stream, parent) {
					var b, end, field, key, operands, ref, ret, val;
					end = stream.pos + parent.length;
					ret = {};
					operands = [];
					Object.defineProperties(ret, {
						parent: {
							value: parent
						},
						_startOffset: {
							value: stream.pos
						}
					});
					ref = this.fields;
					for (key in ref) {
						field = ref[key];
						ret[field[1]] = field[3]
					}
					while (stream.pos < end) {
						b = stream.readUInt8();
						if (b <= 21) {
							if (b === 12) {
								b = b << 8 | stream.readUInt8()
							}
							field = this.fields[b];
							if (!field) {
								throw new Error("Unknown operator " + b)
							}
							val = decodeOperands(field[2], stream, ret, operands);
							if (val != null) {
								if (val instanceof PropertyDescriptor) {
									Object.defineProperty(ret, field[1], val)
								} else {
									ret[field[1]] = val
								}
							}
							operands = []
						} else {
							operands.push(CFFOperand.decode(stream, b))
						}
					}
					return ret
				};
				CFFDict.prototype.size = function(dict, parent, includePointers) {
					var ctx, field, j, k, key, len, len1, op, operands, ref, val;
					if (includePointers == null) {
						includePointers = true
					}
					ctx = {
						parent: parent,
						val: dict,
						pointerSize: 0,
						startOffset: parent.startOffset || 0
					};
					len = 0;
					ref = this.fields;
					for (k in ref) {
						field = ref[k];
						val = dict[field[1]];
						if (val == null || isEqual(val, field[3])) {
							continue
						}
						operands = encodeOperands(field[2], null, ctx, val);
						for (j = 0, len1 = operands.length; j < len1; j++) {
							op = operands[j];
							len += CFFOperand.size(op)
						}
						key = Array.isArray(field[0]) ? field[0] : [field[0]];
						len += key.length
					}
					if (includePointers) {
						len += ctx.pointerSize
					}
					return len
				};
				CFFDict.prototype.encode = function(stream, dict, parent) {
					var ctx, field, i, j, key, l, len1, len2, len3, m, op, operands, ptr, ref, val;
					ctx = {
						pointers: [],
						startOffset: stream.pos,
						parent: parent,
						val: dict,
						pointerSize: 0
					};
					ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);
					ref = this.ops;
					for (j = 0, len1 = ref.length; j < len1; j++) {
						field = ref[j];
						val = dict[field[1]];
						if (val == null || isEqual(val, field[3])) {
							continue
						}
						operands = encodeOperands(field[2], stream, ctx, val);
						for (l = 0, len2 = operands.length; l < len2; l++) {
							op = operands[l];
							CFFOperand.encode(stream, op)
						}
						key = Array.isArray(field[0]) ? field[0] : [field[0]];
						for (m = 0, len3 = key.length; m < len3; m++) {
							op = key[m];
							stream.writeUInt8(op)
						}
					}
					i = 0;
					while (i < ctx.pointers.length) {
						ptr = ctx.pointers[i++];
						ptr.type.encode(stream, ptr.val, ptr.parent)
					}
				};
				return CFFDict
			}();
			module.exports = CFFDict
		}).call(this)
	}, {
		"./CFFOperand": 36,
		"deep-equal": 115,
		restructure: 3,
		"restructure/src/utils": 19
	}],
	34: [function(require, module, exports) {
		(function() {
			exports.StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"];
			exports.ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"]
		}).call(this)
	}, {}],
	35: [function(require, module, exports) {
		(function() {
			var CFFIndex, r;
			r = require("restructure");
			CFFIndex = function() {
				function CFFIndex(type1) {
					this.type = type1
				}
				CFFIndex.prototype.decode = function(stream, parent) {
					var count, end, i, j, offSize, offsetType, pos, ref, ret, start, startPos;
					count = stream.readUInt16BE();
					if (count === 0) {
						return []
					}
					offSize = stream.readUInt8();
					offsetType = function() {
						switch (offSize) {
							case 1:
								return r.uint8;
							case 2:
								return r.uint16;
							case 3:
								return r.uint24;
							case 4:
								return r.uint32;
							default:
								throw new Error("Bad offset size in CFFIndex: " + offSize + " " + stream.pos)
						}
					}();
					ret = [];
					startPos = stream.pos + (count + 1) * offSize - 1;
					start = offsetType.decode(stream);
					for (i = j = 0, ref = count; j < ref; i = j += 1) {
						end = offsetType.decode(stream);
						if (this.type != null) {
							pos = stream.pos;
							stream.pos = startPos + start;
							parent.length = end - start;
							ret.push(this.type.decode(stream, parent));
							stream.pos = pos
						} else {
							ret.push({
								offset: startPos + start,
								length: end - start
							})
						}
						start = end
					}
					stream.pos = startPos + start;
					return ret
				};
				CFFIndex.prototype.size = function(arr, parent) {
					var item, j, len, offset, offsetType, size, type;
					size = 2;
					if (arr.length === 0) {
						return size
					}
					type = this.type || new r.Buffer;
					offset = 1;
					for (j = 0, len = arr.length; j < len; j++) {
						item = arr[j];
						offset += type.size(item, parent)
					}
					offsetType = function() {
						if (offset <= 255) {
							return r.uint8
						} else if (offset <= 65535) {
							return r.uint16
						} else if (offset <= 16777215) {
							return r.uint24
						} else if (offset <= 4294967295) {
							return r.uint32
						} else {
							throw new Error("Bad offset in CFFIndex")
						}
					}();
					size += 1 + offsetType.size() * (arr.length + 1);
					size += offset - 1;
					return size
				};
				CFFIndex.prototype.encode = function(stream, arr, parent) {
					var i, item, j, k, l, len, len1, len2, offset, offsetType, s, sizes, type;
					stream.writeUInt16BE(arr.length);
					if (arr.length === 0) {
						return
					}
					type = this.type || new r.Buffer;
					sizes = [];
					offset = 1;
					for (j = 0, len = arr.length; j < len; j++) {
						item = arr[j];
						s = type.size(item, parent);
						sizes.push(s);
						offset += s
					}
					offsetType = function() {
						if (offset <= 255) {
							return r.uint8
						} else if (offset <= 65535) {
							return r.uint16
						} else if (offset <= 16777215) {
							return r.uint24
						} else if (offset <= 4294967295) {
							return r.uint32
						} else {
							throw new Error("Bad offset in CFFIndex")
						}
					}();
					stream.writeUInt8(offsetType.size());
					offset = 1;
					offsetType.encode(stream, offset);
					for (i = k = 0, len1 = arr.length; k < len1; i = ++k) {
						item = arr[i];
						offset += sizes[i];
						offsetType.encode(stream, offset)
					}
					for (l = 0, len2 = arr.length; l < len2; l++) {
						item = arr[l];
						type.encode(stream, item, parent)
					}
				};
				return CFFIndex
			}();
			module.exports = CFFIndex
		}).call(this)
	}, {
		restructure: 3
	}],
	36: [function(require, module, exports) {
		(function() {
			var CFFOperand;
			CFFOperand = function() {
				var FLOAT_ENCODE_LOOKUP, FLOAT_EOF, FLOAT_LOOKUP;

				function CFFOperand() {}
				FLOAT_EOF = 15;
				FLOAT_LOOKUP = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
				FLOAT_ENCODE_LOOKUP = {
					".": 10,
					E: 11,
					"E-": 12,
					"-": 14
				};
				CFFOperand.prototype.decode = function(stream, value) {
					var b, n1, n2, str;
					if (32 <= value && value <= 246) {
						return value - 139
					}
					if (247 <= value && value <= 250) {
						return (value - 247) * 256 + stream.readUInt8() + 108
					}
					if (251 <= value && value <= 254) {
						return -(value - 251) * 256 - stream.readUInt8() - 108
					}
					if (value === 28) {
						return stream.readInt16BE()
					}
					if (value === 29) {
						return stream.readInt32BE()
					}
					if (value === 30) {
						str = "";
						while (true) {
							b = stream.readUInt8();
							n1 = b >> 4;
							if (n1 === FLOAT_EOF) {
								break
							}
							str += FLOAT_LOOKUP[n1];
							n2 = b & 15;
							if (n2 === FLOAT_EOF) {
								break
							}
							str += FLOAT_LOOKUP[n2]
						}
						return parseFloat(str)
					}
					return null
				};
				CFFOperand.prototype.size = function(value) {
					var str;
					if (value.forceLarge) {
						value = 32768
					}
					if ((value | 0) !== value) {
						str = "" + value;
						return 1 + Math.ceil((str.length + 1) / 2)
					} else if (-107 <= value && value <= 107) {
						return 1
					} else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {
						return 2
					} else if (-32768 <= value && value <= 32767) {
						return 3
					} else {
						return 5
					}
				};
				CFFOperand.prototype.encode = function(stream, value) {
					var c1, c2, i, j, len, n1, n2, str, val;
					val = Number(value);
					if (value.forceLarge) {
						stream.writeUInt8(29);
						return stream.writeInt32BE(val)
					} else if ((val | 0) !== val) {
						stream.writeUInt8(30);
						str = "" + val;
						for (i = j = 0, len = str.length; j < len; i = j += 2) {
							c1 = str[i];
							n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;
							if (i === str.length - 1) {
								n2 = FLOAT_EOF
							} else {
								c2 = str[i + 1];
								n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2
							}
							stream.writeUInt8(n1 << 4 | n2 & 15)
						}
						if (n2 !== FLOAT_EOF) {
							return stream.writeUInt8(FLOAT_EOF << 4)
						}
					} else if (-107 <= val && val <= 107) {
						return stream.writeUInt8(val + 139)
					} else if (108 <= val && val <= 1131) {
						val -= 108;
						stream.writeUInt8((val >> 8) + 247);
						return stream.writeUInt8(val & 255)
					} else if (-1131 <= val && val <= -108) {
						val = -val - 108;
						stream.writeUInt8((val >> 8) + 251);
						return stream.writeUInt8(val & 255)
					} else if (-32768 <= val && val <= 32767) {
						stream.writeUInt8(28);
						return stream.writeInt16BE(val)
					} else {
						stream.writeUInt8(29);
						return stream.writeInt32BE(val)
					}
				};
				return CFFOperand
			}();
			module.exports = new CFFOperand
		}).call(this)
	}, {}],
	37: [function(require, module, exports) {
		(function() {
			var CFFPointer, r, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty;
			r = require("restructure");
			CFFPointer = function(superClass) {
				var Ptr;
				extend(CFFPointer, superClass);

				function CFFPointer(type, options) {
					if (options == null) {
						options = {}
					}
					if (options.type == null) {
						options.type = "global"
					}
					CFFPointer.__super__.constructor.call(this, null, type, options)
				}
				CFFPointer.prototype.decode = function(stream, parent, operands) {
					this.offsetType = {
						decode: function() {
							return operands[0]
						}
					};
					return CFFPointer.__super__.decode.apply(this, arguments)
				};
				Ptr = function() {
					function Ptr(val1) {
						this.val = val1;
						this.forceLarge = true
					}
					Ptr.prototype.valueOf = function() {
						return this.val
					};
					return Ptr
				}();
				CFFPointer.prototype.encode = function(stream, value, ctx) {
					var ptr;
					if (!stream) {
						this.offsetType = {
							size: function() {
								return 0
							}
						};
						this.size(value, ctx);
						return [new Ptr(0)]
					}
					ptr = null;
					this.offsetType = {
						encode: function(stream, val) {
							return ptr = val
						}
					};
					CFFPointer.__super__.encode.apply(this, arguments);
					return [new Ptr(ptr)]
				};
				return CFFPointer
			}(r.Pointer);
			module.exports = CFFPointer
		}).call(this)
	}, {
		restructure: 3
	}],
	38: [function(require, module, exports) {
		(function() {
			var CFFDict, CFFIndex, CFFPointer;
			CFFDict = require("./CFFDict");
			CFFIndex = require("./CFFIndex");
			CFFPointer = require("./CFFPointer");
			module.exports = new CFFDict([
				[6, "BlueValues", "delta", null],
				[7, "OtherBlues", "delta", null],
				[8, "FamilyBlues", "delta", null],
				[9, "FamilyOtherBlues", "delta", null],
				[
					[12, 9], "BlueScale", "number", .039625
				],
				[
					[12, 10], "BlueShift", "number", 7
				],
				[
					[12, 11], "BlueFuzz", "number", 1
				],
				[10, "StdHW", "number", null],
				[11, "StdVW", "number", null],
				[
					[12, 12], "StemSnapH", "delta", null
				],
				[
					[12, 13], "StemSnapV", "delta", null
				],
				[
					[12, 14], "ForceBold", "boolean", false
				],
				[
					[12, 17], "LanguageGroup", "number", 0
				],
				[
					[12, 18], "ExpansionFactor", "number", .06
				],
				[
					[12, 19], "initialRandomSeed", "number", 0
				],
				[20, "defaultWidthX", "number", 0],
				[21, "nominalWidthX", "number", 0],
				[19, "Subrs", new CFFPointer(new CFFIndex, {
					type: "local"
				}), null]
			])
		}).call(this)
	}, {
		"./CFFDict": 33,
		"./CFFIndex": 35,
		"./CFFPointer": 37
	}],
	39: [function(require, module, exports) {
		(function() {
			module.exports = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"]
		}).call(this)
	}, {}],
	40: [function(require, module, exports) {
		(function() {
			var CFFCharset, CFFCustomCharset, CFFCustomEncoding, CFFDict, CFFEncoding, CFFEncodingVersion, CFFHeader, CFFIndex, CFFPointer, CFFPrivateDict, CFFPrivateOp, CFFTop, CFFTopDict, ExpertCharset, ExpertEncoding, ExpertSubsetCharset, FDRange, FDSelect, FontDict, ISOAdobeCharset, PredefinedOp, Range1, Range2, RangeArray, StandardEncoding, StandardStrings, r, ref, ref1, resolveLength, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty;
			r = require("restructure");
			resolveLength = require("restructure/src/utils").resolveLength;
			CFFDict = require("./CFFDict");
			CFFIndex = require("./CFFIndex");
			CFFPointer = require("./CFFPointer");
			CFFPrivateDict = require("./CFFPrivateDict");
			StandardStrings = require("./CFFStandardStrings");
			ref = require("./CFFEncodings"), StandardEncoding = ref.StandardEncoding, ExpertEncoding = ref.ExpertEncoding;
			ref1 = require("./CFFCharsets"), ISOAdobeCharset = ref1.ISOAdobeCharset, ExpertCharset = ref1.ExpertCharset, ExpertSubsetCharset = ref1.ExpertSubsetCharset;
			PredefinedOp = function() {
				function PredefinedOp(predefinedOps, type) {
					this.predefinedOps = predefinedOps;
					this.type = type
				}
				PredefinedOp.prototype.decode = function(stream, parent, operands) {
					if (this.predefinedOps[operands[0]]) {
						return this.predefinedOps[operands[0]]
					}
					return this.type.decode(stream, parent, operands)
				};
				PredefinedOp.prototype.size = function(value, ctx) {
					return this.type.size(value, ctx)
				};
				PredefinedOp.prototype.encode = function(stream, value, ctx) {
					var index;
					index = this.predefinedOps.indexOf(value);
					if (index !== -1) {
						return index
					}
					return this.type.encode(stream, value, ctx)
				};
				return PredefinedOp
			}();
			CFFEncodingVersion = function(superClass) {
				extend(CFFEncodingVersion, superClass);

				function CFFEncodingVersion() {
					CFFEncodingVersion.__super__.constructor.call(this, "UInt8")
				}
				CFFEncodingVersion.prototype.decode = function(stream) {
					return r.uint8.decode(stream) & 127
				};
				return CFFEncodingVersion
			}(r.Number);
			Range1 = new r.Struct({
				first: r.uint16,
				nLeft: r.uint8
			});
			Range2 = new r.Struct({
				first: r.uint16,
				nLeft: r.uint16
			});
			CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion, {
				0: {
					nCodes: r.uint8,
					codes: new r.Array(r.uint8, "nCodes")
				},
				1: {
					nRanges: r.uint8,
					ranges: new r.Array(Range1, "nRanges")
				}
			});
			CFFEncoding = new PredefinedOp([StandardEncoding, ExpertEncoding], new CFFPointer(CFFCustomEncoding, {
				lazy: true
			}));
			RangeArray = function(superClass) {
				extend(RangeArray, superClass);

				function RangeArray() {
					return RangeArray.__super__.constructor.apply(this, arguments)
				}
				RangeArray.prototype.decode = function(stream, parent) {
					var count, length, range, res;
					length = resolveLength(this.length, stream, parent);
					count = 0;
					res = [];
					while (count < length) {
						range = this.type.decode(stream, parent);
						range.offset = count;
						count += range.nLeft + 1;
						res.push(range)
					}
					return res
				};
				return RangeArray
			}(r.Array);
			CFFCustomCharset = new r.VersionedStruct(r.uint8, {
				0: {
					glyphs: new r.Array(r.uint16, function() {
						return this.parent.CharStrings.length - 1
					})
				},
				1: {
					ranges: new RangeArray(Range1, function() {
						return this.parent.CharStrings.length - 1
					})
				},
				2: {
					ranges: new RangeArray(Range2, function() {
						return this.parent.CharStrings.length - 1
					})
				}
			});
			CFFCharset = new PredefinedOp([ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset], new CFFPointer(CFFCustomCharset, {
				lazy: true
			}));
			FDRange = new r.Struct({
				first: r.uint16,
				fd: r.uint8
			});
			FDSelect = new r.VersionedStruct(r.uint8, {
				0: {
					fds: new r.Array(r.uint8, function() {
						return this.parent.CharStrings.length
					})
				},
				3: {
					nRanges: r.uint16,
					ranges: new r.Array(FDRange, "nRanges"),
					sentinel: r.uint16
				}
			});
			CFFPrivateOp = function() {
				var ptr;

				function CFFPrivateOp() {}
				ptr = new CFFPointer(CFFPrivateDict);
				CFFPrivateOp.prototype.decode = function(stream, parent, operands) {
					parent.length = operands[0];
					return ptr.decode(stream, parent, [operands[1]])
				};
				CFFPrivateOp.prototype.size = function(dict, ctx) {
					return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]]
				};
				CFFPrivateOp.prototype.encode = function(stream, dict, ctx) {
					return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream, dict, ctx)[0]]
				};
				return CFFPrivateOp
			}();
			FontDict = new CFFDict([
				[18, "Private", new CFFPrivateOp, null],
				[
					[12, 38], "FontName", "sid", null
				]
			]);
			CFFTopDict = new CFFDict([
				[
					[12, 30], "ROS", ["sid", "sid", "number"], null
				],
				[0, "version", "sid", null],
				[1, "Notice", "sid", null],
				[
					[12, 0], "Copyright", "sid", null
				],
				[2, "FullName", "sid", null],
				[3, "FamilyName", "sid", null],
				[4, "Weight", "sid", null],
				[
					[12, 1], "isFixedPitch", "boolean", false
				],
				[
					[12, 2], "ItalicAngle", "number", 0
				],
				[
					[12, 3], "UnderlinePosition", "number", -100
				],
				[
					[12, 4], "UnderlineThickness", "number", 50
				],
				[
					[12, 5], "PaintType", "number", 0
				],
				[
					[12, 6], "CharstringType", "number", 2
				],
				[
					[12, 7], "FontMatrix", "array", [.001, 0, 0, .001, 0, 0]
				],
				[13, "UniqueID", "number", null],
				[5, "FontBBox", "array", [0, 0, 0, 0]],
				[
					[12, 8], "StrokeWidth", "number", 0
				],
				[14, "XUID", "array", null],
				[15, "charset", CFFCharset, ISOAdobeCharset],
				[16, "Encoding", CFFEncoding, StandardEncoding],
				[17, "CharStrings", new CFFPointer(new CFFIndex), null],
				[18, "Private", new CFFPrivateOp, null],
				[
					[12, 20], "SyntheticBase", "number", null
				],
				[
					[12, 21], "PostScript", "sid", null
				],
				[
					[12, 22], "BaseFontName", "sid", null
				],
				[
					[12, 23], "BaseFontBlend", "delta", null
				],
				[
					[12, 31], "CIDFontVersion", "number", 0
				],
				[
					[12, 32], "CIDFontRevision", "number", 0
				],
				[
					[12, 33], "CIDFontType", "number", 0
				],
				[
					[12, 34], "CIDCount", "number", 8720
				],
				[
					[12, 35], "UIDBase", "number", null
				],
				[
					[12, 37], "FDSelect", new CFFPointer(FDSelect), null
				],
				[
					[12, 36], "FDArray", new CFFPointer(new CFFIndex(FontDict)), null
				],
				[
					[12, 38], "FontName", "sid", null
				]
			]);
			CFFHeader = new r.Struct({
				majorVersion: r.uint8,
				minorVersion: r.uint8,
				hdrSize: r.uint8,
				offSize: r.uint8
			});
			CFFTop = new r.Struct({
				header: CFFHeader,
				nameIndex: new CFFIndex(new r.String("length")),
				topDictIndex: new CFFIndex(CFFTopDict),
				stringIndex: new CFFIndex(new r.String("length")),
				globalSubrIndex: new CFFIndex
			});
			module.exports = CFFTop
		}).call(this)
	}, {
		"./CFFCharsets": 32,
		"./CFFDict": 33,
		"./CFFEncodings": 34,
		"./CFFIndex": 35,
		"./CFFPointer": 37,
		"./CFFPrivateDict": 38,
		"./CFFStandardStrings": 39,
		restructure: 3,
		"restructure/src/utils": 19
	}],
	41: [function(require, module, exports) {
		(function() {
			module.exports = function(self) {
				return function(_this) {
					return function(key, fn) {
						return Object.defineProperty(self.prototype, key, {
							get: fn,
							enumerable: true
						})
					}
				}(this)
			}
		}).call(this)
	}, {}],
	42: [function(require, module, exports) {
		(function() {
			var BBox;
			BBox = function() {
				var get;
				get = require("../get")(BBox);

				function BBox(minX, minY, maxX, maxY) {
					this.minX = minX != null ? minX : Infinity;
					this.minY = minY != null ? minY : Infinity;
					this.maxX = maxX != null ? maxX : -Infinity;
					this.maxY = maxY != null ? maxY : -Infinity
				}
				get("width", function() {
					return this.maxX - this.minX
				});
				get("height", function() {
					return this.maxY - this.minY
				});
				BBox.prototype.addPoint = function(x, y) {
					if (x < this.minX) {
						this.minX = x
					}
					if (y < this.minY) {
						this.minY = y
					}
					if (x > this.maxX) {
						this.maxX = x
					}
					if (y > this.maxY) {
						return this.maxY = y
					}
				};
				BBox.prototype.copy = function() {
					return new BBox(this.minX, this.minY, this.maxX, this.maxY)
				};
				return BBox
			}();
			module.exports = BBox
		}).call(this)
	}, {
		"../get": 41
	}],
	43: [function(require, module, exports) {
		(function() {
			var CFFGlyph, Glyph, Path, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty;
			Glyph = require("./Glyph");
			Path = require("./Path");
			CFFGlyph = function(superClass) {
				var bias;
				extend(CFFGlyph, superClass);

				function CFFGlyph() {
					return CFFGlyph.__super__.constructor.apply(this, arguments)
				}
				CFFGlyph.prototype._getName = function() {
					return this._font["CFF "].getGlyphName(this.id)
				};
				bias = function(s) {
					if (s.length < 1240) {
						return 107
					} else if (s.length < 33900) {
						return 1131
					} else {
						return 32768
					}
				};
				CFFGlyph.prototype._getPath = function() {
					var cff, end, gsubrs, gsubrsBias, nStems, parse, parseStems, path, pos, privateDict, stack, str, stream, subrs, subrsBias, trans, usedGsubrs, usedSubrs, width, x, y;
					stream = this._font.stream;
					pos = stream.pos;
					cff = this._font["CFF "];
					str = cff.topDict.CharStrings[this.id];
					end = str.offset + str.length;
					stream.pos = str.offset;
					path = new Path;
					stack = [];
					trans = [];
					width = null;
					nStems = 0;
					x = y = 0;
					this._usedGsubrs = usedGsubrs = {};
					this._usedSubrs = usedSubrs = {};
					gsubrs = cff.globalSubrIndex || [];
					gsubrsBias = bias(gsubrs);
					privateDict = cff.privateDictForGlyph(this.id);
					subrs = privateDict.Subrs || [];
					subrsBias = bias(subrs);
					var open = false;

					function newContour(x, y) {
						if (open) {
							path.closePath()
						}
						path.moveTo(x, y);
						open = true
					}
					parseStems = function() {
						if (stack.length % 2 !== 0) {
							if (width == null) {
								width = stack.shift() + privateDict.nominalWidthX
							}
						}
						nStems += stack.length >> 1;
						return stack.length = 0
					};
					(parse = function() {
						var a, b, b1, c1x, c1y, c2x, c2y, c3x, c3y, c4x, c4y, c5x, c5y, c6x, c6y, e, haveWidth, i, idx, index, j, k, l, m, n, o, op, p, phase, pts, ref, ref1, s1, s2, startx, starty, subr, t, v1, v2, val;
						while (stream.pos < end) {
							op = stream.readUInt8();
							if (op < 32) {
								switch (op) {
									case 1:
									case 3:
									case 18:
									case 23:
										parseStems();
										break;
									case 4:
										if (stack.length > 1) {
											if (width == null) {
												width = stack.shift() + privateDict.nominalWidthX
											}
										}
										y += stack.shift();
										newContour(x, y);
										break;
									case 5:
										while (stack.length >= 2) {
											x += stack.shift();
											y += stack.shift();
											path.lineTo(x, y)
										}
										break;
									case 6:
									case 7:
										phase = op === 6;
										while (stack.length >= 1) {
											if (phase) {
												x += stack.shift()
											} else {
												y += stack.shift()
											}
											path.lineTo(x, y);
											phase = !phase
										}
										break;
									case 8:
										while (stack.length > 0) {
											c1x = x + stack.shift();
											c1y = y + stack.shift();
											c2x = c1x + stack.shift();
											c2y = c1y + stack.shift();
											x = c2x + stack.shift();
											y = c2y + stack.shift();
											path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y)
										}
										break;
									case 10:
										index = stack.pop() + subrsBias;
										subr = subrs[index];
										if (subr) {
											usedSubrs[index] = true;
											p = stream.pos;
											e = end;
											stream.pos = subr.offset;
											end = subr.offset + subr.length;
											parse();
											stream.pos = p;
											end = e
										}
										break;
									case 11:
										return;
									case 14:
										if (stack.length > 0) {
											if (width == null) {
												width = stack.shift() + privateDict.nominalWidthX
											}
										}
										path.closePath();
										break;
									case 19:
									case 20:
										parseStems();
										stream.pos += nStems + 7 >> 3;
										break;
									case 21:
										if (stack.length > 2) {
											if (width == null) {
												width = stack.shift() + privateDict.nominalWidthX
											}
											haveWidth = true
										}
										x += stack.shift();
										y += stack.shift();
										newContour(x, y);
										break;
									case 22:
										if (stack.length > 1) {
											if (width == null) {
												width = stack.shift() + privateDict.nominalWidthX
											}
										}
										x += stack.shift();
										newContour(x, y);
										break;
									case 24:
										while (stack.length >= 8) {
											c1x = x + stack.shift();
											c1y = y + stack.shift();
											c2x = c1x + stack.shift();
											c2y = c1y + stack.shift();
											x = c2x + stack.shift();
											y = c2y + stack.shift();
											path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y)
										}
										x += stack.shift();
										y += stack.shift();
										path.lineTo(x, y);
										break;
									case 25:
										while (stack.length >= 8) {
											x += stack.shift();
											y += stack.shift();
											path.lineTo(x, y)
										}
										c1x = x + stack.shift();
										c1y = y + stack.shift();
										c2x = c1x + stack.shift();
										c2y = c1y + stack.shift();
										x = c2x + stack.shift();
										y = c2y + stack.shift();
										path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
										break;
									case 26:
										if (stack.length % 2) {
											x += stack.shift()
										}
										while (stack.length >= 4) {
											c1x = x;
											c1y = y + stack.shift();
											c2x = c1x + stack.shift();
											c2y = c1y + stack.shift();
											x = c2x;
											y = c2y + stack.shift();
											path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y)
										}
										break;
									case 27:
										if (stack.length % 2) {
											y += stack.shift()
										}
										while (stack.length >= 4) {
											c1x = x + stack.shift();
											c1y = y;
											c2x = c1x + stack.shift();
											c2y = c1y + stack.shift();
											x = c2x + stack.shift();
											y = c2y;
											path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y)
										}
										break;
									case 28:
										stack.push(stream.readInt16BE());
										break;
									case 29:
										index = stack.pop() + gsubrsBias;
										subr = gsubrs[index];
										if (subr) {
											usedGsubrs[index] = true;
											p = stream.pos;
											e = end;
											stream.pos = subr.offset;
											end = subr.offset + subr.length;
											parse();
											stream.pos = p;
											end = e
										}
										break;
									case 30:
									case 31:
										phase = op === 31;
										while (stack.length >= 4) {
											if (phase) {
												c1x = x + stack.shift();
												c1y = y;
												c2x = c1x + stack.shift();
												c2y = c1y + stack.shift();
												y = c2y + stack.shift();
												x = c2x + (stack.length === 1 ? stack.shift() : 0)
											} else {
												c1x = x;
												c1y = y + stack.shift();
												c2x = c1x + stack.shift();
												c2y = c1y + stack.shift();
												x = c2x + stack.shift();
												y = c2y + (stack.length === 1 ? stack.shift() : 0)
											}
											path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
											phase = !phase
										}
										break;
									case 12:
										op = stream.readUInt8();
										switch (op) {
											case 3:
												a = stack.pop();
												b = stack.pop();
												stack.push(a && b ? 1 : 0);
												break;
											case 4:
												a = stack.pop();
												b = stack.pop();
												stack.push(a || b ? 1 : 0);
												break;
											case 5:
												a = stack.pop();
												stack.push(a ? 0 : 1);
												break;
											case 9:
												a = stack.pop();
												stack.push(Math.abs(a));
												break;
											case 10:
												a = stack.pop();
												b = stack.pop();
												stack.push(a + b);
												break;
											case 11:
												a = stack.pop();
												b = stack.pop();
												stack.push(a - b);
												break;
											case 12:
												a = stack.pop();
												b = stack.pop();
												stack.push(a / b);
												break;
											case 14:
												a = stack.pop();
												stack.push(-a);
												break;
											case 15:
												a = stack.pop();
												b = stack.pop();
												stack.push(a === b ? 1 : 0);
												break;
											case 18:
												stack.pop();
												break;
											case 20:
												val = stack.pop();
												idx = stack.pop();
												trans[idx] = val;
												break;
											case 21:
												idx = stack.pop();
												stack.push(trans[idx] || 0);
												break;
											case 22:
												s1 = stack.pop();
												s2 = stack.pop();
												v1 = stack.pop();
												v2 = stack.pop();
												stack.push(v1 <= v2 ? s1 : s2);
												break;
											case 23:
												stack.push(Math.random());
												break;
											case 24:
												a = stack.pop();
												b = stack.pop();
												stack.push(a * b);
												break;
											case 26:
												a = stack.pop();
												stack.push(Math.sqrt(a));
												break;
											case 27:
												a = stack.pop();
												stack.push(a, a);
												break;
											case 28:
												a = stack.pop();
												b = stack.pop();
												stack.push(b, a);
												break;
											case 29:
												idx = stack.pop();
												if (idx < 0) {
													idx = 0
												} else if (idx > stack.length - 1) {
													idx = stack.length - 1
												}
												stack.push(stack[idx]);
												break;
											case 30:
												n = stack.pop();
												j = stack.pop();
												if (j >= 0) {
													while (j > 0) {
														t = stack[n - 1];
														for (i = k = ref = n - 2; k >= 0; i = k += -1) {
															stack[i + 1] = stack[i]
														}
														stack[0] = t;
														j--
													}
												} else {
													while (j < 0) {
														t = stack[0];
														for (i = l = 0, ref1 = n; l <= ref1; i = l += 1) {
															stack[i] = stack[i + 1]
														}
														stack[n - 1] = t;
														j++
													}
												}
												break;
											case 34:
												c1x = x + stack.shift();
												c1y = y;
												c2x = c1x + stack.shift();
												c2y = c1y + stack.shift();
												c3x = c2x + stack.shift();
												c3y = c2y;
												c4x = c3x + stack.shift();
												c4y = c3y;
												c5x = c4x + stack.shift();
												c5y = c4y;
												c6x = c5x + stack.shift();
												c6y = c5y;
												x = c6x;
												y = c6y;
												path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
												path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
												break;
											case 35:
												pts = [];
												for (i = m = 0; m < 6; i = ++m) {
													x += stack.shift();
													y += stack.shift();
													pts.push(x, y)
												}
												path.bezierCurveTo.apply(path, pts.slice(0, 6));
												path.bezierCurveTo.apply(path, pts.slice(6));
												stack.shift();
												break;
											case 36:
												c1x = x + stack.shift();
												c1y = y + stack.shift();
												c2x = c1x + stack.shift();
												c2y = c1y + stack.shift();
												c3x = c2x + stack.shift();
												c3y = c2y;
												c4x = c3x + stack.shift();
												c4y = c3y;
												c5x = c4x + stack.shift();
												c5y = c4y + stack.shift();
												c6x = c5x + stack.shift();
												c6y = c5y;
												x = c6x;
												y = c6y;
												path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
												path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
												break;
											case 37:
												startx = x;
												starty = y;
												pts = [];
												for (i = o = 0; o < 5; i = ++o) {
													x += stack.shift();
													y += stack.shift();
													pts.push(x, y)
												}
												if (Math.abs(x - startx) > Math.abs(y - starty)) {
													x += stack.shift();
													y = starty
												} else {
													x = startx;
													y += stack.shift()
												}
												pts.push(x, y);
												path.bezierCurveTo.apply(path, pts.slice(0, 6));
												path.bezierCurveTo.apply(path, pts.slice(6));
												break;
											default:
												throw new Error("Unknown op: 12 " + op)
										}
										break;
									default:
										throw new Error("Unknown op: " + op)
								}
							} else if (op < 247) {
								stack.push(op - 139)
							} else if (op < 251) {
								b1 = stream.readUInt8();
								stack.push((op - 247) * 256 + b1 + 108)
							} else if (op < 255) {
								b1 = stream.readUInt8();
								stack.push(-(op - 251) * 256 - b1 - 108)
							} else {
								stack.push(stream.readInt32BE() / 65536)
							}
						}
					})();
					return path
				};
				return CFFGlyph
			}(Glyph);
			module.exports = CFFGlyph
		}).call(this)
	}, {
		"./Glyph": 45,
		"./Path": 47
	}],
	44: [function(require, module, exports) {
		(function() {
			var BBox, COLRGlyph, Glyph, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty;
			Glyph = require("./Glyph");
			BBox = require("./BBox");
			COLRGlyph = function(superClass) {
				var COLRLayer, get;
				extend(COLRGlyph, superClass);

				function COLRGlyph() {
					return COLRGlyph.__super__.constructor.apply(this, arguments)
				}
				get = require("../get")(COLRGlyph);
				COLRLayer = function() {
					function COLRLayer(glyph1, color1) {
						this.glyph = glyph1;
						this.color = color1
					}
					return COLRLayer
				}();
				COLRGlyph.prototype._getBBox = function() {
					var b, bbox, j, layer, len, ref;
					bbox = new BBox;
					ref = this.layers;
					for (j = 0, len = ref.length; j < len; j++) {
						layer = ref[j];
						b = layer.glyph.bbox;
						bbox.addPoint(b.minX, b.minY);
						bbox.addPoint(b.maxX, b.maxY)
					}
					return bbox
				};
				get("layers", function() {
					var baseLayer, color, colr, cpal, g, high, i, j, low, mid, rec, ref, ref1, results;
					cpal = this._font.CPAL;
					colr = this._font.COLR;
					low = 0;
					high = colr.baseGlyphRecord.length - 1;
					while (low <= high) {
						mid = low + high >> 1;
						rec = colr.baseGlyphRecord[mid];
						if (this.id < rec.gid) {
							high = mid - 1
						} else if (this.id > rec.gid) {
							low = mid + 1
						} else {
							baseLayer = rec;
							break
						}
					}
					if (baseLayer == null) {
						g = this._font._getBaseGlyph(this.id);
						color = {
							red: 0,
							green: 0,
							blue: 0,
							alpha: 255
						};
						return [new COLRLayer(g, color)]
					}
					results = [];
					for (i = j = ref = baseLayer.firstLayerIndex, ref1 = baseLayer.firstLayerIndex + baseLayer.numLayers; j < ref1; i = j += 1) {
						rec = colr.layerRecords[i];
						color = cpal.colorRecords[rec.paletteIndex];
						g = this._font._getBaseGlyph(rec.gid);
						results.push(new COLRLayer(g, color))
					}
					return results
				});
				COLRGlyph.prototype.render = function(ctx, size) {
					var color, glyph, j, len, ref, ref1, results;
					ref = this.layers;
					results = [];
					for (j = 0, len = ref.length; j < len; j++) {
						ref1 = ref[j], glyph = ref1.glyph, color = ref1.color;
						ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);
						results.push(glyph.render(ctx, size))
					}
					return results
				};
				return COLRGlyph
			}(Glyph);
			module.exports = COLRGlyph
		}).call(this)
	}, {
		"../get": 41,
		"./BBox": 42,
		"./Glyph": 45
	}],
	45: [function(require, module, exports) {
		(function() {
			var Glyph, Path, StandardNames, unicode;
			Path = require("./Path");
			unicode = require("unicode-properties");
			StandardNames = require("./StandardNames");
			Glyph = function() {
				var get, getMetrics;
				get = require("../get")(Glyph);

				function Glyph(id1, codePoints, _font) {
					this.id = id1;
					this.codePoints = codePoints;
					this._font = _font;
					this.isMark = this.codePoints.every(unicode.isMark);
					this.isLigature = this.codePoints.length > 1
				}
				Glyph.prototype._getPath = function() {
					return new Path
				};
				Glyph.prototype._getCBox = function() {
					return this.path.cbox
				};
				Glyph.prototype._getBBox = function() {
					return this.path.bbox
				};
				getMetrics = function(table, gid) {
					var ref, res;
					if (gid < table.metrics.length) {
						return table.metrics.get(gid)
					}
					res = {
						advance: ((ref = table.metrics.get(table.metrics.length - 1)) != null ? ref.advance : void 0) || 0,
						bearing: table.bearings.get(gid - table.metrics.length) || 0
					};
					return res
				};
				Glyph.prototype._getMetrics = function(cbox) {
					var advanceHeight, advanceWidth, hhea, leftBearing, os2, ref, ref1, topBearing;
					if (this._metrics) {
						return this._metrics
					}
					ref = getMetrics(this._font.hmtx, this.id), advanceWidth = ref.advance, leftBearing = ref.bearing;
					if (this._font.vmtx) {
						ref1 = getMetrics(this._font.vmtx, this.id), advanceHeight = ref1.advance, topBearing = ref1.bearing
					} else {
						if (cbox == null) {
							cbox = this.cbox
						}
						if ((os2 = this._font["OS/2"]) && os2.version > 0) {
							advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
							topBearing = os2.typoAscender - cbox.maxY
						} else {
							hhea = this._font.hhea;
							advanceHeight = Math.abs(hhea.ascent - hhea.descent);
							topBearing = hhea.ascent - cbox.maxY
						}
					}
					return this._metrics = {
						advanceWidth: advanceWidth,
						advanceHeight: advanceHeight,
						leftBearing: leftBearing,
						topBearing: topBearing
					}
				};
				get("cbox", function() {
					return this._cbox != null ? this._cbox : this._cbox = this._getCBox()
				});
				get("bbox", function() {
					return this._bbox != null ? this._bbox : this._bbox = this._getBBox()
				});
				get("path", function() {
					return this._path != null ? this._path : this._path = this._getPath()
				});
				get("advanceWidth", function() {
					return this._advanceWidth != null ? this._advanceWidth : this._advanceWidth = this._getMetrics().advanceWidth
				});
				get("advanceHeight", function() {
					return this._advanceHeight != null ? this._advanceHeight : this._advanceHeight = this._getMetrics().advanceHeight
				});
				get("ligatureCaretPositions", function() {});
				Glyph.prototype._getName = function() {
					var id, post;
					post = this._font.post;
					if (!post) {
						return null
					}
					switch (post.version) {
						case 1:
							return StandardNames[this.id];
						case 2:
							id = post.glyphNameIndex[this.id];
							if (id < StandardNames.length) {
								return StandardNames[id]
							} else {
								return post.names[id - StandardNames.length]
							}
							break;
						case 2.5:
							return StandardNames[this.id + post.offsets[this.id]];
						case 4:
							return String.fromCharCode(post.map[this.id])
					}
				};
				get("name", function() {
					return this._name != null ? this._name : this._name = this._getName()
				});
				Glyph.prototype.render = function(ctx, size) {
					var fn, scale;
					ctx.save();
					scale = 1 / this._font.head.unitsPerEm * size;
					ctx.scale(scale, scale);
					fn = this.path.toFunction();
					fn(ctx);
					ctx.fill();
					return ctx.restore()
				};
				return Glyph
			}();
			module.exports = Glyph
		}).call(this)
	}, {
		"../get": 41,
		"./Path": 47,
		"./StandardNames": 49,
		"unicode-properties": 21
	}],
	46: [function(require, module, exports) {
		(function() {
			var GlyphVariationProcessor;
			GlyphVariationProcessor = function() {
				var DELTAS_ARE_WORDS, DELTAS_ARE_ZERO, DELTA_RUN_COUNT_MASK, EMBEDDED_TUPLE_COORD, INTERMEDIATE_TUPLE, POINTS_ARE_WORDS, POINT_RUN_COUNT_MASK, PRIVATE_POINT_NUMBERS, TUPLES_SHARE_POINT_NUMBERS, TUPLE_COUNT_MASK, TUPLE_INDEX_MASK;

				function GlyphVariationProcessor(font, coords) {
					this.font = font;
					this.normalizedCoords = this.normalizeCoords(coords)
				}
				TUPLES_SHARE_POINT_NUMBERS = 32768;
				TUPLE_COUNT_MASK = 4095;
				EMBEDDED_TUPLE_COORD = 32768;
				INTERMEDIATE_TUPLE = 16384;
				PRIVATE_POINT_NUMBERS = 8192;
				TUPLE_INDEX_MASK = 4095;
				POINTS_ARE_WORDS = 128;
				POINT_RUN_COUNT_MASK = 127;
				DELTAS_ARE_ZERO = 128;
				DELTAS_ARE_WORDS = 64;
				DELTA_RUN_COUNT_MASK = 63;
				GlyphVariationProcessor.prototype.normalizeCoords = function(coords) {
					var axis, i, j, l, len, len1, m, normalized, pair, prev, ref3, ref4, segment;
					normalized = function() {
						var l, len, ref3, results;
						ref3 = this.font.fvar.axis;
						results = [];
						for (i = l = 0, len = ref3.length; l < len; i = ++l) {
							axis = ref3[i];
							if (coords[i] < axis.defaultValue) {
								results.push((coords[i] - axis.defaultValue) / (axis.defaultValue - axis.minValue))
							} else {
								results.push((coords[i] - axis.defaultValue) / (axis.maxValue - axis.defaultValue))
							}
						}
						return results
					}.call(this);
					if (this.font.avar) {
						ref3 = this.font.avar.segment;
						for (i = l = 0, len = ref3.length; l < len; i = ++l) {
							segment = ref3[i];
							ref4 = segment.correspondence;
							for (j = m = 0, len1 = ref4.length; m < len1; j = ++m) {
								pair = ref4[j];
								if (j >= 1 && normalized[i] < pair.fromCoord) {
									prev = segment.correspondence[j - 1];
									normalized[i] = (normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) / (pair.fromCoord - prev.fromCoord) + prev.toCoord;
									break
								}
							}
						}
					}
					return normalized
				};
				GlyphVariationProcessor.prototype.transformPoints = function(gid, glyphPoints) {
					var a, endCoords, factor, gvar, hasDelta, here, i, idx, l, len, len1, m, n, nPoints, offset, offsetToData, origPoints, p, point, points, ref3, sharedPoints, startCoords, stream, tupleCoords, tupleCount, tupleDataSize, tupleIndex, xDeltas, yDeltas;
					if (!(this.font.fvar && this.font.gvar)) {
						return
					}
					gvar = this.font.gvar;
					if (gid >= gvar.glyphCount) {
						return
					}
					offset = gvar.offsets[gid];
					if (offset === gvar.offsets[gid + 1]) {
						return
					}
					stream = this.font.stream;
					stream.pos = offset;
					tupleCount = stream.readUInt16BE();
					offsetToData = offset + stream.readUInt16BE();
					if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {
						here = stream.pos;
						stream.pos = offsetToData;
						sharedPoints = this.decodePoints();
						stream.pos = here
					}
					for (i = l = 0, ref3 = tupleCount & TUPLE_COUNT_MASK; l < ref3; i = l += 1) {
						tupleDataSize = stream.readUInt16BE();
						tupleIndex = stream.readUInt16BE();
						if (tupleIndex & EMBEDDED_TUPLE_COORD) {
							tupleCoords = function() {
								var m, ref4, results;
								results = [];
								for (a = m = 0, ref4 = gvar.axisCount; m < ref4; a = m += 1) {
									results.push(stream.readInt16BE() / 16384)
								}
								return results
							}()
						} else {
							if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {
								throw new Error("Invalid gvar table")
							}
							tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK]
						}
						if (tupleIndex & INTERMEDIATE_TUPLE) {
							startCoords = function() {
								var m, ref4, results;
								results = [];
								for (a = m = 0, ref4 = gvar.axisCount; m < ref4; a = m += 1) {
									results.push(stream.readInt16BE() / 16384)
								}
								return results
							}();
							endCoords = function() {
								var m, ref4, results;
								results = [];
								for (a = m = 0, ref4 = gvar.axisCount; m < ref4; a = m += 1) {
									results.push(stream.readInt16BE() / 16384)
								}
								return results
							}()
						}
						factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
						if (factor === 0) {
							offsetToData += tupleDataSize;
							continue
						}
						here = stream.pos;
						if (tupleIndex & PRIVATE_POINT_NUMBERS) {
							stream.pos = offsetToData;
							points = this.decodePoints()
						} else {
							points = sharedPoints
						}
						nPoints = points.length === 0 ? glyphPoints.length : points.length;
						xDeltas = this.decodeDeltas(nPoints);
						yDeltas = this.decodeDeltas(nPoints);
						if (points.length === 0) {
							for (i = m = 0, len = glyphPoints.length; m < len; i = ++m) {
								point = glyphPoints[i];
								point.x += xDeltas[i] * factor;
								point.y += yDeltas[i] * factor
							}
						} else {
							origPoints = glyphPoints.slice();
							hasDelta = function() {
								var len1, n, results;
								results = [];
								for (n = 0, len1 = glyphPoints.length; n < len1; n++) {
									p = glyphPoints[n];
									results.push(false)
								}
								return results
							}();
							for (i = n = 0, len1 = points.length; n < len1; i = ++n) {
								idx = points[i];
								if (!(idx < glyphPoints.length)) {
									continue
								}
								point = glyphPoints[idx];
								origPoints[idx] = point.copy();
								hasDelta[idx] = true;
								point.x += xDeltas[i] * factor;
								point.y += yDeltas[i] * factor
							}
							this.interpolateMissingDeltas(glyphPoints, origPoints, hasDelta)
						}
						offsetToData += tupleDataSize;
						stream.pos = here
					}
				};
				GlyphVariationProcessor.prototype.decodePoints = function() {
					var count, fn, i, j, l, point, points, ref3, run, runCount, stream;
					stream = this.font.stream;
					count = stream.readUInt8();
					if (count & POINTS_ARE_WORDS) {
						count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8()
					}
					points = new Uint16Array(count);
					i = 0;
					while (i < count) {
						run = stream.readUInt8();
						runCount = (run & POINT_RUN_COUNT_MASK) + 1;
						if (i + runCount > count) {
							throw new Error("Bad point run length")
						}
						fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;
						point = 0;
						for (j = l = 0, ref3 = runCount; l < ref3; j = l += 1) {
							point += fn.call(stream);
							points[i++] = point
						}
					}
					return points
				};
				GlyphVariationProcessor.prototype.decodeDeltas = function(count) {
					var deltas, fn, i, j, l, ref3, run, runCount, stream;
					stream = this.font.stream;
					i = 0;
					deltas = new Int16Array(count);
					while (i < count) {
						run = stream.readUInt8();
						runCount = (run & DELTA_RUN_COUNT_MASK) + 1;
						if (i + runCount > count) {
							throw new Error("Bad delta run length")
						}
						if (run & DELTAS_ARE_ZERO) {
							i += runCount
						} else {
							fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;
							for (j = l = 0, ref3 = runCount; l < ref3; j = l += 1) {
								deltas[i++] = fn.call(stream);
							}
						}
					}
					return deltas
				};
				GlyphVariationProcessor.prototype.tupleFactor = function(tupleIndex, tupleCoords, startCoords, endCoords) {
					var factor, gvar, i, l, normalized, ref3;
					normalized = this.normalizedCoords;
					gvar = this.font.gvar;
					factor = 1;
					for (i = l = 0, ref3 = gvar.axisCount; l < ref3; i = l += 1) {
						if (tupleCoords[i] === 0) {
							continue
						} else if (normalized[i] === 0) {
							return 0
						} else if (normalized[i] < 0 && tupleCoords[i] > 0 || normalized[i] > 0 && tupleCoords[i] < 0) {
							return 0
						} else if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {
							factor *= Math.abs(normalized[i])
						} else if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i]) {
							return 0
						} else if (normalized[i] < tupleCoords[i]) {
							factor = factor * (normalized[i] - startCoords[i]) / (tupleCoords[i] - startCoords[i])
						} else {
							factor = factor * (endCoords[i] - normalized[i]) / (endCoords[i] - tupleCoords[i])
						}
					}
					return factor
				};
				GlyphVariationProcessor.prototype.interpolateMissingDeltas = function(points, inPoints, hasDelta) {
					var curDelta, endPoint, firstDelta, firstPoint, point, pt;
					if (points.length === 0) {
						return
					}
					point = 0;
					while (point < points.length) {
						firstPoint = point;
						endPoint = point;
						pt = points[endPoint];
						while (!pt.endContour) {
							pt = points[++endPoint]
						}
						while (point <= endPoint && !hasDelta[point]) {
							point++
						}
						if (!(point <= endPoint)) {
							continue
						}
						firstDelta = point;
						curDelta = point;
						point++;
						while (point <= endPoint) {
							if (hasDelta[point]) {
								this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
								curDelta = point
							}
							point++
						}
						if (curDelta === firstDelta) {
							this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points)
						} else {
							this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
							if (firstDelta > 0) {
								this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points)
							}
						}
						point = endPoint + 1
					}
				};
				GlyphVariationProcessor.prototype.deltaInterpolate = function(p1, p2, ref1, ref2, inPoints, outPoints) {
					var in1, in2, k, l, len, m, out, out1, out2, p, ref3, ref4, ref5, scale;
					if (p1 > p2) {
						return
					}
					ref3 = ["x", "y"];
					for (l = 0, len = ref3.length; l < len; l++) {
						k = ref3[l];
						if (inPoints[ref1][k] > inPoints[ref2][k]) {
							p = ref1;
							ref1 = ref2;
							ref2 = p
						}
						in1 = inPoints[ref1][k];
						in2 = inPoints[ref2][k];
						out1 = outPoints[ref1][k];
						out2 = outPoints[ref2][k];
						scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
						for (p = m = ref4 = p1, ref5 = p2; m <= ref5; p = m += 1) {
							out = inPoints[p][k];
							if (out <= in1) {
								out += out1 - in1
							} else if (out >= in2) {
								out += out2 - in2
							} else {
								out = out1 + (out - in1) * scale
							}
							outPoints[p][k] = out
						}
					}
				};
				GlyphVariationProcessor.prototype.deltaShift = function(p1, p2, ref, inPoints, outPoints) {
					var deltaX, deltaY, l, p, ref3, ref4;
					deltaX = outPoints[ref].x - inPoints[ref].x;
					deltaY = outPoints[ref].y - inPoints[ref].y;
					if (deltaX === 0 && deltaY === 0) {
						return
					}
					for (p = l = ref3 = p1, ref4 = p2; l <= ref4; p = l += 1) {
						if (!(p !== ref)) {
							continue
						}
						outPoints[p].x += deltaX;
						outPoints[p].y += deltaY
					}
				};
				return GlyphVariationProcessor
			}();
			module.exports = GlyphVariationProcessor
		}).call(this)
	}, {}],
	47: [function(require, module, exports) {
		(function() {
			var BBox, Path, slice = [].slice;
			BBox = require("./BBox");
			Path = function() {
				var SVG_COMMANDS, command, fn, get, j, len, ref;
				get = require("../get")(Path);

				function Path() {
					this.commands = [];
					this._bbox = this._cbox = null
				}
				ref = ["moveTo", "lineTo", "quadraticCurveTo", "bezierCurveTo", "closePath"];
				fn = function(command) {
					return Path.prototype[command] = function() {
						var args;
						args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
						this._bbox = this._cbox = null;
						this.commands.push({
							command: command,
							args: args
						});
						return this
					}
				};
				for (j = 0, len = ref.length; j < len; j++) {
					command = ref[j];
					fn(command)
				}
				Path.prototype.toFunction = function() {
					var c, cmds, k, len1, ref1;
					cmds = [];
					ref1 = this.commands;
					for (k = 0, len1 = ref1.length; k < len1; k++) {
						c = ref1[k];
						cmds.push("  ctx." + c.command + "(" + c.args.join(", ") + ");")
					}
					return new Function("ctx", cmds.join("\n"))
				};
				SVG_COMMANDS = {
					moveTo: "M",
					lineTo: "L",
					quadraticCurveTo: "Q",
					bezierCurveTo: "C",
					closePath: "Z"
				};
				Path.prototype.toSVG = function() {
					var arg, args, c, cmds, k, len1, ref1;
					cmds = [];
					ref1 = this.commands;
					for (k = 0, len1 = ref1.length; k < len1; k++) {
						c = ref1[k];
						args = function() {
							var l, len2, ref2, results;
							ref2 = c.args;
							results = [];
							for (l = 0, len2 = ref2.length; l < len2; l++) {
								arg = ref2[l];
								results.push(Math.round(arg * 100) / 100)
							}
							return results
						}();
						cmds.push("" + SVG_COMMANDS[c.command] + args.join(" "))
					}
					return cmds.join("")
				};
				get("cbox", function() {
					var cbox, i, k, l, len1, len2, ref1, ref2, x;
					if (this._cbox) {
						return this._cbox
					}
					cbox = new BBox;
					ref1 = this.commands;
					for (k = 0, len1 = ref1.length; k < len1; k++) {
						command = ref1[k];
						ref2 = command.args;
						for (i = l = 0, len2 = ref2.length; l < len2; i = l += 2) {
							x = ref2[i];
							cbox.addPoint(x, command.args[i + 1])
						}
					}
					return this._cbox = Object.freeze(cbox)
				});
				get("bbox", function() {
					var a, b, b2ac, bbox, c, cp1x, cp1y, cp2x, cp2y, cx, cy, f, i, k, l, len1, p0, p1, p2, p3, p3x, p3y, qp1x, qp1y, ref1, ref2, ref3, ref4, t, t1, t2, x, y;
					if (this._bbox) {
						return this._bbox
					}
					bbox = new BBox;
					cx = cy = 0;
					f = function(t) {
						return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i]
					};
					ref1 = this.commands;
					for (k = 0, len1 = ref1.length; k < len1; k++) {
						c = ref1[k];
						switch (c.command) {
							case "moveTo":
							case "lineTo":
								ref2 = c.args, x = ref2[0], y = ref2[1];
								bbox.addPoint(x, y);
								cx = x;
								cy = y;
								break;
							case "quadraticCurveTo":
							case "bezierCurveTo":
								if (c.command === "quadraticCurveTo") {
									ref3 = c.args, qp1x = ref3[0], qp1y = ref3[1], p3x = ref3[2], p3y = ref3[3];
									cp1x = cx + 2 / 3 * (qp1x - cx);
									cp1y = cy + 2 / 3 * (qp1y - cy);
									cp2x = p3x + 2 / 3 * (qp1x - p3x);
									cp2y = p3y + 2 / 3 * (qp1y - p3y)
								} else {
									ref4 = c.args, cp1x = ref4[0], cp1y = ref4[1], cp2x = ref4[2], cp2y = ref4[3], p3x = ref4[4], p3y = ref4[5]
								}
								bbox.addPoint(p3x, p3y);
								p0 = [cx, cy];
								p1 = [cp1x, cp1y];
								p2 = [cp2x, cp2y];
								p3 = [p3x, p3y];
								for (i = l = 0; l <= 1; i = ++l) {
									b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
									a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
									c = 3 * p1[i] - 3 * p0[i];
									if (a === 0) {
										if (b === 0) {
											continue
										}
										t = -c / b;
										if (0 < t && t < 1) {
											if (i === 0) {
												bbox.addPoint(f(t), bbox.maxY)
											}
											if (i === 1) {
												bbox.addPoint(bbox.maxX, f(t))
											}
										}
										continue
									}
									b2ac = Math.pow(b, 2) - 4 * c * a;
									if (b2ac < 0) {
										continue
									}
									t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
									if (0 < t1 && t1 < 1) {
										if (i === 0) {
											bbox.addPoint(f(t1), bbox.maxY)
										}
										if (i === 1) {
											bbox.addPoint(bbox.maxX, f(t1))
										}
									}
									t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
									if (0 < t2 && t2 < 1) {
										if (i === 0) {
											bbox.addPoint(f(t2), bbox.maxY)
										}
										if (i === 1) {
											bbox.addPoint(bbox.maxX, f(t2))
										}
									}
								}
								cx = p3x;
								cy = p3y
						}
					}
					return this._bbox = Object.freeze(bbox)
				});
				return Path
			}();
			module.exports = Path
		}).call(this)
	}, {
		"../get": 41,
		"./BBox": 42
	}],
	48: [function(require, module, exports) {
		(function() {
			var SBIXGlyph, TTFGlyph, r, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty;
			TTFGlyph = require("./TTFGlyph");
			r = require("restructure");
			SBIXGlyph = function(superClass) {
				var SBIXImage;
				extend(SBIXGlyph, superClass);

				function SBIXGlyph() {
					return SBIXGlyph.__super__.constructor.apply(this, arguments)
				}
				SBIXImage = new r.Struct({
					originX: r.uint16,
					originY: r.uint16,
					type: new r.String(4),
					data: new r.Buffer(function() {
						return this.parent.buflen - this._currentOffset
					})
				});
				SBIXGlyph.prototype.getImageForSize = function(size) {
					var end, i, len, offsets, ref, start, table;
					ref = this._font.sbix.imageTables;
					for (i = 0, len = ref.length; i < len; i++) {
						table = ref[i];
						if (table.ppem >= size) {
							break
						}
					}
					offsets = table.imageOffsets;
					start = offsets[this.id];
					end = offsets[this.id + 1];
					if (start === end) {
						return null
					}
					this._font.stream.pos = start;
					return SBIXImage.decode(this._font.stream, {
						buflen: end - start
					})
				};
				SBIXGlyph.prototype.render = function(ctx, size) {
					var img, scale;
					img = this.getImageForSize(size);
					if (img != null) {
						scale = size / this._font.unitsPerEm;
						ctx.image(img.data, {
							height: size,
							x: img.originX,
							y: (this.bbox.minY - img.originY) * scale
						})
					}
					if (this._font.sbix.flags.renderOutlines) {
						return SBIXGlyph.__super__.render.apply(this, arguments)
					}
				};
				return SBIXGlyph
			}(TTFGlyph);
			module.exports = SBIXGlyph
		}).call(this)
	}, {
		"./TTFGlyph": 50,
		restructure: 3
	}],
	49: [function(require, module, exports) {
		(function() {
			module.exports = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"]
		}).call(this)
	}, {}],
	50: [function(require, module, exports) {
		(function() {
			var BBox, Glyph, Path, TTFGlyph, r, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty;
			Glyph = require("./Glyph");
			Path = require("./Path");
			BBox = require("./BBox");
			r = require("restructure");
			TTFGlyph = function(superClass) {
				var ARGS_ARE_XY_VALUES, ARG_1_AND_2_ARE_WORDS, Component, GlyfHeader, MORE_COMPONENTS, ON_CURVE, OVERLAP_COMPOUND, Point, REPEAT, ROUND_XY_TO_GRID, SAME_X, SAME_Y, SCALED_COMPONENT_OFFSET, UNSCALED_COMPONENT_OFFSET, USE_MY_METRICS, WE_HAVE_AN_X_AND_Y_SCALE, WE_HAVE_A_SCALE, WE_HAVE_A_TWO_BY_TWO, WE_HAVE_INSTRUCTIONS, X_SHORT_VECTOR, Y_SHORT_VECTOR, parseGlyphCoord;
				extend(TTFGlyph, superClass);

				function TTFGlyph() {
					return TTFGlyph.__super__.constructor.apply(this, arguments)
				}
				GlyfHeader = new r.Struct({
					numberOfContours: r.int16,
					xMin: r.int16,
					yMin: r.int16,
					xMax: r.int16,
					yMax: r.int16
				});
				ON_CURVE = 1 << 0;
				X_SHORT_VECTOR = 1 << 1;
				Y_SHORT_VECTOR = 1 << 2;
				REPEAT = 1 << 3;
				SAME_X = 1 << 4;
				SAME_Y = 1 << 5;
				ARG_1_AND_2_ARE_WORDS = 1 << 0;
				ARGS_ARE_XY_VALUES = 1 << 1;
				ROUND_XY_TO_GRID = 1 << 2;
				WE_HAVE_A_SCALE = 1 << 3;
				MORE_COMPONENTS = 1 << 5;
				WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
				WE_HAVE_A_TWO_BY_TWO = 1 << 7;
				WE_HAVE_INSTRUCTIONS = 1 << 8;
				USE_MY_METRICS = 1 << 9;
				OVERLAP_COMPOUND = 1 << 10;
				SCALED_COMPONENT_OFFSET = 1 << 11;
				UNSCALED_COMPONENT_OFFSET = 1 << 12;
				Point = function() {
					function Point(onCurve, endContour, x, y) {
						this.onCurve = onCurve;
						this.endContour = endContour;
						this.x = x != null ? x : 0;
						this.y = y != null ? y : 0
					}
					Point.prototype.copy = function() {
						return new Point(this.onCurve, this.endContour, this.x, this.y)
					};
					return Point
				}();
				Component = function() {
					function Component(glyphID1, dx1, dy1) {
						this.glyphID = glyphID1;
						this.dx = dx1;
						this.dy = dy1;
						this.pos = 0;
						this.scale = this.xScale = this.yScale = this.scale01 = this.scale10 = null
					}
					return Component
				}();
				TTFGlyph.prototype._getCBox = function(internal) {
					var cbox, glyph, stream;
					if (this._font._variationProcessor && !internal) {
						return this.path.cbox
					}
					stream = this._font._getTableStream("glyf");
					stream.pos += this._font.loca.offsets[this.id];
					glyph = GlyfHeader.decode(stream);
					cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
					return Object.freeze(cbox)
				};
				parseGlyphCoord = function(stream, prev, short, same) {
					var val;
					if (short) {
						val = stream.readUInt8();
						if (!same) {
							val = -val
						}
						val += prev
					} else {
						if (same) {
							val = prev
						} else {
							val = prev + stream.readInt16BE()
						}
					}
					return val
				};
				TTFGlyph.prototype._decode = function() {
					var glyfPos, glyph, nextPos, startPos, stream;
					glyfPos = this._font.loca.offsets[this.id];
					nextPos = this._font.loca.offsets[this.id + 1];
					if (glyfPos === nextPos) {
						return null
					}
					stream = this._font._getTableStream("glyf");
					stream.pos += glyfPos;
					startPos = stream.pos;
					glyph = GlyfHeader.decode(stream);
					if (glyph.numberOfContours > 0) {
						this._decodeSimple(glyph, stream)
					} else if (glyph.numberOfContours < 0) {
						this._decodeComposite(glyph, stream, startPos)
					}
					return glyph
				};
				TTFGlyph.prototype._decodeSimple = function(glyph, stream) {
					var count, endPtsOfContours, flag, flags, i, instructions, j, k, l, len, len1, len2, m, n, numCoords, point, points, px, py, ref;
					glyph.points = [];
					endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);
					instructions = new r.Array(r.uint8, r.uint16).decode(stream);
					flags = [];
					numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
					while (flags.length < numCoords) {
						flag = stream.readUInt8();
						flags.push(flag);
						if (flag & REPEAT) {
							count = stream.readUInt8();
							for (j = k = 0, ref = count; k < ref; j = k += 1) {
								flags.push(flag)
							}
						}
					}
					for (i = l = 0, len = flags.length; l < len; i = ++l) {
						flag = flags[i];
						point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
						glyph.points.push(point)
					}
					px = 0;
					for (i = m = 0, len1 = flags.length; m < len1; i = ++m) {
						flag = flags[i];
						glyph.points[i].x = px = parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X)
					}
					py = 0;
					for (i = n = 0, len2 = flags.length; n < len2; i = ++n) {
						flag = flags[i];
						glyph.points[i].y = py = parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y)
					}
					if (this._font._variationProcessor) {
						points = glyph.points.slice();
						points.push.apply(points, this._getPhantomPoints(glyph));
						this._font._variationProcessor.transformPoints(this.id, points);
						glyph.phantomPoints = points.slice(-4)
					}
				};
				TTFGlyph.prototype._decodeComposite = function(glyph, stream, offset) {
					var component, dx, dy, flags, gPos, glyphID, haveInstructions, i, k, len, point, points;
					if (offset == null) {
						offset = 0
					}
					glyph.components = [];
					haveInstructions = false;
					flags = MORE_COMPONENTS;
					while (flags & MORE_COMPONENTS) {
						flags = stream.readUInt16BE();
						gPos = stream.pos - offset;
						glyphID = stream.readUInt16BE();
						haveInstructions || (haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0);
						if (flags & ARG_1_AND_2_ARE_WORDS) {
							dx = stream.readInt16BE();
							dy = stream.readInt16BE()
						} else {
							dx = stream.readInt8();
							dy = stream.readInt8()
						}
						component = new Component(glyphID, dx, dy);
						component.pos = gPos;
						component.scaleX = component.scaleY = 1;
						component.scale01 = component.scale10 = 0;
						if (flags & WE_HAVE_A_SCALE) {
							component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824
						} else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
							component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
							component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824
						} else if (flags & WE_HAVE_A_TWO_BY_TWO) {
							component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
							component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
							component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
							component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824
						}
						glyph.components.push(component)
					}
					if (this._font._variationProcessor) {
						points = function() {
							var k, len, ref, results;
							ref = glyph.components;
							results = [];
							for (k = 0, len = ref.length; k < len; k++) {
								component = ref[k];
								results.push(new Point(true, true, component.dx, component.dy))
							}
							return results
						}();
						points.push.apply(points, this._getPhantomPoints(glyph));
						this._font._variationProcessor.transformPoints(this.id, points);
						glyph.phantomPoints = points.splice(-4, 4);
						for (i = k = 0, len = points.length; k < len; i = ++k) {
							point = points[i];
							glyph.components[i].dx = point.x;
							glyph.components[i].dy = point.y
						}
					}
					return haveInstructions
				};
				TTFGlyph.prototype._getPhantomPoints = function(glyph) {
					var advanceHeight, advanceWidth, cbox, leftBearing, ref, topBearing;
					cbox = this._getCBox(true);
					if (this._metrics == null) {
						this._metrics = Glyph.prototype._getMetrics.call(this, cbox)
					}
					ref = this._metrics, advanceWidth = ref.advanceWidth, advanceHeight = ref.advanceHeight, leftBearing = ref.leftBearing, topBearing = ref.topBearing;
					return [new Point(false, true, glyph.xMin - leftBearing, 0), new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0), new Point(false, true, 0, glyph.yMax + topBearing), new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)]
				};
				TTFGlyph.prototype._getContours = function() {
					var component, contours, cur, glyph, k, l, len, len1, len2, m, point, points, ref, ref1;
					glyph = this._decode();
					if (!glyph) {
						return []
					}
					if (glyph.numberOfContours < 0) {
						points = [];
						ref = glyph.components;
						for (k = 0, len = ref.length; k < len; k++) {
							component = ref[k];
							glyph = this._font.getGlyph(component.glyphID)._decode();
							ref1 = glyph.points;
							for (l = 0, len1 = ref1.length; l < len1; l++) {
								point = ref1[l];
								points.push(new Point(point.onCurve, point.endContour, point.x + component.dx, point.y + component.dy))
							}
						}
					} else {
						points = glyph.points
					}
					if (glyph.phantomPoints) {
						this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
						this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
						this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
						this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax
					}
					contours = [];
					cur = [];
					for (m = 0, len2 = points.length; m < len2; m++) {
						point = points[m];
						cur.push(point);
						if (point.endContour) {
							contours.push(cur);
							cur = []
						}
					}
					return contours
				};
				TTFGlyph.prototype._getMetrics = function() {
					var cbox;
					if (this._metrics) {
						return this._metrics
					}
					cbox = this._getCBox(true);
					TTFGlyph.__super__._getMetrics.call(this, cbox);
					if (this._font._variationProcessor) {
						if (this._path == null) {
							this._path = this._getPath()
						}
					}
					return this._metrics
				};
				TTFGlyph.prototype._getPath = function() {
					var contour, contours, curvePt, firstPt, j, k, l, lastPt, len, midX, midY, path, prevPt, pt, ref, ref1, start;
					contours = this._getContours();
					path = new Path;
					for (k = 0, len = contours.length; k < len; k++) {
						contour = contours[k];
						firstPt = contour[0];
						lastPt = contour[contour.length - 1];
						start = 0;
						if (firstPt.onCurve) {
							curvePt = null;
							start = 1
						} else {
							if (lastPt.onCurve) {
								firstPt = lastPt
							} else {
								firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2)
							}
							curvePt = firstPt
						}
						path.moveTo(firstPt.x, firstPt.y);
						for (j = l = ref = start, ref1 = contour.length; l < ref1; j = l += 1) {
							pt = contour[j];
							prevPt = j === 0 ? firstPt : contour[j - 1];
							if (prevPt.onCurve && pt.onCurve) {
								path.lineTo(pt.x, pt.y)
							} else if (prevPt.onCurve && !pt.onCurve) {
								curvePt = pt
							} else if (!prevPt.onCurve && !pt.onCurve) {
								midX = (prevPt.x + pt.x) / 2;
								midY = (prevPt.y + pt.y) / 2;
								path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
								curvePt = pt
							} else if (!prevPt.onCurve && pt.onCurve) {
								path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
								curvePt = null
							} else {
								throw new Error("Unknown TTF path state")
							}
						}
						if (firstPt !== lastPt) {
							if (curvePt) {
								path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y)
							} else {
								path.lineTo(firstPt.x, firstPt.y)
							}
						}
					}
					path.closePath();
					return path
				};
				return TTFGlyph
			}(Glyph);
			module.exports = TTFGlyph
		}).call(this)
	}, {
		"./BBox": 42,
		"./Glyph": 45,
		"./Path": 47,
		restructure: 3
	}],
	51: [function(require, module, exports) {
		(function() {
			var BBox, GlyphRun;
			BBox = require("../glyph/BBox");
			GlyphRun = function() {
				var get;
				get = require("../get")(GlyphRun);

				function GlyphRun(glyphs, positions) {
					this.glyphs = glyphs;
					this.positions = positions
				}
				get("advanceWidth", function() {
					var i, len, position, ref, width;
					width = 0;
					ref = this.positions;
					for (i = 0, len = ref.length; i < len; i++) {
						position = ref[i];
						width += position.xAdvance
					}
					return width
				});
				get("advanceHeight", function() {
					var height, i, len, position, ref;
					height = 0;
					ref = this.positions;
					for (i = 0, len = ref.length; i < len; i++) {
						position = ref[i];
						height += position.yAdvance
					}
					return height
				});
				get("bbox", function() {
					var b, bbox, glyph, i, index, len, p, ref, x, y;
					bbox = new BBox;
					x = 0;
					y = 0;
					ref = this.glyphs;
					for (index = i = 0, len = ref.length; i < len; index = ++i) {
						glyph = ref[index];
						p = this.positions[index];
						b = glyph.bbox;
						bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
						bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
						x += p.xAdvance;
						y += p.yAdvance
					}
					return bbox
				});
				return GlyphRun
			}();
			module.exports = GlyphRun
		}).call(this)
	}, {
		"../get": 41,
		"../glyph/BBox": 42
	}],
	52: [function(require, module, exports) {
		(function() {
			var KernProcessor;
			KernProcessor = function() {
				function KernProcessor(font) {
					this.font = font;
					this.kern = this.font.kern
				}
				KernProcessor.prototype.process = function(glyphs, positions) {
					var glyph, glyphIndex, i, left, len, results, right;
					results = [];
					for (glyphIndex = i = 0, len = glyphs.length; i < len; glyphIndex = ++i) {
						glyph = glyphs[glyphIndex];
						if (glyphIndex + 1 >= glyphs.length) {
							break
						}
						left = glyphs[glyphIndex].id;
						right = glyphs[glyphIndex + 1].id;
						results.push(positions[glyphIndex].xAdvance += this.getKerning(left, right))
					}
					return results
				};
				KernProcessor.prototype.getKerning = function(left, right) {
					var i, index, j, leftOffset, len, len1, pair, ref, ref1, res, rightOffset, s, table, val;
					res = 0;
					ref = this.kern.tables;
					for (i = 0, len = ref.length; i < len; i++) {
						table = ref[i];
						if (table.coverage.crossStream) {
							continue
						}
						switch (table.version) {
							case 0:
								if (!table.coverage.horizontal) {
									continue
								}
								break;
							case 1:
								if (table.coverage.vertical || table.coverage.variation) {
									continue
								}
								break;
							default:
								throw new Error("Unsupported kerning table version " + table.version)
						}
						val = 0;
						s = table.subtable;
						switch (table.format) {
							case 0:
								ref1 = s.pairs;
								for (j = 0, len1 = ref1.length; j < len1; j++) {
									pair = ref1[j];
									if (pair.left === left && pair.right === right) {
										val = pair.value;
										break
									}
								}
								break;
							case 2:
								if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {
									leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph]
								} else {
									leftOffset = s.array.off
								}
								if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {
									rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph]
								} else {
									rightOffset = 0
								}
								index = (leftOffset + rightOffset - s.array.off) / 2;
								val = s.array.values.get(index);
								break;
							case 3:
								if (left >= s.glyphCount || right >= s.glyphCount) {
									return 0
								}
								val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
								break;
							default:
								throw new Error("Unsupported kerning sub-table format " + table.format)
						}
						if (table.coverage.override) {
							res = val
						} else {
							res += val
						}
					}
					return res
				};
				return KernProcessor
			}();
			module.exports = KernProcessor
		}).call(this)
	}, {}],
	53: [function(require, module, exports) {
		(function() {
			var AATLayoutEngine, GlyphRun, KernProcessor, LayoutEngine, OTLayoutEngine, Script, UnicodeLayoutEngine, unicode, indexOf = [].indexOf || function(item) {
				for (var i = 0, l = this.length; i < l; i++) {
					if (i in this && this[i] === item) return i
				}
				return -1
			};
			KernProcessor = require("./KernProcessor");
			UnicodeLayoutEngine = require("./UnicodeLayoutEngine");
			GlyphRun = require("./GlyphRun");
			Script = require("./Script");
			unicode = require("unicode-properties");
			AATLayoutEngine = require("../aat/AATLayoutEngine");
			OTLayoutEngine = require("../opentype/OTLayoutEngine");
			LayoutEngine = function() {
				var GlyphPosition;

				function LayoutEngine(font) {
					this.font = font;
					this.engine = this.font.morx ? new AATLayoutEngine(this.font) : this.font.GSUB || this.font.GPOS ? new OTLayoutEngine(this.font) : void 0
				}
				LayoutEngine.prototype.layout = function(string, features, script, language) {
					var codePoints, glyph, glyphs, j, len, positions, ref, ref1;
					if (features == null) {
						features = []
					}
					if (typeof features === "string") {
						script = features;
						language = script;
						features = []
					}
					if (typeof string === "string") {
						if (script == null) {
							script = Script.forString(string)
						}
						glyphs = this.font.glyphsForString(string)
					} else {
						if (script == null) {
							codePoints = [];
							for (j = 0, len = string.length; j < len; j++) {
								glyph = string[j];
								codePoints.push.apply(codePoints, glyph.codePoints)
							}
							script = Script.forCodePoints(codePoints)
						}
						glyphs = string
					}
					if (glyphs.length === 0) {
						return new GlyphRun(glyphs, [])
					}
					if ((ref = this.engine) != null) {
						if (typeof ref.setup === "function") {
							ref.setup(glyphs, features, script, language)
						}
					}
					glyphs = this.substitute(glyphs, features, script, language);
					positions = this.position(glyphs, features, script, language);
					if ((ref1 = this.engine) != null) {
						if (typeof ref1.cleanup === "function") {
							ref1.cleanup()
						}
					}
					return new GlyphRun(glyphs, positions)
				};
				LayoutEngine.prototype.substitute = function(glyphs, features, script, language) {
					var ref;
					if ((ref = this.engine) != null ? ref.substitute : void 0) {
						glyphs = this.engine.substitute(glyphs, features, script, language)
					}
					return glyphs
				};
				GlyphPosition = function() {
					function GlyphPosition(xAdvance, yAdvance, xOffset, yOffset) {
						this.xAdvance = xAdvance != null ? xAdvance : 0;
						this.yAdvance = yAdvance != null ? yAdvance : 0;
						this.xOffset = xOffset != null ? xOffset : 0;
						this.yOffset = yOffset != null ? yOffset : 0
					}
					return GlyphPosition
				}();
				LayoutEngine.prototype.position = function(glyphs, features, script, language) {
					var glyph, i, j, len, positioned, positions, ref;
					positions = [];
					for (i = j = 0, len = glyphs.length; j < len; i = ++j) {
						glyph = glyphs[i];
						positions.push(new GlyphPosition(glyph.advanceWidth))
					}
					positioned = (ref = this.engine) != null ? typeof ref.position === "function" ? ref.position(glyphs, positions, features, script, language) : void 0 : void 0;
					if (!positioned) {
						if (this.unicodeLayoutEngine == null) {
							this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font)
						}
						this.unicodeLayoutEngine.positionGlyphs(glyphs, positions);
						for (var i = 0; i < positions.length; i++) {
							positions[i].xOffset = isFinite(positions[i].xOffset) ? positions[i].xOffset : 0;
							positions[i].yOffset = isFinite(positions[i].yOffset) ? positions[i].yOffset : 0
						}
					}
					if (!(positioned != null ? positioned.kern : void 0) && this.font.kern) {
						if (this.kernProcessor == null) {
							this.kernProcessor = new KernProcessor(this.font)
						}
						this.kernProcessor.process(glyphs, positions)
					}
					return positions
				};
				LayoutEngine.prototype.getAvailableFeatures = function(script, language) {
					var features;
					features = [];
					if (this.engine) {
						features.push.apply(features, this.engine.getAvailableFeatures(script, language))
					}
					if (this.font.kern && indexOf.call(features, "kern") < 0) {
						features.push("kern")
					}
					return features
				};
				return LayoutEngine
			}();
			module.exports = LayoutEngine
		}).call(this)
	}, {
		"../aat/AATLayoutEngine": 28,
		"../opentype/OTLayoutEngine": 60,
		"./GlyphRun": 51,
		"./KernProcessor": 52,
		"./Script": 54,
		"./UnicodeLayoutEngine": 55,
		"unicode-properties": 21
	}],
	54: [function(require, module, exports) {
		(function() {
			var RTL, UNICODE_SCRIPTS, unicode;
			unicode = require("unicode-properties");
			UNICODE_SCRIPTS = {
				Caucasian_Albanian: "aghb",
				Arabic: "arab",
				Imperial_Aramaic: "armi",
				Armenian: "armn",
				Avestan: "avst",
				Balinese: "bali",
				Bamum: "bamu",
				Bassa_Vah: "bass",
				Batak: "batk",
				Bengali: ["bng2", "beng"],
				Bopomofo: "bopo",
				Brahmi: "brah",
				Braille: "brai",
				Buginese: "bugi",
				Buhid: "buhd",
				Chakma: "cakm",
				Canadian_Aboriginal: "cans",
				Carian: "cari",
				Cham: "cham",
				Cherokee: "cher",
				Coptic: "copt",
				Cypriot: "cprt",
				Cyrillic: "cyrl",
				Devanagari: ["dev2", "deva"],
				Deseret: "dsrt",
				Duployan: "dupl",
				Egyptian_Hieroglyphs: "egyp",
				Elbasan: "elba",
				Ethiopic: "ethi",
				Georgian: "geor",
				Glagolitic: "glag",
				Gothic: "goth",
				Grantha: "gran",
				Greek: "grek",
				Gujarati: ["gjr2", "gujr"],
				Gurmukhi: ["gur2", "guru"],
				Hangul: "hang",
				Han: "hani",
				Hanunoo: "hano",
				Hebrew: "hebr",
				Hiragana: "hira",
				Pahawh_Hmong: "hmng",
				Katakana_Or_Hiragana: "hrkt",
				Old_Italic: "ital",
				Javanese: "java",
				Kayah_Li: "kali",
				Katakana: "kana",
				Kharoshthi: "khar",
				Khmer: "khmr",
				Khojki: "khoj",
				Kannada: ["knd2", "knda"],
				Kaithi: "kthi",
				Tai_Tham: "lana",
				Lao: "lao ",
				Latin: "latn",
				Lepcha: "lepc",
				Limbu: "limb",
				Linear_A: "lina",
				Linear_B: "linb",
				Lisu: "lisu",
				Lycian: "lyci",
				Lydian: "lydi",
				Mahajani: "mahj",
				Mandaic: "mand",
				Manichaean: "mani",
				Mende_Kikakui: "mend",
				Meroitic_Cursive: "merc",
				Meroitic_Hieroglyphs: "mero",
				Malayalam: ["mlm2", "mlym"],
				Modi: "modi",
				Mongolian: "mong",
				Mro: "mroo",
				Meetei_Mayek: "mtei",
				Myanmar: ["mym2", "mymr"],
				Old_North_Arabian: "narb",
				Nabataean: "nbat",
				Nko: "nko ",
				Ogham: "ogam",
				Ol_Chiki: "olck",
				Old_Turkic: "orkh",
				Oriya: "orya",
				Osmanya: "osma",
				Palmyrene: "palm",
				Pau_Cin_Hau: "pauc",
				Old_Permic: "perm",
				Phags_Pa: "phag",
				Inscriptional_Pahlavi: "phli",
				Psalter_Pahlavi: "phlp",
				Phoenician: "phnx",
				Miao: "plrd",
				Inscriptional_Parthian: "prti",
				Rejang: "rjng",
				Runic: "runr",
				Samaritan: "samr",
				Old_South_Arabian: "sarb",
				Saurashtra: "saur",
				Shavian: "shaw",
				Sharada: "shrd",
				Siddham: "sidd",
				Khudawadi: "sind",
				Sinhala: "sinh",
				Sora_Sompeng: "sora",
				Sundanese: "sund",
				Syloti_Nagri: "sylo",
				Syriac: "syrc",
				Tagbanwa: "tagb",
				Syloti_Nagri: "takr",
				Tai_Le: "tale",
				New_Tai_Lue: "talu",
				Tamil: "taml",
				Tai_Viet: "tavt",
				Telugu: ["tel2", "telu"],
				Tifinagh: "tfng",
				Tagalog: "tglg",
				Thaana: "thaa",
				Thai: "thai",
				Tibetan: "tibt",
				Tirhuta: "tirh",
				Ugaritic: "ugar",
				Vai: "vai ",
				Warang_Citi: "wara",
				Old_Persian: "xpeo",
				Cuneiform: "xsux",
				Yi: "yi  ",
				Inherited: "zinh",
				Common: "zyyy",
				Unknown: "zzzz"
			};
			exports.fromUnicode = function(script) {
				return UNICODE_SCRIPTS[script]
			};
			exports.forString = function(string) {
				var code, idx, len, next, script;
				len = string.length;
				idx = 0;
				while (idx < len) {
					code = string.charCodeAt(idx++);
					if (55296 <= code && code <= 56319 && idx < len) {
						next = string.charCodeAt(idx);
						if (56320 <= next && next <= 57343) {
							idx++;
							code = ((code & 1023) << 10) + (next & 1023) + 65536
						}
					}
					script = unicode.getScript(code);
					if (script !== "Common" && script !== "Inherited" && script !== "Unknown") {
						return UNICODE_SCRIPTS[script]
					}
				}
				return UNICODE_SCRIPTS.Unknown
			};
			exports.forCodePoints = function(codePoints) {
				var codePoint, i, len1, script;
				for (i = 0, len1 = codePoints.length; i < len1; i++) {
					codePoint = codePoints[i];
					script = unicode.getScript(codePoint);
					if (script !== "Common" && script !== "Inherited" && script !== "Unknown") {
						return UNICODE_SCRIPTS[script]
					}
				}
				return UNICODE_SCRIPTS.Unknown
			};
			RTL = {
				arab: true,
				hebr: true,
				syrc: true,
				thaa: true,
				cprt: true,
				khar: true,
				phnx: true,
				"nko ": true,
				lydi: true,
				avst: true,
				armi: true,
				phli: true,
				prti: true,
				sarb: true,
				orkh: true,
				samr: true,
				mand: true,
				merc: true,
				mero: true,
				mani: true,
				mend: true,
				nbat: true,
				narb: true,
				palm: true,
				phlp: true
			};
			exports.direction = function(script) {
				if (RTL[script]) {
					return "rtl"
				}
				return "ltr"
			}
		}).call(this)
	}, {
		"unicode-properties": 21
	}],
	55: [function(require, module, exports) {
		(function() {
			var UnicodeLayoutEngine, unicode;
			unicode = require("unicode-properties");
			UnicodeLayoutEngine = function() {
				function UnicodeLayoutEngine(font) {
					this.font = font
				}
				UnicodeLayoutEngine.prototype.positionGlyphs = function(glyphs, positions) {
					var clusterEnd, clusterStart, glyph, i, index, len;
					clusterStart = 0;
					clusterEnd = 0;
					for (index = i = 0, len = glyphs.length; i < len; index = ++i) {
						glyph = glyphs[index];
						if (glyph.isMark) {
							clusterEnd = index
						} else {
							if (clusterStart !== clusterEnd) {
								this.positionCluster(glyphs, positions, clusterStart, clusterEnd)
							}
							clusterStart = clusterEnd = index
						}
					}
					if (clusterStart !== clusterEnd) {
						this.positionCluster(glyphs, positions, clusterStart, clusterEnd)
					}
					return positions
				};
				UnicodeLayoutEngine.prototype.positionCluster = function(glyphs, positions, clusterStart, clusterEnd) {
					var base, baseBox, combiningClass, i, index, mark, markBox, position, ref, ref1, xOffset, yGap, yOffset;
					base = glyphs[clusterStart];
					baseBox = base.cbox.copy();
					if (base.codePoints.length > 1) {
						baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length
					}
					xOffset = -positions[clusterStart].xAdvance;
					yOffset = 0;
					yGap = this.font.unitsPerEm / 16;
					for (index = i = ref = clusterStart + 1, ref1 = clusterEnd; i <= ref1; index = i += 1) {
						mark = glyphs[index];
						markBox = mark.cbox;
						position = positions[index];
						combiningClass = this.getCombiningClass(mark.codePoints[0]);
						if (combiningClass !== "Not_Reordered") {
							position.xOffset = position.yOffset = 0;
							switch (combiningClass) {
								case "Double_Above":
								case "Double_Below":
									position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
									break;
								case "Attached_Below_Left":
								case "Below_Left":
								case "Above_Left":
									position.xOffset += baseBox.minX - markBox.minX;
									break;
								case "Attached_Above_Right":
								case "Below_Right":
								case "Above_Right":
									position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
									break;
								default:
									position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX
							}
							switch (combiningClass) {
								case "Double_Below":
								case "Below_Left":
								case "Below":
								case "Below_Right":
								case "Attached_Below_Left":
								case "Attached_Below":
									if (combiningClass !== "Attached_Below_Left" && combiningClass !== "Attached_Below") {
										baseBox.minY += yGap
									}
									position.yOffset = -baseBox.minY - markBox.maxY;
									baseBox.minY += markBox.height;
									break;
								case "Double_Above":
								case "Above_Left":
								case "Above":
								case "Above_Right":
								case "Attached_Above":
								case "Attached_Above_Right":
									if (combiningClass !== "Attached_Above" && combiningClass !== "Attached_Above_Right") {
										baseBox.maxY += yGap
									}
									position.yOffset = baseBox.maxY - markBox.minY;
									baseBox.maxY += markBox.height
							}
							position.xAdvance = position.yAdvance = 0;
							position.xOffset += xOffset;
							position.yOffset += yOffset
						} else {
							xOffset -= position.xAdvance;
							yOffset -= position.yAdvance
						}
					}
				};
				UnicodeLayoutEngine.prototype.getCombiningClass = function(codePoint) {
					var combiningClass;
					combiningClass = unicode.getCombiningClass(codePoint);
					if ((codePoint & ~255) === 3584) {
						if (combiningClass === "Not_Reordered") {
							switch (codePoint) {
								case 3633:
								case 3636:
								case 3637:
								case 3638:
								case 3639:
								case 3655:
								case 3660:
								case 3645:
								case 3662:
									return "Above_Right";
								case 3761:
								case 3764:
								case 3765:
								case 3766:
								case 3767:
								case 3771:
								case 3788:
								case 3789:
									return "Above";
								case 3772:
									return "Below"
							}
						} else if (codePoint === 3642) {
							return "Below_Right"
						}
					}
					switch (combiningClass) {
						case "CCC10":
						case "CCC11":
						case "CCC12":
						case "CCC13":
						case "CCC14":
						case "CCC15":
						case "CCC16":
						case "CCC17":
						case "CCC18":
						case "CCC20":
						case "CCC22":
							return "Below";
						case "CCC23":
							return "Attached_Above";
						case "CCC24":
							return "Above_Right";
						case "CCC25":
						case "CCC19":
							return "Above_Left";
						case "CCC26":
							return "Above";
						case "CCC21":
							break;
						case "CCC27":
						case "CCC28":
						case "CCC30":
						case "CCC31":
						case "CCC33":
						case "CCC34":
						case "CCC35":
						case "CCC36":
							return "Above";
						case "CCC29":
						case "CCC32":
							return "Below";
						case "CCC103":
							return "Below_Right";
						case "CCC107":
							return "Above_Right";
						case "CCC118":
							return "Below";
						case "CCC122":
							return "Above";
						case "CCC129":
						case "CCC132":
							return "Below";
						case "CCC130":
							return "Above"
					}
					return combiningClass
				};
				return UnicodeLayoutEngine
			}();
			module.exports = UnicodeLayoutEngine
		}).call(this)
	}, {
		"unicode-properties": 21
	}],
	56: [function(require, module, exports) {
		(function() {
			var GPOSProcessor, OTProcessor, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty;
			OTProcessor = require("./OTProcessor");
			GPOSProcessor = function(superClass) {
				extend(GPOSProcessor, superClass);

				function GPOSProcessor() {
					return GPOSProcessor.__super__.constructor.apply(this, arguments)
				}
				GPOSProcessor.prototype.applyPositionValue = function(sequenceIndex, value) {
					var position;
					position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
					if (value.xAdvance != null) {
						position.xAdvance += value.xAdvance
					}
					if (value.yAdvance != null) {
						position.yAdvance += value.yAdvance
					}
					if (value.xPlacement != null) {
						position.xOffset += value.xPlacement
					}
					if (value.yPlacement != null) {
						return position.yOffset += value.yPlacement
					}
				};
				GPOSProcessor.prototype.applyLookup = function(lookupType, table) {
					var baseAnchor, baseGlyphIndex, baseIndex, class1, class2, compIndex, cur, curRecord, d, entry, exit, good, index, l, len, ligAttach, ligGlyph, ligIndex, mark1Index, mark2Index, markGlyph, markIndex, markRecord, next, nextGlyph, nextIndex, nextRecord, pair, prev, prevIndex, set;
					switch (lookupType) {
						case 1:
							index = this.coverageIndex(table.coverage);
							if (index === -1) {
								return false
							}
							switch (table.version) {
								case 1:
									this.applyPositionValue(0, table.value);
									break;
								case 2:
									this.applyPositionValue(0, table.values.get(index))
							}
							return true;
						case 2:
							nextGlyph = this.glyphIterator.peek();
							if (!nextGlyph) {
								return false
							}
							index = this.coverageIndex(table.coverage);
							if (index === -1) {
								return false
							}
							switch (table.version) {
								case 1:
									set = table.pairSets.get(index);
									for (l = 0, len = set.length; l < len; l++) {
										pair = set[l];
										if (!(pair.secondGlyph === nextGlyph.id)) {
											continue
										}
										this.applyPositionValue(0, pair.value1);
										this.applyPositionValue(1, pair.value2);
										return true
									}
									return false;
								case 2:
									class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
									class2 = this.getClassID(nextGlyph.id, table.classDef2);
									if (class1 === -1 || class2 === -1) {
										return false
									}
									pair = table.classRecords.get(class1).get(class2);
									this.applyPositionValue(0, pair.value1);
									this.applyPositionValue(1, pair.value2)
							}
							return true;
						case 3:
							nextIndex = this.glyphIterator.peekIndex();
							nextGlyph = this.glyphs[nextIndex];
							if (!nextGlyph) {
								return false
							}
							curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
							if (!(curRecord != null ? curRecord.exitAnchor : void 0)) {
								return false
							}
							nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
							if (!(nextRecord != null ? nextRecord.entryAnchor : void 0)) {
								return false
							}
							entry = this.getAnchor(nextRecord.entryAnchor);
							exit = this.getAnchor(curRecord.exitAnchor);
							cur = this.positions[this.glyphIterator.index];
							next = this.positions[nextIndex];
							switch (this.direction) {
								case "ltr":
									cur.xAdvance = exit.x + cur.xOffset;
									d = entry.x + next.xOffset;
									next.xAdvance -= d;
									next.xOffset -= d;
									break;
								case "rtl":
									d = exit.x + cur.xOffset;
									cur.xAdvance -= d;
									cur.xOffset -= d;
									next.xAdvance = entry.x + next.xOffset
							}
							if (this.glyphIterator.flags.rightToLeft) {
								this.glyphIterator.cur.cursiveAttachment = nextIndex;
								cur.yOffset = entry.y - exit.y
							} else {
								nextGlyph.cursiveAttachment = this.glyphIterator.index;
								cur.yOffset = exit.y - entry.y
							}
							return true;
						case 4:
							markIndex = this.coverageIndex(table.markCoverage);
							if (markIndex === -1) {
								return false
							}
							baseGlyphIndex = this.glyphIterator.index;
							while (--baseGlyphIndex >= 0) {
								if (!this.glyphs[baseGlyphIndex].isMark) {
									break
								}
							}
							if (baseGlyphIndex < 0) {
								return false
							}
							baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
							if (baseIndex === -1) {
								return false
							}
							markRecord = table.markArray[markIndex];
							baseAnchor = table.baseArray[baseIndex][markRecord["class"]];
							this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
							return true;
						case 5:
							markIndex = this.coverageIndex(table.markCoverage);
							if (markIndex === -1) {
								return false
							}
							baseGlyphIndex = this.glyphIterator.index;
							while (--baseGlyphIndex >= 0) {
								if (!this.glyphs[baseGlyphIndex].isMark) {
									break
								}
							}
							if (baseGlyphIndex < 0) {
								return false
							}
							ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
							if (ligIndex === -1) {
								return false
							}
							ligAttach = table.ligatureArray[ligIndex];
							markGlyph = this.glyphIterator.cur;
							ligGlyph = this.glyphs[baseGlyphIndex];
							compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent != null ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
							markRecord = table.markArray[markIndex];
							baseAnchor = ligAttach[compIndex][markRecord["class"]];
							this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
							return true;
						case 6:
							mark1Index = this.coverageIndex(table.mark1Coverage);
							if (mark1Index === -1) {
								return false
							}
							prevIndex = this.glyphIterator.peekIndex(-1);
							prev = this.glyphs[prevIndex];
							if (!(prev != null ? prev.isMark : void 0)) {
								return false
							}
							cur = this.glyphIterator.cur;
							good = false;
							if (cur.ligatureID === prev.ligatureID) {
								if (!cur.ligatureID) {
									good = true
								} else if (cur.ligatureComponent === prev.ligatureComponent) {
									good = true
								}
							} else {
								if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) {
									good = true
								}
							}
							if (!good) {
								return false
							}
							mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
							if (mark2Index === -1) {
								return false
							}
							markRecord = table.mark1Array[mark1Index];
							baseAnchor = table.mark2Array[mark2Index][markRecord["class"]];
							this.applyAnchor(markRecord, baseAnchor, prevIndex);
							return true;
						case 7:
							this.applyContext(table);
							break;
						case 8:
							this.applyChainingContext(table);
							break;
						case 9:
							this.applyLookup(table.lookupType, table.extension);
							break;
						default:
							throw new Error("Unsupported GPOS table: " + lookupType)
					}
					return false
				};
				GPOSProcessor.prototype.applyAnchor = function(markRecord, baseAnchor, baseGlyphIndex) {
					var baseCoords, basePos, markCoords, markPos;
					baseCoords = this.getAnchor(baseAnchor);
					markCoords = this.getAnchor(markRecord.markAnchor);
					basePos = this.positions[baseGlyphIndex];
					markPos = this.positions[this.glyphIterator.index];
					markPos.xOffset = baseCoords.x - markCoords.x;
					markPos.yOffset = baseCoords.y - markCoords.y;
					return this.glyphIterator.cur.markAttachment = baseGlyphIndex
				};
				GPOSProcessor.prototype.getAnchor = function(anchor) {
					return {
						x: anchor.xCoordinate,
						y: anchor.yCoordinate
					}
				};
				GPOSProcessor.prototype.applyFeatures = function() {
					var glyph, i, l, len, ref;
					GPOSProcessor.__super__.applyFeatures.apply(this, arguments);
					ref = this.glyphs;
					for (i = l = 0, len = ref.length; l < len; i = ++l) {
						glyph = ref[i];
						this.fixCursiveAttachment(i)
					}
					return this.fixMarkAttachment(i)
				};
				GPOSProcessor.prototype.fixCursiveAttachment = function(i) {
					var glyph, j;
					glyph = this.glyphs[i];
					if (glyph.cursiveAttachment != null) {
						j = glyph.cursiveAttachment;
						glyph.cursiveAttachment = null;
						this.fixCursiveAttachment(j);
						return this.positions[i].yOffset += this.positions[j].yOffset
					}
				};
				GPOSProcessor.prototype.fixMarkAttachment = function() {
					var glyph, i, j, k, l, len, m, ref, ref1, ref2;
					ref = this.glyphs;
					for (i = l = 0, len = ref.length; l < len; i = ++l) {
						glyph = ref[i];
						if (!(glyph.markAttachment != null)) {
							continue
						}
						j = glyph.markAttachment;
						this.positions[i].xOffset += this.positions[j].xOffset;
						this.positions[i].yOffset += this.positions[j].yOffset;
						if (this.direction === "ltr") {
							for (k = m = ref1 = j, ref2 = i; m < ref2; k = m += 1) {
								this.positions[i].xOffset -= this.positions[k].xAdvance;
								this.positions[i].yOffset -= this.positions[k].yAdvance
							}
						}
					}
				};
				return GPOSProcessor
			}(OTProcessor);
			module.exports = GPOSProcessor
		}).call(this)
	}, {
		"./OTProcessor": 61
	}],
	57: [function(require, module, exports) {
		(function() {
			var GSUBProcessor, GlyphInfo, OTProcessor, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty,
				slice = [].slice;
			OTProcessor = require("./OTProcessor");
			GlyphInfo = require("./GlyphInfo");
			GSUBProcessor = function(superClass) {
				extend(GSUBProcessor, superClass);

				function GSUBProcessor() {
					return GSUBProcessor.__super__.constructor.apply(this, arguments)
				}
				GSUBProcessor.prototype.applyLookup = function(lookupType, table) {
					var USER_INDEX, characters, curComps, curGlyph, g, gid, glyph, i, idx, index, j, k, l, lastLigID, lastNumComps, len, len1, len2, len3, ligature, ligatureComponent, ligatureGlyph, m, matchIndex, matched, n, o, ref, ref1, ref2, ref3, ref4, replacement, sequence;
					switch (lookupType) {
						case 1:
							index = this.coverageIndex(table.coverage);
							if (index === -1) {
								return false
							}
							glyph = this.glyphIterator.cur;
							switch (table.version) {
								case 1:
									glyph.id = glyph.id + table.deltaGlyphID & 65535;
									break;
								case 2:
									glyph.id = table.substitute.get(index)
							}
							return true;
						case 2:
							index = this.coverageIndex(table.coverage);
							if (index !== -1) {
								sequence = table.sequences.get(index);
								this.glyphIterator.cur.id = sequence[0];
								replacement = [];
								ref = sequence.slice(1);
								for (j = 0, len = ref.length; j < len; j++) {
									gid = ref[j];
									g = new GlyphInfo(gid);
									g.features = this.glyphIterator.cur.features;
									replacement.push(g)
								}(ref1 = this.glyphs).splice.apply(ref1, [this.glyphIterator.index + 1, 0].concat(slice.call(replacement)));
								return true
							}
							break;
						case 3:
							index = this.coverageIndex(table.coverage);
							if (index !== -1) {
								USER_INDEX = 0;
								this.glyphIterator.cur.id = table.alternateSet.get(index)[USER_INDEX];
								return true
							}
							break;
						case 4:
							index = this.coverageIndex(table.coverage);
							if (index === -1) {
								return false
							}
							ref2 = table.ligatureSets.get(index);
							for (k = 0, len1 = ref2.length; k < len1; k++) {
								ligature = ref2[k];
								matched = this.sequenceMatchIndices(1, ligature.components);
								if (!matched) {
									continue
								}
								curGlyph = this.glyphIterator.cur;
								characters = slice.call(curGlyph.codePoints);
								for (l = 0, len2 = matched.length; l < len2; l++) {
									index = matched[l];
									characters.push.apply(characters, this.glyphs[index].codePoints)
								}
								ligatureGlyph = new GlyphInfo(ligature.glyph, characters);
								ligatureGlyph.features = curGlyph.features;
								ligatureGlyph.ligatureID = ligatureGlyph.isMark ? 0 : this.ligatureID++;
								lastLigID = curGlyph.ligatureID;
								lastNumComps = curGlyph.codePoints.length;
								curComps = lastNumComps;
								idx = this.glyphIterator.index + 1;
								for (m = 0, len3 = matched.length; m < len3; m++) {
									matchIndex = matched[m];
									if (ligatureGlyph.isMark) {
										idx = matchIndex
									} else {
										while (idx < matchIndex) {
											ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
											this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
											this.glyphs[idx].ligatureComponent = ligatureComponent;
											idx++
										}
									}
									lastLigID = this.glyphs[idx].ligatureID;
									lastNumComps = this.glyphs[idx].codePoints.length;
									curComps += lastNumComps;
									idx++
								}
								if (lastLigID && !ligatureGlyph.isMark) {
									for (i = n = ref3 = idx, ref4 = this.glyphs.length; n < ref4; i = n += 1) {
										if (this.glyphs[i].ligatureID === lastLigID) {
											ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i].ligatureComponent || 1, lastNumComps);
											this.glyphs[i].ligatureComponent = ligatureComponent
										} else {
											break
										}
									}
								}
								for (o = matched.length - 1; o >= 0; o += -1) {
									index = matched[o];
									this.glyphs.splice(index, 1)
								}
								this.glyphs[this.glyphIterator.index] = ligatureGlyph;
								return true
							}
							break;
						case 5:
							this.applyContext(table);
							break;
						case 6:
							this.applyChainingContext(table);
							break;
						case 7:
							this.applyLookup(table.lookupType, table.extension);
							break;
						default:
							throw new Error("GSUB lookupType " + lookupType + " is not supported")
					}
					return false
				};
				return GSUBProcessor
			}(OTProcessor);
			module.exports = GSUBProcessor
		}).call(this)
	}, {
		"./GlyphInfo": 58,
		"./OTProcessor": 61
	}],
	58: [function(require, module, exports) {
		(function() {
			var GlyphInfo, unicode;
			unicode = require("unicode-properties");
			GlyphInfo = function() {
				function GlyphInfo(id, codePoints, features) {
					var feature, i, len;
					this.id = id;
					this.codePoints = codePoints != null ? codePoints : [];
					if (features == null) {
						features = []
					}
					this.isMark = this.codePoints.every(unicode.isMark);
					this.isLigature = this.codePoints.length > 1;
					this.features = {};
					for (i = 0, len = features.length; i < len; i++) {
						feature = features[i];
						this.features[feature] = true
					}
					this.ligatureID = null;
					this.ligatureComponent = null;
					this.cursiveAttachment = null;
					this.markAttachment = null
				}
				return GlyphInfo
			}();
			module.exports = GlyphInfo
		}).call(this)
	}, {
		"unicode-properties": 21
	}],
	59: [function(require, module, exports) {
		(function() {
			var GlyphIterator;
			GlyphIterator = function() {
				var get, move, shouldIgnore;
				get = require("../get")(GlyphIterator);

				function GlyphIterator(glyphs, flags) {
					this.glyphs = glyphs;
					this.reset(flags)
				}
				GlyphIterator.prototype.reset = function(flags1) {
					this.flags = flags1 != null ? flags1 : {};
					return this.index = 0
				};
				get("cur", function() {
					return this.glyphs[this.index] || null
				});
				shouldIgnore = function(glyph, flags) {
					return flags.ignoreMarks && glyph.isMark || flags.ignoreBaseGlyphs && !glyph.isMark || flags.ignoreLigatures && glyph.isLigature
				};
				move = function(dir) {
					var ref, ref1;
					this.index += dir;
					while (0 <= (ref = this.index) && ref < this.glyphs.length && shouldIgnore(this.glyphs[this.index], this.flags)) {
						this.index += dir
					}
					if (!(0 <= (ref1 = this.index) && ref1 < this.glyphs.length)) {
						return null
					}
					return this.glyphs[this.index]
				};
				GlyphIterator.prototype.next = function() {
					return move.call(this, 1)
				};
				GlyphIterator.prototype.prev = function() {
					return move.call(this, -1)
				};
				GlyphIterator.prototype.peek = function(count) {
					var idx, res;
					if (count == null) {
						count = 1
					}
					idx = this.index;
					res = this.increment(count);
					this.index = idx;
					return res
				};
				GlyphIterator.prototype.peekIndex = function(count) {
					var idx, res;
					if (count == null) {
						count = 1
					}
					idx = this.index;
					this.increment(count);
					res = this.index;
					this.index = idx;
					return res
				};
				GlyphIterator.prototype.increment = function(count) {
					var dir;
					if (count == null) {
						count = 1
					}
					dir = count < 0 ? -1 : 1;
					count = Math.abs(count);
					while (count--) {
						move.call(this, dir)
					}
					return this.glyphs[this.index]
				};
				return GlyphIterator
			}();
			module.exports = GlyphIterator
		}).call(this)
	}, {
		"../get": 41
	}],
	60: [function(require, module, exports) {
		(function() {
			var GPOSProcessor, GSUBProcessor, GlyphInfo, OTLayoutEngine, Shapers, ShapingPlan, slice = [].slice;
			ShapingPlan = require("./ShapingPlan");
			Shapers = require("./shapers");
			GlyphInfo = require("./GlyphInfo");
			GSUBProcessor = require("./GSUBProcessor");
			GPOSProcessor = require("./GPOSProcessor");
			OTLayoutEngine = function() {
				function OTLayoutEngine(font) {
					this.font = font;
					if (this.font.GSUB) {
						this.GSUBProcessor = new GSUBProcessor(this.font, this.font.GSUB)
					}
					if (this.font.GPOS) {
						this.GPOSProcessor = new GPOSProcessor(this.font, this.font.GPOS)
					}
					this.glyphInfos = null;
					this.plan = null
				}
				OTLayoutEngine.prototype.setup = function(glyphs, features, script, language) {
					var glyph, i, shaper;
					this.glyphInfos = function() {
						var j, len, results;
						results = [];
						for (i = j = 0, len = glyphs.length; j < len; i = ++j) {
							glyph = glyphs[i];
							results.push(new GlyphInfo(glyph.id, slice.call(glyph.codePoints)))
						}
						return results
					}();
					shaper = Shapers.choose(script);
					this.plan = new ShapingPlan(this.font, script, language);
					return shaper.plan(this.plan, this.glyphInfos, features)
				};
				OTLayoutEngine.prototype.substitute = function(glyphs) {
					var glyphInfo;
					if (this.GSUBProcessor) {
						this.plan.process(this.GSUBProcessor, this.glyphInfos);
						glyphs = function() {
							var j, len, ref, results;
							ref = this.glyphInfos;
							results = [];
							for (j = 0, len = ref.length; j < len; j++) {
								glyphInfo = ref[j];
								results.push(this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints))
							}
							return results
						}.call(this)
					}
					return glyphs
				};
				OTLayoutEngine.prototype.position = function(glyphs, positions) {
					var ref;
					if (this.GPOSProcessor) {
						this.plan.process(this.GPOSProcessor, this.glyphInfos, positions)
					}
					if (this.plan.direction === "rtl") {
						glyphs.reverse();
						positions.reverse()
					}
					return (ref = this.GPOSProcessor) != null ? ref.features : void 0
				};
				OTLayoutEngine.prototype.cleanup = function() {
					this.glyphInfos = null;
					return this.plan = null
				};
				OTLayoutEngine.prototype.getAvailableFeatures = function(script, language) {
					var features;
					features = [];
					if (this.GSUBProcessor) {
						this.GSUBProcessor.selectScript(script, language);
						features.push.apply(features, Object.keys(this.GSUBProcessor.features))
					}
					if (this.GPOSProcessor) {
						this.GPOSProcessor.selectScript(script, language);
						features.push.apply(features, Object.keys(this.GPOSProcessor.features))
					}
					return features
				};
				return OTLayoutEngine
			}();
			module.exports = OTLayoutEngine
		}).call(this)
	}, {
		"./GPOSProcessor": 56,
		"./GSUBProcessor": 57,
		"./GlyphInfo": 58,
		"./ShapingPlan": 62,
		"./shapers": 66
	}],
	61: [function(require, module, exports) {
		(function() {
			var GlyphIterator, OTProcessor, Script, indexOf = [].indexOf || function(item) {
				for (var i = 0, l = this.length; i < l; i++) {
					if (i in this && this[i] === item) return i
				}
				return -1
			};
			GlyphIterator = require("./GlyphIterator");
			Script = require("../layout/Script");
			OTProcessor = function() {
				function OTProcessor(font, table1) {
					this.font = font;
					this.table = table1;
					this.script = null;
					this.scriptTag = null;
					this.language = null;
					this.languageTag = null;
					this.features = {};
					this.lookups = {};
					this.selectScript();
					this.glyphs = [];
					this.positions = [];
					this.ligatureID = 1
				}
				OTProcessor.prototype.findScript = function(script) {
					var entry, j, len, ref;
					if (this.table.scriptList == null) {
						return null
					}
					ref = this.table.scriptList;
					for (j = 0, len = ref.length; j < len; j++) {
						entry = ref[j];
						if (entry.tag === script) {
							return entry
						}
					}
					return null
				};
				OTProcessor.prototype.selectScript = function(script, language) {
					var changed, entry, featureIndex, j, k, l, lang, len, len1, len2, record, ref, ref1, s;
					changed = false;
					if (this.script == null || script !== this.scriptTag) {
						if (script != null) {
							if (Array.isArray(script)) {
								for (j = 0, len = script.length; j < len; j++) {
									s = script[j];
									entry = this.findScript(s);
									if (entry) {
										break
									}
								}
							} else {
								entry = this.findScript(script)
							}
						}
						if (entry == null) {
							entry = this.findScript("DFLT")
						}
						if (entry == null) {
							entry = this.findScript("dflt")
						}
						if (entry == null) {
							entry = this.findScript("latn")
						}
						if (entry == null) {
							return
						}
						this.scriptTag = entry.tag;
						this.script = entry.script;
						this.direction = Script.direction(script);
						this.language = null;
						changed = true
					}
					if (language != null && language !== this.langugeTag) {
						ref = this.script.langSysRecords;
						for (k = 0, len1 = ref.length; k < len1; k++) {
							lang = ref[k];
							if (!(lang.tag === language)) {
								continue
							}
							this.language = lang.langSys;
							this.langugeTag = lang.tag;
							changed = true;
							break
						}
					}
					if (this.language == null) {
						this.language = this.script.defaultLangSys
					}
					if (changed) {
						this.features = {};
						if (this.language != null) {
							ref1 = this.language.featureIndexes;
							for (l = 0, len2 = ref1.length; l < len2; l++) {
								featureIndex = ref1[l];
								record = this.table.featureList[featureIndex];
								this.features[record.tag] = record.feature
							}
						}
					}
				};
				OTProcessor.prototype.lookupsForFeatures = function(userFeatures, exclude) {
					var feature, j, k, len, len1, lookupIndex, lookups, ref, tag;
					if (userFeatures == null) {
						userFeatures = []
					}
					lookups = [];
					for (j = 0, len = userFeatures.length; j < len; j++) {
						tag = userFeatures[j];
						feature = this.features[tag];
						if (!feature) {
							continue
						}
						ref = feature.lookupListIndexes;
						for (k = 0, len1 = ref.length; k < len1; k++) {
							lookupIndex = ref[k];
							if (exclude && indexOf.call(exclude, lookupIndex) >= 0) {
								continue
							}
							lookups.push({
								feature: tag,
								index: lookupIndex,
								lookup: this.table.lookupList.get(lookupIndex)
							})
						}
					}
					lookups.sort(function(a, b) {
						return a.index - b.index
					});
					return lookups
				};
				OTProcessor.prototype.applyFeatures = function(userFeatures, glyphs, advances) {
					var lookups;
					lookups = this.lookupsForFeatures(userFeatures);
					return this.applyLookups(lookups, glyphs, advances)
				};
				OTProcessor.prototype.applyLookups = function(lookups, glyphs1, positions) {
					var feature, j, k, len, len1, lookup, ref, ref1, res, table;
					this.glyphs = glyphs1;
					this.positions = positions;
					this.glyphIterator = new GlyphIterator(this.glyphs);
					for (j = 0, len = lookups.length; j < len; j++) {
						ref = lookups[j], feature = ref.feature, lookup = ref.lookup;
						this.glyphIterator.reset(lookup.flags);
						while (this.glyphIterator.index < this.glyphs.length) {
							if (!(feature in this.glyphIterator.cur.features)) {
								this.glyphIterator.index++;
								continue
							}
							ref1 = lookup.subTables;
							for (k = 0, len1 = ref1.length; k < len1; k++) {
								table = ref1[k];
								res = this.applyLookup(lookup.lookupType, table);
								if (res) {
									break
								}
							}
							this.glyphIterator.index++
						}
					}
				};
				OTProcessor.prototype.applyLookup = function(lookup, table) {
					throw new Error("applyLookup must be implemented by subclasses")
				};
				OTProcessor.prototype.applyLookupList = function(lookupRecords) {
					var glyphIndex, j, k, len, len1, lookup, lookupRecord, ref, table;
					glyphIndex = this.glyphIterator.index;
					for (j = 0, len = lookupRecords.length; j < len; j++) {
						lookupRecord = lookupRecords[j];
						this.glyphIterator.index = glyphIndex + lookupRecord.sequenceIndex;
						lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);
						ref = lookup.subTables;
						for (k = 0, len1 = ref.length; k < len1; k++) {
							table = ref[k];
							this.applyLookup(lookup.lookupType, table)
						}
					}
					this.glyphIterator.index = glyphIndex
				};
				OTProcessor.prototype.coverageIndex = function(coverage, glyph) {
					var i, j, len, range, ref;
					if (glyph == null) {
						glyph = this.glyphIterator.cur.id
					}
					switch (coverage.version) {
						case 1:
							return coverage.glyphs.indexOf(glyph);
						case 2:
							ref = coverage.rangeRecords;
							for (i = j = 0, len = ref.length; j < len; i = ++j) {
								range = ref[i];
								if (range.start <= glyph && glyph <= range.end) {
									return range.startCoverageIndex + glyph - range.start
								}
							}
					}
					return -1
				};
				OTProcessor.prototype.match = function(sequenceIndex, sequence, fn, matched) {
					var glyph, idx, pos;
					pos = this.glyphIterator.index;
					glyph = this.glyphIterator.increment(sequenceIndex);
					idx = 0;
					while (idx < sequence.length && glyph && fn(sequence[idx], glyph.id)) {
						if (matched != null) {
							matched.push(this.glyphIterator.index)
						}
						idx++;
						glyph = this.glyphIterator.next()
					}
					this.glyphIterator.index = pos;
					if (idx < sequence.length) {
						return false
					}
					return matched || true
				};
				OTProcessor.prototype.sequenceMatches = function(sequenceIndex, sequence) {
					return this.match(sequenceIndex, sequence, function(component, glyph) {
						return component === glyph
					})
				};
				OTProcessor.prototype.sequenceMatchIndices = function(sequenceIndex, sequence) {
					return this.match(sequenceIndex, sequence, function(component, glyph) {
						return component === glyph
					}, [])
				};
				OTProcessor.prototype.coverageSequenceMatches = function(sequenceIndex, sequence) {
					return this.match(sequenceIndex, sequence, function(_this) {
						return function(coverage, glyph) {
							return _this.coverageIndex(coverage, glyph) >= 0
						}
					}(this))
				};
				OTProcessor.prototype.getClassID = function(glyph, classDef) {
					var classID, glyphID, j, k, len, len1, range, ref, ref1;
					switch (classDef.version) {
						case 1:
							glyphID = classDef.startGlyph;
							ref = classDef.classValueArray;
							for (j = 0, len = ref.length; j < len; j++) {
								classID = ref[j];
								if (glyph === glyphID++) {
									return classID
								}
							}
							break;
						case 2:
							ref1 = classDef.classRangeRecord;
							for (k = 0, len1 = ref1.length; k < len1; k++) {
								range = ref1[k];
								if (range.start <= glyph && glyph <= range.end) {
									return range["class"]
								}
							}
					}
					return -1
				};
				OTProcessor.prototype.classSequenceMatches = function(sequenceIndex, sequence, classDef) {
					return this.match(sequenceIndex, sequence, function(_this) {
						return function(classID, glyph) {
							return classID === _this.getClassID(glyph, classDef)
						}
					}(this))
				};
				OTProcessor.prototype.applyContext = function(table) {
					var index, j, k, len, len1, rule, set;
					switch (table.version) {
						case 1:
							index = this.coverageIndex(table.coverage);
							if (index === -1) {
								return
							}
							set = table.ruleSets[index];
							for (j = 0, len = set.length; j < len; j++) {
								rule = set[j];
								if (this.sequenceMatches(1, rule.input)) {
									return this.applyLookupList(rule.lookupRecords)
								}
							}
							break;
						case 2:
							if (this.coverageIndex(table.coverage) === -1) {
								return
							}
							index = this.getClassID(this.glyphIterator.cur.id, table.classDef);
							if (index === -1) {
								return
							}
							set = table.classSet[index];
							for (k = 0, len1 = set.length; k < len1; k++) {
								rule = set[k];
								if (this.classSequenceMatches(1, rule.classes, table.classDef)) {
									return this.applyLookupList(rule.lookupRecords)
								}
							}
							break;
						case 3:
							if (this.coverageSequenceMatches(0, table.coverages)) {
								return this.applyLookupList(table.lookupRecords)
							}
					}
				};
				OTProcessor.prototype.applyChainingContext = function(table) {
					var index, j, k, len, len1, rule, rules, set;
					switch (table.version) {
						case 1:
							index = this.coverageIndex(table.coverage);
							if (index === -1) {
								return
							}
							set = table.chainRuleSets[index];
							for (j = 0, len = set.length; j < len; j++) {
								rule = set[j];
								if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {
									return this.applyLookupList(rule.lookupRecords)
								}
							}
							break;
						case 2:
							if (this.coverageIndex(table.coverage) === -1) {
								return
							}
							index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
							if (index === -1) {
								return
							}
							rules = table.chainClassSet[index];
							for (k = 0, len1 = rules.length; k < len1; k++) {
								rule = rules[k];
								if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) {
									return this.applyLookupList(rule.lookupRecords)
								}
							}
							break;
						case 3:
							if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {
								return this.applyLookupList(table.lookupRecords)
							}
					}
				};
				return OTProcessor
			}();
			module.exports = OTProcessor
		}).call(this)
	}, {
		"../layout/Script": 54,
		"./GlyphIterator": 59
	}],
	62: [function(require, module, exports) {
		(function() {
			var Script, ShapingPlan;
			Script = require("../layout/Script");
			ShapingPlan = function() {
				function ShapingPlan(font, script, language) {
					this.font = font;
					this.script = script;
					this.language = language;
					this.direction = Script.direction(this.script);
					this.stages = [];
					this.globalFeatures = {};
					this.allFeatures = {}
				}
				ShapingPlan.prototype._addFeatures = function(features) {
					var feature, i, len, stage;
					stage = this.stages[this.stages.length - 1];
					for (i = 0, len = features.length; i < len; i++) {
						feature = features[i];
						if (!this.allFeatures[feature]) {
							stage.push(feature);
							this.allFeatures[feature] = true
						}
					}
				};
				ShapingPlan.prototype._addGlobal = function(features) {
					var feature, i, len;
					for (i = 0, len = features.length; i < len; i++) {
						feature = features[i];
						this.globalFeatures[feature] = true
					}
				};
				ShapingPlan.prototype.add = function(arg, global) {
					var features;
					if (global == null) {
						global = true
					}
					if (this.stages.length === 0) {
						this.stages.push([])
					}
					if (typeof arg === "string") {
						arg = [arg]
					}
					if (Array.isArray(arg)) {
						this._addFeatures(arg);
						if (global) {
							return this._addGlobal(arg)
						}
					} else if (typeof arg === "object") {
						features = (arg.global || []).concat(arg.local || []);
						this._addFeatures(features);
						if (arg.global) {
							return this._addGlobal(arg.global)
						}
					} else {
						throw new Error("Unsupported argument to ShapingPlan#add")
					}
				};
				ShapingPlan.prototype.addStage = function(arg, global) {
					if (typeof arg === "function") {
						return this.stages.push(arg, [])
					} else {
						this.stages.push([]);
						return this.add(arg, global)
					}
				};
				ShapingPlan.prototype.assignGlobalFeatures = function(glyphs) {
					var feature, glyph, i, len;
					for (i = 0, len = glyphs.length; i < len; i++) {
						glyph = glyphs[i];
						for (feature in this.globalFeatures) {
							glyph.features[feature] = true
						}
					}
				};
				ShapingPlan.prototype.process = function(processor, glyphs, positions) {
					var i, item, len, ref;
					processor.selectScript(this.script, this.language);
					ref = this.stages;
					for (i = 0, len = ref.length; i < len; i++) {
						item = ref[i];
						if (typeof item === "function") {
							item(glyphs, positions)
						} else if (item.length > 0) {
							processor.applyFeatures(item, glyphs, positions)
						}
					}
				};
				return ShapingPlan
			}();
			module.exports = ShapingPlan
		}).call(this)
	}, {
		"../layout/Script": 54
	}],
	63: [function(require, module, exports) {
		(function(Buffer) {
			(function() {
				var ArabicShaper, DefaultShaper, UnicodeTrie, fs, trie, unicode, extend = function(child, parent) {
						for (var key in parent) {
							if (hasProp.call(parent, key)) child[key] = parent[key]
						}

						function ctor() {
							this.constructor = child
						}
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					},
					hasProp = {}.hasOwnProperty;
				DefaultShaper = require("./DefaultShaper");
				unicode = require("unicode-properties");
				UnicodeTrie = require("unicode-trie");
				trie = new UnicodeTrie(Buffer("AAEQAAAAAAAAAE0ge3tDu0DJkOHYxzeTXn8p1E9JTb2rOPHOHMcwIFCaeGeNo9JEDxWhk2ekgDJAcPfv81tzT6Zu2jDlzcED38/+aeMtmey7qT8neqVhbskFV/5aHoMjHMk+Bkd5inU2HGGW+9iSvueBqOfhGcYmhZ3aMYtbzaxePGLbvuOwbdWL5AZFN4nkJs20GcmNqnIfOtRtHrOu99B5u7jTO+ahlO6Wi47i5S9nS6f/vnZzGvPxmPuL2+3YJOQu/umfs6+vf8V9JQgoqlG7NmPlv/+KIE7Q6vj0/KIbxdsmKrbvXdDDY/km/dSJCYfrFoKY4WDmYhCzHMQ06/1ZmXXm/eW7/YcXzvroZ8q/J1z3R95O9/fR9pee6LsGiqChpxsmTSmo58893lW7fvvDjY3+8Rnzb9yp+q75znBn8oP+1J5/xwOO3zky7/6qvxxzpx99f+ynjnfP6xO5673u2O2+nzvbv/GX/721s/6veu5yeOXl++9VDn2sV5k97/zGdc2lyZK/amN3e21988tu69uYqW/3v7u56+TWV/9yM3QDy2JmxzkfNV73RqZ/4pHVp9ebX4vKuP78ysLo6Zu+5hv+/30g5M3p/x31sVdu+l2tPmF28+udY5Nm9fcGr9D7Lvd6n79I8cRZ9e+Pp2b3lLj+Xfita9squddqr++Hlv56vfzCx5+3/33eeG5Kb7Hs9aPyAA==", "base64"));
				ArabicShaper = function(superClass) {
					var FEATURES, FIN2, FIN3, FINA, INIT, ISOL, MED2, MEDI, NONE, STATE_TABLE, ShapingClasses, getShapingClass;
					extend(ArabicShaper, superClass);

					function ArabicShaper() {
						return ArabicShaper.__super__.constructor.apply(this, arguments)
					}
					FEATURES = ["isol", "fina", "fin2", "fin3", "medi", "med2", "init"];
					ArabicShaper.planFeatures = function(plan) {
						var feature, j, len;
						plan.add(["ccmp", "locl"]);
						for (j = 0, len = FEATURES.length; j < len; j++) {
							feature = FEATURES[j];
							plan.addStage(feature, false)
						}
						return plan.addStage("mset")
					};
					ShapingClasses = {
						Non_Joining: 0,
						Left_Joining: 1,
						Right_Joining: 2,
						Dual_Joining: 3,
						Join_Causing: 3,
						ALAPH: 4,
						"DALATH RISH": 5,
						Transparent: 6
					};
					ISOL = "isol";
					FINA = "fina";
					FIN2 = "fin2";
					FIN3 = "fin3";
					MEDI = "medi";
					MED2 = "med2";
					INIT = "init";
					NONE = null;
					STATE_TABLE = [
						[
							[NONE, NONE, 0],
							[NONE, ISOL, 2],
							[NONE, ISOL, 1],
							[NONE, ISOL, 2],
							[NONE, ISOL, 1],
							[NONE, ISOL, 6]
						],
						[
							[NONE, NONE, 0],
							[NONE, ISOL, 2],
							[NONE, ISOL, 1],
							[NONE, ISOL, 2],
							[NONE, FIN2, 5],
							[NONE, ISOL, 6]
						],
						[
							[NONE, NONE, 0],
							[NONE, ISOL, 2],
							[INIT, FINA, 1],
							[INIT, FINA, 3],
							[INIT, FINA, 4],
							[INIT, FINA, 6]
						],
						[
							[NONE, NONE, 0],
							[NONE, ISOL, 2],
							[MEDI, FINA, 1],
							[MEDI, FINA, 3],
							[MEDI, FINA, 4],
							[MEDI, FINA, 6]
						],
						[
							[NONE, NONE, 0],
							[NONE, ISOL, 2],
							[MED2, ISOL, 1],
							[MED2, ISOL, 2],
							[MED2, FIN2, 5],
							[MED2, ISOL, 6]
						],
						[
							[NONE, NONE, 0],
							[NONE, ISOL, 2],
							[ISOL, ISOL, 1],
							[ISOL, ISOL, 2],
							[ISOL, FIN2, 5],
							[ISOL, ISOL, 6]
						],
						[
							[NONE, NONE, 0],
							[NONE, ISOL, 2],
							[NONE, ISOL, 1],
							[NONE, ISOL, 2],
							[NONE, FIN3, 5],
							[NONE, ISOL, 6]
						]
					];
					getShapingClass = function(codePoint) {
						var ref, res;
						res = trie.get(codePoint);
						if (res) {
							return res - 1
						}
						if ((ref = unicode.getCategory(codePoint)) === "Mn" || ref === "Me" || ref === "Cf") {
							return ShapingClasses.Transparent
						}
						return ShapingClasses.Non_Joining
					};
					ArabicShaper.assignFeatures = function(plan, glyphs) {
						var actions, curAction, feature, glyph, i, index, j, k, len, len1, prev, prevAction, ref, state, type;
						ArabicShaper.__super__.constructor.assignFeatures.apply(this, arguments);
						prev = -1;
						state = 0;
						actions = [];
						for (i = j = 0, len = glyphs.length; j < len; i = ++j) {
							glyph = glyphs[i];
							type = getShapingClass(glyph.codePoints[0]);
							if (type === ShapingClasses.Transparent) {
								actions[i] = NONE;
								continue
							}
							ref = STATE_TABLE[state][type], prevAction = ref[0], curAction = ref[1], state = ref[2];
							if (prevAction !== NONE && prev !== -1) {
								actions[prev] = prevAction
							}
							actions[i] = curAction;
							prev = i
						}
						for (index = k = 0, len1 = glyphs.length; k < len1; index = ++k) {
							glyph = glyphs[index];
							if (feature = actions[index]) {
								glyph.features[feature] = true
							}
						}
					};
					return ArabicShaper
				}(DefaultShaper);
				module.exports = ArabicShaper
			}).call(this)
		}).call(this, require("buffer").Buffer)
	}, {
		"./DefaultShaper": 64,
		buffer: 116,
		"unicode-properties": 21,
		"unicode-trie": 22
	}],
	64: [function(require, module, exports) {
		(function() {
			var COMMON_FEATURES, DIRECTIONAL_FEATURES, DefaultShaper, FRACTIONAL_FEATURES, HORIZONTAL_FEATURES, VERTICAL_FEATURES, unicode, slice = [].slice;
			unicode = require("unicode-properties");
			COMMON_FEATURES = ["ccmp", "locl", "rlig", "mark", "mkmk"];
			FRACTIONAL_FEATURES = ["frac", "numr", "dnom"];
			HORIZONTAL_FEATURES = ["calt", "clig", "liga", "rclt", "curs", "kern"];
			VERTICAL_FEATURES = ["vert"];
			DIRECTIONAL_FEATURES = {
				ltr: ["ltra", "ltrm"],
				rtl: ["rtla", "rtlm"]
			};
			DefaultShaper = function() {
				function DefaultShaper() {}
				DefaultShaper.plan = function(plan, glyphs, features) {
					this.planPreprocessing(plan);
					this.planFeatures(plan);
					this.planPostprocessing(plan, features);
					plan.assignGlobalFeatures(glyphs);
					return this.assignFeatures(plan, glyphs)
				};
				DefaultShaper.planPreprocessing = function(plan) {
					return plan.add({
						global: DIRECTIONAL_FEATURES[plan.direction],
						local: FRACTIONAL_FEATURES
					})
				};
				DefaultShaper.planFeatures = function(plan) {};
				DefaultShaper.planPostprocessing = function(plan, userFeatures) {
					return plan.add(slice.call(COMMON_FEATURES).concat(slice.call(HORIZONTAL_FEATURES), slice.call(userFeatures)))
				};
				DefaultShaper.assignFeatures = function(plan, glyphs) {
					var end, glyph, i, start;
					i = 0;
					while (i < glyphs.length) {
						glyph = glyphs[i];
						if (glyph.codePoints[0] === 8260) {
							start = i - 1;
							end = i + 1;
							while (start >= 0 && unicode.isDigit(glyphs[start].codePoints[0])) {
								glyphs[start].features.numr = true;
								glyphs[start].features.frac = true;
								start--
							}
							while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {
								glyphs[end].features.dnom = true;
								glyphs[end].features.frac = true;
								end++
							}
							glyph.features.frac = true;
							i = end - 1
						} else {
							i++
						}
					}
				};
				return DefaultShaper
			}();
			module.exports = DefaultShaper;
		}).call(this)
	}, {
		"unicode-properties": 21
	}],
	65: [function(require, module, exports) {
		(function() {
			var DefaultShaper, GlyphInfo, HangulShaper, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty,
				slice = [].slice;
			DefaultShaper = require("./DefaultShaper");
			GlyphInfo = require("../GlyphInfo");
			HangulShaper = function(superClass) {
				var COMPOSE, DECOMPOSE, DOTTED_CIRCLE, HANGUL_BASE, HANGUL_COUNT, HANGUL_END, INVALID, L, LV, LVT, L_BASE, L_COUNT, L_END, M, NO_ACTION, STATE_TABLE, T, TONE_MARK, T_BASE, T_COUNT, T_END, V, V_BASE, V_COUNT, V_END, X, compose, decompose, getGlyph, getType, insertDottedCircle, isCombiningL, isCombiningT, isCombiningV, isL, isLV, isLVT, isT, isTone, isV, reorderToneMark;
				extend(HangulShaper, superClass);

				function HangulShaper() {
					return HangulShaper.__super__.constructor.apply(this, arguments)
				}
				HANGUL_BASE = 44032;
				HANGUL_END = 55204;
				HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;
				L_BASE = 4352;
				V_BASE = 4449;
				T_BASE = 4519;
				L_COUNT = 19;
				V_COUNT = 21;
				T_COUNT = 28;
				L_END = L_BASE + L_COUNT - 1;
				V_END = V_BASE + V_COUNT - 1;
				T_END = T_BASE + T_COUNT - 1;
				DOTTED_CIRCLE = 9676;
				isL = function(code) {
					return 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388
				};
				isV = function(code) {
					return 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238
				};
				isT = function(code) {
					return 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291
				};
				isTone = function(code) {
					return 12334 <= code && code <= 12335
				};
				isLVT = function(code) {
					return HANGUL_BASE <= code && code <= HANGUL_END
				};
				isLV = function(c) {
					c -= HANGUL_BASE;
					return c < HANGUL_COUNT && c % T_COUNT === 0
				};
				isCombiningL = function(code) {
					return L_BASE <= code && code <= L_END
				};
				isCombiningV = function(code) {
					return V_BASE <= code && code <= V_END
				};
				isCombiningT = function(code) {
					return T_BASE + 1 <= code && code <= T_END
				};
				X = 0;
				L = 1;
				V = 2;
				T = 3;
				LV = 4;
				LVT = 5;
				M = 6;
				getType = function(code) {
					if (isL(code)) {
						return L
					}
					if (isV(code)) {
						return V
					}
					if (isT(code)) {
						return T
					}
					if (isLV(code)) {
						return LV
					}
					if (isLVT(code)) {
						return LVT
					}
					if (isTone(code)) {
						return M
					}
					return X
				};
				NO_ACTION = 0;
				DECOMPOSE = 1;
				COMPOSE = 2;
				TONE_MARK = 4;
				INVALID = 5;
				STATE_TABLE = [
					[
						[NO_ACTION, 0],
						[NO_ACTION, 1],
						[NO_ACTION, 0],
						[NO_ACTION, 0],
						[DECOMPOSE, 2],
						[DECOMPOSE, 3],
						[INVALID, 0]
					],
					[
						[NO_ACTION, 0],
						[NO_ACTION, 1],
						[COMPOSE, 2],
						[NO_ACTION, 0],
						[DECOMPOSE, 2],
						[DECOMPOSE, 3],
						[INVALID, 0]
					],
					[
						[NO_ACTION, 0],
						[NO_ACTION, 1],
						[NO_ACTION, 0],
						[COMPOSE, 3],
						[DECOMPOSE, 2],
						[DECOMPOSE, 3],
						[TONE_MARK, 0]
					],
					[
						[NO_ACTION, 0],
						[NO_ACTION, 1],
						[NO_ACTION, 0],
						[NO_ACTION, 0],
						[DECOMPOSE, 2],
						[DECOMPOSE, 3],
						[TONE_MARK, 0]
					]
				];
				HangulShaper.planFeatures = function(plan) {
					return plan.add(["ljmo", "vjmo", "tjmo"], false)
				};
				HangulShaper.assignFeatures = function(plan, glyphs) {
					var action, code, glyph, i, ref, state, type;
					state = 0;
					i = 0;
					while (i < glyphs.length) {
						glyph = glyphs[i];
						code = glyph.codePoints[0];
						type = getType(code);
						ref = STATE_TABLE[state][type], action = ref[0], state = ref[1];
						switch (action) {
							case DECOMPOSE:
								if (!plan.font.hasGlyphForCodePoint(code)) {
									i = decompose(glyphs, i, plan.font)
								}
								break;
							case COMPOSE:
								i = compose(glyphs, i, plan.font);
								break;
							case TONE_MARK:
								reorderToneMark(glyphs, i, plan.font);
								break;
							case INVALID:
								i = insertDottedCircle(glyphs, i, plan.font)
						}
						i++
					}
				};
				getGlyph = function(font, code, features) {
					return new GlyphInfo(font.glyphForCodePoint(code).id, [code], Object.keys(features))
				};
				decompose = function(glyphs, i, font) {
					var code, glyph, insert, l, ljmo, s, t, tjmo, v, vjmo;
					glyph = glyphs[i];
					code = glyph.codePoints[0];
					s = code - HANGUL_BASE;
					t = T_BASE + s % T_COUNT;
					s = s / T_COUNT | 0;
					l = L_BASE + s / V_COUNT | 0;
					v = V_BASE + s % V_COUNT;
					if (!(font.hasGlyphForCodePoint(l) && font.hasGlyphForCodePoint(v) && (t === T_BASE || font.hasGlyphForCodePoint(t)))) {
						return i
					}
					ljmo = getGlyph(font, l, glyph.features);
					ljmo.features.ljmo = true;
					vjmo = getGlyph(font, v, glyph.features);
					vjmo.features.vjmo = true;
					insert = [ljmo, vjmo];
					if (t > T_BASE) {
						tjmo = getGlyph(font, t, glyph.features);
						tjmo.features.tjmo = true;
						insert.push(tjmo)
					}
					glyphs.splice.apply(glyphs, [i, 1].concat(slice.call(insert)));
					return i + insert.length - 1
				};
				compose = function(glyphs, i, font) {
					var code, del, glyph, l, ljmo, lv, prev, prevType, s, t, tjmo, type, v, vjmo;
					glyph = glyphs[i];
					code = glyphs[i].codePoints[0];
					type = getType(code);
					prev = glyphs[i - 1].codePoints[0];
					prevType = getType(prev);
					if (prevType === LV && type === T) {
						lv = prev;
						tjmo = glyph
					} else {
						if (type === V) {
							ljmo = glyphs[i - 1];
							vjmo = glyph
						} else {
							ljmo = glyphs[i - 2];
							vjmo = glyphs[i - 1];
							tjmo = glyph
						}
						l = ljmo.codePoints[0];
						v = vjmo.codePoints[0];
						if (isCombiningL(l) && isCombiningV(v)) {
							lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT
						}
					}
					t = (tjmo != null ? tjmo.codePoints[0] : void 0) || T_BASE;
					if (lv != null && (t === T_BASE || isCombiningT(t))) {
						s = lv + (t - T_BASE);
						if (font.hasGlyphForCodePoint(s)) {
							del = prevType === V ? 3 : 2;
							glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));
							return i - del + 1
						}
					}
					if (ljmo != null) {
						ljmo.features.ljmo = true
					}
					if (vjmo != null) {
						vjmo.features.vjmo = true
					}
					if (tjmo != null) {
						tjmo.features.tjmo = true
					}
					if (prevType === LV) {
						decompose(glyphs, i - 1, font);
						return i + 1
					}
					return i
				};
				reorderToneMark = function(glyphs, i, font) {
					var code, glyph, len, prev;
					glyph = glyphs[i];
					code = glyphs[i].codePoints[0];
					if (font.glyphForCodePoint(code).advanceWidth === 0) {
						return
					}
					prev = glyphs[i - 1].codePoints[0];
					len = function() {
						switch (getType(prev)) {
							case LV:
							case LVT:
								return 1;
							case V:
								return 2;
							case T:
								return 3
						}
					}();
					glyphs.splice(i, 1);
					return glyphs.splice(i - len, 0, glyph)
				};
				insertDottedCircle = function(glyphs, i, font) {
					var code, dottedCircle, glyph, idx;
					glyph = glyphs[i];
					code = glyphs[i].codePoints[0];
					if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {
						dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features);
						idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;
						glyphs.splice(idx, 0, dottedCircle);
						i++
					}
					return i
				};
				return HangulShaper
			}(DefaultShaper);
			module.exports = HangulShaper
		}).call(this)
	}, {
		"../GlyphInfo": 58,
		"./DefaultShaper": 64
	}],
	66: [function(require, module, exports) {
		(function() {
			var ArabicShaper, DefaultShaper, HangulShaper, SHAPERS;
			DefaultShaper = require("./DefaultShaper");
			ArabicShaper = require("./ArabicShaper");
			HangulShaper = require("./HangulShaper");
			SHAPERS = {
				arab: ArabicShaper,
				mong: ArabicShaper,
				syrc: ArabicShaper,
				"nko ": ArabicShaper,
				phag: ArabicShaper,
				mand: ArabicShaper,
				mani: ArabicShaper,
				phlp: ArabicShaper,
				hang: HangulShaper,
				latn: DefaultShaper,
				DFLT: DefaultShaper
			};
			exports.choose = function(script) {
				var shaper;
				shaper = SHAPERS[script];
				if (shaper) {
					return shaper
				}
				return DefaultShaper
			}
		}).call(this)
	}, {
		"./ArabicShaper": 63,
		"./DefaultShaper": 64,
		"./HangulShaper": 65
	}],
	67: [function(require, module, exports) {
		(function(Buffer) {
			(function() {
				var CFFPrivateDict, CFFSubset, CFFTop, Subset, standardStrings, extend = function(child, parent) {
						for (var key in parent) {
							if (hasProp.call(parent, key)) child[key] = parent[key]
						}

						function ctor() {
							this.constructor = child
						}
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					},
					hasProp = {}.hasOwnProperty;
				Subset = require("./Subset");
				CFFTop = require("../cff/CFFTop");
				CFFPrivateDict = require("../cff/CFFPrivateDict");
				standardStrings = require("../cff/CFFStandardStrings");
				CFFSubset = function(superClass) {
					var shallowCopy;
					extend(CFFSubset, superClass);

					function CFFSubset() {
						CFFSubset.__super__.constructor.apply(this, arguments);
						this.cff = this.font["CFF "];
						if (!this.cff) {
							throw new Error("Not a CFF Font")
						}
					}
					CFFSubset.prototype.subsetCharstrings = function() {
						var gid, glyph, gsubrs, j, len, path, ref, subr;
						this.charstrings = [];
						gsubrs = {};
						ref = this.glyphs;
						for (j = 0, len = ref.length; j < len; j++) {
							gid = ref[j];
							this.charstrings.push(this.cff.getCharString(gid));
							glyph = this.font.getGlyph(gid);
							path = glyph.path;
							for (subr in glyph._usedGsubrs) {
								gsubrs[subr] = true
							}
						}
						return this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs)
					};
					CFFSubset.prototype.subsetSubrs = function(subrs, used) {
						var i, j, len, res, subr;
						res = [];
						for (i = j = 0, len = subrs.length; j < len; i = ++j) {
							subr = subrs[i];
							if (used[i]) {
								this.cff.stream.pos = subr.offset;
								res.push(this.cff.stream.readBuffer(subr.length))
							} else {
								res.push(new Buffer([11]))
							}
						}
						return res
					};
					shallowCopy = function(obj) {
						var key, res, val;
						res = {};
						for (key in obj) {
							val = obj[key];
							res[key] = val
						}
						return res
					};
					CFFSubset.prototype.subsetFontdict = function(topDict) {
						var dict, fd, gid, glyph, i, j, k, len, len1, path, ref, ref1, ref2, subr, used_fds, used_subrs;
						topDict.FDArray = [];
						topDict.FDSelect = {
							version: 0,
							fds: []
						};
						used_fds = {};
						used_subrs = [];
						ref = this.glyphs;
						for (j = 0, len = ref.length; j < len; j++) {
							gid = ref[j];
							fd = this.cff.fdForGlyph(gid);
							if (fd == null) {
								continue
							}
							if (!used_fds[fd]) {
								topDict.FDArray.push(shallowCopy(this.cff.topDict.FDArray[fd]));
								used_subrs.push({})
							}
							used_fds[fd] = true;
							topDict.FDSelect.fds.push(topDict.FDArray.length - 1);
							glyph = this.font.getGlyph(gid);
							path = glyph.path;
							for (subr in glyph._usedSubrs) {
								used_subrs[used_subrs.length - 1][subr] = true
							}
						}
						ref1 = topDict.FDArray;
						for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
							dict = ref1[i];
							delete dict.FontName;
							if ((ref2 = dict.Private) != null ? ref2.Subrs : void 0) {
								dict.Private = shallowCopy(dict.Private);
								dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i])
							}
						}
					};
					CFFSubset.prototype.createCIDFontdict = function(topDict) {
						var gid, glyph, j, len, path, privateDict, ref, subr, used_subrs;
						used_subrs = {};
						ref = this.glyphs;
						for (j = 0, len = ref.length; j < len; j++) {
							gid = ref[j];
							glyph = this.font.getGlyph(gid);
							path = glyph.path;
							for (subr in glyph._usedSubrs) {
								used_subrs[subr] = true
							}
						}
						privateDict = shallowCopy(this.cff.topDict.Private);
						privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
						topDict.FDArray = [{
							Private: privateDict
						}];
						return topDict.FDSelect = {
							version: 3,
							nRanges: 1,
							ranges: [{
								first: 0,
								fd: 0
							}],
							sentinel: this.charstrings.length
						}
					};
					CFFSubset.prototype.addString = function(string) {
						if (!string) {
							return null
						}
						if (this.strings == null) {
							this.strings = []
						}
						this.strings.push(string);
						return standardStrings.length + this.strings.length - 1
					};
					CFFSubset.prototype.encode = function(stream) {
						var charset, j, key, len, ref, top, topDict;
						this.subsetCharstrings();
						charset = {
							version: this.charstrings.length > 255 ? 2 : 1,
							ranges: [{
								first: 1,
								nLeft: this.charstrings.length - 2
							}]
						};
						topDict = shallowCopy(this.cff.topDict);
						topDict.Private = null;
						topDict.charset = charset;
						topDict.Encoding = null;
						topDict.CharStrings = this.charstrings;
						ref = ["version", "Notice", "Copyright", "FullName", "FamilyName", "Weight", "PostScript", "BaseFontName", "FontName"];
						for (j = 0, len = ref.length; j < len; j++) {
							key = ref[j];
							topDict[key] = this.addString(this.cff.string(topDict[key]))
						}
						topDict.ROS = [this.addString("Adobe"), this.addString("Identity"), 0];
						topDict.CIDCount = this.charstrings.length;
						if (this.cff.isCIDFont) {
							this.subsetFontdict(topDict)
						} else {
							this.createCIDFontdict(topDict)
						}
						top = {
							header: this.cff.header,
							nameIndex: [this.cff.postscriptName],
							topDictIndex: [topDict],
							stringIndex: this.strings,
							globalSubrIndex: this.gsubrs
						};
						return CFFTop.encode(stream, top)
					};
					return CFFSubset
				}(Subset);
				module.exports = CFFSubset
			}).call(this)
		}).call(this, require("buffer").Buffer)
	}, {
		"../cff/CFFPrivateDict": 38,
		"../cff/CFFStandardStrings": 39,
		"../cff/CFFTop": 40,
		"./Subset": 68,
		buffer: 116
	}],
	68: [function(require, module, exports) {
		(function(process) {
			(function() {
				var Subset, r;
				r = require("restructure");
				Subset = function() {
					function Subset(font) {
						this.font = font;
						this.glyphs = [];
						this.mapping = {};
						this.includeGlyph(0)
					}
					Subset.prototype.includeGlyph = function(glyph) {
						if (typeof glyph === "object") {
							glyph = glyph.id
						}
						if (this.mapping[glyph] == null) {
							this.glyphs.push(glyph);
							this.mapping[glyph] = this.glyphs.length - 1
						}
						return this.mapping[glyph]
					};
					Subset.prototype.encodeStream = function() {
						var s;
						s = new r.EncodeStream;
						process.nextTick(function(_this) {
							return function() {
								_this.encode(s);
								return s.end()
							}
						}(this));
						return s
					};
					return Subset
				}();
				module.exports = Subset
			}).call(this)
		}).call(this, require("_process"))
	}, {
		_process: 118,
		restructure: 3
	}],
	69: [function(require, module, exports) {
		(function(Buffer) {
			(function() {
				var Directory, Subset, TTFSubset, Tables, cloneDeep, extend = function(child, parent) {
						for (var key in parent) {
							if (hasProp.call(parent, key)) child[key] = parent[key]
						}

						function ctor() {
							this.constructor = child
						}
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					},
					hasProp = {}.hasOwnProperty;
				cloneDeep = require("clone");
				Subset = require("./Subset");
				Directory = require("../tables/directory");
				Tables = require("../tables");
				TTFSubset = function(superClass) {
					extend(TTFSubset, superClass);

					function TTFSubset() {
						return TTFSubset.__super__.constructor.apply(this, arguments)
					}
					TTFSubset.prototype._addGlyph = function(gid) {
						var buffer, component, curOffset, glyf, j, len, nextOffset, ref, stream;
						glyf = this.font.getGlyph(gid)._decode();
						curOffset = this.font.loca.offsets[gid];
						nextOffset = this.font.loca.offsets[gid + 1];
						stream = this.font._getTableStream("glyf");
						stream.pos += curOffset;
						buffer = stream.readBuffer(nextOffset - curOffset);
						if ((glyf != null ? glyf.numberOfContours : void 0) < 0) {
							buffer = new Buffer(buffer);
							ref = glyf.components;
							for (j = 0, len = ref.length; j < len; j++) {
								component = ref[j];
								gid = this.includeGlyph(component.glyphID);
								buffer.writeUInt16BE(gid, component.pos)
							}
						}
						this.glyf.push(buffer);
						this.loca.offsets.push(this.offset);
						if (gid < this.font.hmtx.metrics.length) {
							this.hmtx.metrics.push(this.font.hmtx.metrics.get(gid))
						} else {
							this.hmtx.metrics.push({
								advance: this.font.hmtx.metrics.get(this.font.hmtx.metrics.length - 1).advance,
								bearing: this.font.hmtx.bearings.get(gid - this.font.hmtx.metrics.length)
							})
						}
						this.offset += buffer.length;
						return this.glyf.length - 1
					};
					TTFSubset.prototype.encode = function(stream) {
						var head, hhea, i, maxp;
						this.glyf = [];
						this.offset = 0;
						this.loca = {
							offsets: []
						};
						this.hmtx = {
							metrics: [],
							bearings: []
						};
						i = 0;
						while (i < this.glyphs.length) {
							this._addGlyph(this.glyphs[i++])
						}
						maxp = cloneDeep(this.font.maxp);
						maxp.numGlyphs = this.glyf.length;
						this.loca.offsets.push(this.offset);
						Tables.loca.preEncode.call(this.loca);
						head = cloneDeep(this.font.head);
						head.indexToLocFormat = this.loca.version;
						hhea = cloneDeep(this.font.hhea);
						hhea.numberOfMetrics = this.hmtx.metrics.length;
						return Directory.encode(stream, {
							tables: {
								head: head,
								hhea: hhea,
								loca: this.loca,
								maxp: maxp,
								"cvt ": this.font["cvt "],
								prep: this.font.prep,
								glyf: this.glyf,
								hmtx: this.hmtx,
								fpgm: this.font.fpgm
							}
						})
					};
					return TTFSubset
				}(Subset);
				module.exports = TTFSubset
			}).call(this)
		}).call(this, require("buffer").Buffer)
	}, {
		"../tables": 101,
		"../tables/directory": 90,
		"./Subset": 68,
		buffer: 116,
		clone: 115
	}],
	70: [function(require, module, exports) {
		(function() {
			var Axis, BaseCoord, BaseLangSysRecord, BaseScript, BaseScriptList, BaseScriptRecord, BaseTagList, BaseValues, ClassDef, Coverage, Device, FeatMinMaxRecord, FeatureList, LookupList, MinMax, ScriptList, r, ref;
			r = require("restructure");
			ref = require("./opentype"), ScriptList = ref.ScriptList, FeatureList = ref.FeatureList, LookupList = ref.LookupList, Coverage = ref.Coverage, ClassDef = ref.ClassDef, Device = ref.Device;
			BaseCoord = new r.VersionedStruct(r.uint16, {
				1: {
					coordinate: r.int16
				},
				2: {
					coordinate: r.int16,
					referenceGlyph: r.uint16,
					baseCoordPoint: r.uint16
				},
				3: {
					coordinate: r.int16,
					deviceTable: new r.Pointer(r.uint16, Device)
				}
			});
			BaseValues = new r.Struct({
				defaultIndex: r.uint16,
				baseCoordCount: r.uint16,
				baseCoords: new r.Array(new r.Pointer(r.uint16, BaseCoord), "baseCoordCount")
			});
			FeatMinMaxRecord = new r.Struct({
				tag: new r.String(4),
				minCoord: new r.Pointer(r.uint16, BaseCoord, {
					type: "parent"
				}),
				maxCoord: new r.Pointer(r.uint16, BaseCoord, {
					type: "parent"
				})
			});
			MinMax = new r.Struct({
				minCoord: new r.Pointer(r.uint16, BaseCoord),
				maxCoord: new r.Pointer(r.uint16, BaseCoord),
				featMinMaxCount: r.uint16,
				featMinMaxRecords: new r.Array(FeatMinMaxRecord, "featMinMaxCount")
			});
			BaseLangSysRecord = new r.Struct({
				tag: new r.String(4),
				minMax: new r.Pointer(r.uint16, MinMax, {
					type: "parent"
				})
			});
			BaseScript = new r.Struct({
				baseValues: new r.Pointer(r.uint16, BaseValues),
				defaultMinMax: new r.Pointer(r.uint16, MinMax),
				baseLangSysCount: r.uint16,
				baseLangSysRecords: new r.Array(BaseLangSysRecord, "baseLangSysCount")
			});
			BaseScriptRecord = new r.Struct({
				tag: new r.String(4),
				script: new r.Pointer(r.uint16, BaseScript, {
					type: "parent"
				})
			});
			BaseScriptList = new r.Array(BaseScriptRecord, r.uint16);
			BaseTagList = new r.Array(new r.String(4), r.uint16);
			Axis = new r.Struct({
				baseTagList: new r.Pointer(r.uint16, BaseTagList),
				baseScriptList: new r.Pointer(r.uint16, BaseScriptList)
			});
			module.exports = new r.Struct({
				version: r.uint32,
				horizAxis: new r.Pointer(r.uint16, Axis),
				vertAxis: new r.Pointer(r.uint16, Axis)
			})
		}).call(this)
	}, {
		"./opentype": 109,
		restructure: 3
	}],
	71: [function(require, module, exports) {
		(function() {
			var BaseGlyphRecord, LayerRecord, r;
			r = require("restructure");
			LayerRecord = new r.Struct({
				gid: r.uint16,
				paletteIndex: r.uint16
			});
			BaseGlyphRecord = new r.Struct({
				gid: r.uint16,
				firstLayerIndex: r.uint16,
				numLayers: r.uint16
			});
			module.exports = new r.Struct({
				version: r.uint16,
				numBaseGlyphRecords: r.uint16,
				baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, "numBaseGlyphRecords")),
				layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, "numLayerRecords"), {
					lazy: true
				}),
				numLayerRecords: r.uint16
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	72: [function(require, module, exports) {
		(function() {
			var ColorRecord, r;
			r = require("restructure");
			ColorRecord = new r.Struct({
				blue: r.uint8,
				green: r.uint8,
				red: r.uint8,
				alpha: r.uint8
			});
			module.exports = new r.Struct({
				version: r.uint16,
				numPaletteEntries: r.uint16,
				numPalettes: r.uint16,
				numColorRecords: r.uint16,
				colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, "numColorRecords")),
				colorRecordIndices: new r.Array(r.uint16, "numPalettes")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	73: [function(require, module, exports) {
		(function() {
			var Signature, SignatureBlock, r;
			r = require("restructure");
			Signature = new r.Struct({
				format: r.uint32,
				length: r.uint32,
				offset: r.uint32
			});
			SignatureBlock = new r.Struct({
				reserved: new r.Reserved(r.uint16, 2),
				cbSignature: r.uint32,
				signature: new r.Buffer("cbSignature")
			});
			module.exports = new r.Struct({
				ulVersion: r.uint32,
				usNumSigs: r.uint16,
				usFlag: r.uint16,
				signatures: new r.Array(Signature, "usNumSigs"),
				signatureBlocks: new r.Array(SignatureBlock, "usNumSigs")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	74: [function(require, module, exports) {
		(function() {
			var BigMetrics, BitAligned, ByteAligned, EBDTComponent, SmallMetrics, r;
			r = require("restructure");
			BigMetrics = new r.Struct({
				height: r.uint8,
				width: r.uint8,
				horiBearingX: r.int8,
				horiBearingY: r.int8,
				horiAdvance: r.uint8,
				vertBearingX: r.int8,
				vertBearingY: r.int8,
				vertAdvance: r.uint8
			});
			exports.BigMetrics = BigMetrics;
			SmallMetrics = new r.Struct({
				height: r.uint8,
				width: r.uint8,
				bearingX: r.int8,
				bearingY: r.int8,
				advance: r.uint8
			});
			exports.SmallMetrics = SmallMetrics;
			EBDTComponent = new r.Struct({
				glyph: r.uint16,
				xOffset: r.int8,
				yOffset: r.int8
			});
			ByteAligned = function() {
				function ByteAligned() {}
				return ByteAligned
			}();
			BitAligned = function() {
				function BitAligned() {}
				return BitAligned
			}();
			exports.glyph = new r.VersionedStruct("version", {
				1: {
					metrics: SmallMetrics,
					data: ByteAligned
				},
				2: {
					metrics: SmallMetrics,
					data: BitAligned
				},
				5: {
					data: BitAligned
				},
				6: {
					metrics: BigMetrics,
					data: ByteAligned
				},
				7: {
					metrics: BigMetrics,
					data: BitAligned
				},
				8: {
					metrics: SmallMetrics,
					pad: new r.Reserved(r.uint8),
					numComponents: r.uint16,
					components: new r.Array(EBDTComponent, "numComponents")
				},
				9: {
					metrics: BigMetrics,
					pad: new r.Reserved(r.uint8),
					numComponents: r.uint16,
					components: new r.Array(EBDTComponent, "numComponents")
				},
				17: {
					metrics: SmallMetrics,
					dataLen: r.uint32,
					data: new r.Buffer("dataLen")
				},
				18: {
					metrics: BigMetrics,
					dataLen: r.uint32,
					data: new r.Buffer("dataLen")
				},
				19: {
					dataLen: r.uint32,
					data: new r.Buffer("dataLen")
				}
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	75: [function(require, module, exports) {
		(function() {
			var BitmapSizeTable, CodeOffsetPair, EBDT, IndexSubtable, IndexSubtableArray, SBitLineMetrics, r;
			r = require("restructure");
			EBDT = require("./EBDT");
			SBitLineMetrics = new r.Struct({
				ascender: r.int8,
				descender: r.int8,
				widthMax: r.uint8,
				caretSlopeNumerator: r.int8,
				caretSlopeDenominator: r.int8,
				caretOffset: r.int8,
				minOriginSB: r.int8,
				minAdvanceSB: r.int8,
				maxBeforeBL: r.int8,
				minAfterBL: r.int8,
				pad: new r.Reserved(r.int8, 2)
			});
			CodeOffsetPair = new r.Struct({
				glyphCode: r.uint16,
				offset: r.uint16
			});
			IndexSubtable = new r.VersionedStruct(r.uint16, {
				header: {
					imageFormat: r.uint16,
					imageDataOffset: r.uint32
				},
				1: {
					offsetArray: new r.Array(r.uint32, function() {
						return this.parent.lastGlyphIndex - this.parent.firstGlyphIndex + 1
					})
				},
				2: {
					imageSize: r.uint32,
					bigMetrics: EBDT.BigMetrics
				},
				3: {
					offsetArray: new r.Array(r.uint16, function() {
						return this.parent.lastGlyphIndex - this.parent.firstGlyphIndex + 1
					})
				},
				4: {
					numGlyphs: r.uint32,
					glyphArray: new r.Array(CodeOffsetPair, function() {
						return this.numGlyphs + 1
					})
				},
				5: {
					imageSize: r.uint32,
					bigMetrics: EBDT.BigMetrics,
					numGlyphs: r.uint32,
					glyphCodeArray: new r.Array(r.uint16, "numGlyphs")
				}
			});
			IndexSubtableArray = new r.Struct({
				firstGlyphIndex: r.uint16,
				lastGlyphIndex: r.uint16,
				subtable: new r.Pointer(r.uint32, IndexSubtable)
			});
			BitmapSizeTable = new r.Struct({
				indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), {
					type: "parent"
				}),
				indexTablesSize: r.uint32,
				numberOfIndexSubTables: r.uint32,
				colorRef: r.uint32,
				hori: SBitLineMetrics,
				vert: SBitLineMetrics,
				startGlyphIndex: r.uint16,
				endGlyphIndex: r.uint16,
				ppemX: r.uint8,
				ppemY: r.uint8,
				bitDepth: r.uint8,
				flags: new r.Bitfield(r.uint8, ["horizontal", "vertical"])
			});
			module.exports = new r.Struct({
				version: r.uint32,
				numSizes: r.uint32,
				sizes: new r.Array(BitmapSizeTable, "numSizes")
			})
		}).call(this)
	}, {
		"./EBDT": 74,
		restructure: 3
	}],
	76: [function(require, module, exports) {
		(function() {
			var AttachList, AttachPoint, CaretValue, ClassDef, Coverage, Device, FeatureList, LigCaretList, LigGlyph, LookupList, MarkGlyphSetsDef, ScriptList, r, ref;
			r = require("restructure");
			ref = require("./opentype"), ScriptList = ref.ScriptList, FeatureList = ref.FeatureList, LookupList = ref.LookupList, Coverage = ref.Coverage, ClassDef = ref.ClassDef, Device = ref.Device;
			AttachPoint = new r.Array(r.uint16, r.uint16);
			AttachList = new r.Struct({
				coverage: new r.Pointer(r.uint16, Coverage),
				glyphCount: r.uint16,
				attachPoints: new r.Array(new r.Pointer(r.uint16, AttachPoint), "glyphCount")
			});
			CaretValue = new r.VersionedStruct(r.uint16, {
				1: {
					coordinate: r.int16
				},
				2: {
					caretValuePoint: r.uint16
				},
				3: {
					coordinate: r.int16,
					deviceTable: new r.Pointer(r.uint16, Device)
				}
			});
			LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);
			LigCaretList = new r.Struct({
				coverage: new r.Pointer(r.uint16, Coverage),
				ligGlyphCount: r.uint16,
				ligGlyphs: new r.Array(new r.Pointer(r.uint16, LigGlyph), "ligGlyphCount")
			});
			MarkGlyphSetsDef = new r.Struct({
				markSetTableFormat: r.uint16,
				markSetCount: r.uint16,
				coverage: new r.Array(new r.Pointer(r.uint32, Coverage), "markSetCount")
			});
			module.exports = new r.VersionedStruct(r.uint32, {
				65536: {
					glyphClassDef: new r.Pointer(r.uint16, ClassDef),
					attachList: new r.Pointer(r.uint16, AttachList),
					ligCaretList: new r.Pointer(r.uint16, LigCaretList),
					markAttachClassDef: new r.Pointer(r.uint16, ClassDef)
				},
				65538: {
					glyphClassDef: new r.Pointer(r.uint16, ClassDef),
					attachList: new r.Pointer(r.uint16, AttachList),
					ligCaretList: new r.Pointer(r.uint16, LigCaretList),
					markAttachClassDef: new r.Pointer(r.uint16, ClassDef),
					markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef)
				}
			})
		}).call(this)
	}, {
		"./opentype": 109,
		restructure: 3
	}],
	77: [function(require, module, exports) {
		(function() {
			var Anchor, BaseArray, BaseRecord, ChainingContext, Class2Record, ClassDef, ComponentRecord, Context, Coverage, Device, EntryExitRecord, FeatureList, GPOSLookup, LigatureArray, LigatureAttach, LookupList, MarkArray, MarkRecord, PairSet, PairValueRecord, ScriptList, ValueFormat, ValueRecord, r, ref;
			r = require("restructure");
			ref = require("./opentype"), ScriptList = ref.ScriptList, FeatureList = ref.FeatureList, LookupList = ref.LookupList, Coverage = ref.Coverage, ClassDef = ref.ClassDef, Device = ref.Device, Context = ref.Context, ChainingContext = ref.ChainingContext;
			ValueFormat = new r.Bitfield(r.uint16, ["xPlacement", "yPlacement", "xAdvance", "yAdvance", "xPlaDevice", "yPlaDevice", "xAdvDevice", "yAdvDevice"]);
			ValueRecord = function() {
				var types;

				function ValueRecord(key1) {
					this.key = key1 != null ? key1 : "valueFormat"
				}
				types = {
					xPlacement: r.int16,
					yPlacement: r.int16,
					xAdvance: r.int16,
					yAdvance: r.int16,
					xPlaDevice: new r.Pointer(r.uint16, Device, {
						type: "global",
						relativeTo: "rel"
					}),
					yPlaDevice: new r.Pointer(r.uint16, Device, {
						type: "global",
						relativeTo: "rel"
					}),
					xAdvDevice: new r.Pointer(r.uint16, Device, {
						type: "global",
						relativeTo: "rel"
					}),
					yAdvDevice: new r.Pointer(r.uint16, Device, {
						type: "global",
						relativeTo: "rel"
					})
				};
				ValueRecord.prototype.buildStruct = function(parent) {
					var fields, included, key, ref1, struct, type;
					struct = parent;
					while (!struct[this.key] && struct.parent) {
						struct = struct.parent
					}
					if (!struct[this.key]) {
						return
					}
					fields = {};
					fields.rel = function() {
						return struct._startOffset
					};
					ref1 = struct[this.key];
					for (key in ref1) {
						included = ref1[key];
						if (!included) {
							continue
						}
						type = types[key];
						fields[key] = type
					}
					return new r.Struct(fields)
				};
				ValueRecord.prototype.size = function(val, ctx) {
					return this.buildStruct(ctx).size(val, ctx)
				};
				ValueRecord.prototype.decode = function(stream, parent) {
					var res;
					res = this.buildStruct(parent).decode(stream, parent);
					delete res.rel;
					return res
				};
				return ValueRecord
			}();
			PairValueRecord = new r.Struct({
				secondGlyph: r.uint16,
				value1: new ValueRecord("valueFormat1"),
				value2: new ValueRecord("valueFormat2")
			});
			PairSet = new r.Array(PairValueRecord, r.uint16);
			Class2Record = new r.Struct({
				value1: new ValueRecord("valueFormat1"),
				value2: new ValueRecord("valueFormat2")
			});
			Anchor = new r.VersionedStruct(r.uint16, {
				1: {
					xCoordinate: r.int16,
					yCoordinate: r.int16
				},
				2: {
					xCoordinate: r.int16,
					yCoordinate: r.int16,
					anchorPoint: r.uint16
				},
				3: {
					xCoordinate: r.int16,
					yCoordinate: r.int16,
					xDeviceTable: new r.Pointer(r.uint16, Device),
					yDeviceTable: new r.Pointer(r.uint16, Device)
				}
			});
			EntryExitRecord = new r.Struct({
				entryAnchor: new r.Pointer(r.uint16, Anchor, {
					type: "parent"
				}),
				exitAnchor: new r.Pointer(r.uint16, Anchor, {
					type: "parent"
				})
			});
			MarkRecord = new r.Struct({
				class: r.uint16,
				markAnchor: new r.Pointer(r.uint16, Anchor, {
					type: "parent"
				})
			});
			MarkArray = new r.Array(MarkRecord, r.uint16);
			BaseRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function() {
				return this.parent.classCount
			});
			BaseArray = new r.Array(BaseRecord, r.uint16);
			ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function() {
				return this.parent.parent.classCount
			});
			LigatureAttach = new r.Array(ComponentRecord, r.uint16);
			LigatureArray = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);
			GPOSLookup = new r.VersionedStruct("lookupType", {
				1: new r.VersionedStruct(r.uint16, {
					1: {
						coverage: new r.Pointer(r.uint16, Coverage),
						valueFormat: ValueFormat,
						value: new ValueRecord
					},
					2: {
						coverage: new r.Pointer(r.uint16, Coverage),
						valueFormat: ValueFormat,
						valueCount: r.uint16,
						values: new r.LazyArray(new ValueRecord, "valueCount")
					}
				}),
				2: new r.VersionedStruct(r.uint16, {
					1: {
						coverage: new r.Pointer(r.uint16, Coverage),
						valueFormat1: ValueFormat,
						valueFormat2: ValueFormat,
						pairSetCount: r.uint16,
						pairSets: new r.LazyArray(new r.Pointer(r.uint16, PairSet), "pairSetCount")
					},
					2: {
						coverage: new r.Pointer(r.uint16, Coverage),
						valueFormat1: ValueFormat,
						valueFormat2: ValueFormat,
						classDef1: new r.Pointer(r.uint16, ClassDef),
						classDef2: new r.Pointer(r.uint16, ClassDef),
						class1Count: r.uint16,
						class2Count: r.uint16,
						classRecords: new r.LazyArray(new r.LazyArray(Class2Record, "class2Count"), "class1Count")
					}
				}),
				3: {
					format: r.uint16,
					coverage: new r.Pointer(r.uint16, Coverage),
					entryExitCount: r.uint16,
					entryExitRecords: new r.Array(EntryExitRecord, "entryExitCount")
				},
				4: {
					format: r.uint16,
					markCoverage: new r.Pointer(r.uint16, Coverage),
					baseCoverage: new r.Pointer(r.uint16, Coverage),
					classCount: r.uint16,
					markArray: new r.Pointer(r.uint16, MarkArray),
					baseArray: new r.Pointer(r.uint16, BaseArray)
				},
				5: {
					format: r.uint16,
					markCoverage: new r.Pointer(r.uint16, Coverage),
					ligatureCoverage: new r.Pointer(r.uint16, Coverage),
					classCount: r.uint16,
					markArray: new r.Pointer(r.uint16, MarkArray),
					ligatureArray: new r.Pointer(r.uint16, LigatureArray)
				},
				6: {
					format: r.uint16,
					mark1Coverage: new r.Pointer(r.uint16, Coverage),
					mark2Coverage: new r.Pointer(r.uint16, Coverage),
					classCount: r.uint16,
					mark1Array: new r.Pointer(r.uint16, MarkArray),
					mark2Array: new r.Pointer(r.uint16, BaseArray)
				},
				7: Context,
				8: ChainingContext,
				9: {
					posFormat: r.uint16,
					lookupType: r.uint16,
					extension: new r.Pointer(r.uint32, GPOSLookup)
				}
			});
			GPOSLookup.versions[9].extension.type = GPOSLookup;
			module.exports = new r.Struct({
				version: r.int32,
				scriptList: new r.Pointer(r.uint16, ScriptList),
				featureList: new r.Pointer(r.uint16, FeatureList),
				lookupList: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
			});
			module.exports.GPOSLookup = GPOSLookup
		}).call(this)
	}, {
		"./opentype": 109,
		restructure: 3
	}],
	78: [function(require, module, exports) {
		(function() {
			var AlternateSet, ChainingContext, ClassDef, Context, Coverage, Device, FeatureList, GSUBLookup, Ligature, LigatureSet, LookupList, ScriptList, Sequence, r, ref;
			r = require("restructure");
			ref = require("./opentype"), ScriptList = ref.ScriptList, FeatureList = ref.FeatureList, LookupList = ref.LookupList, Coverage = ref.Coverage, ClassDef = ref.ClassDef, Device = ref.Device, Context = ref.Context, ChainingContext = ref.ChainingContext;
			Sequence = AlternateSet = new r.Array(r.uint16, r.uint16);
			Ligature = new r.Struct({
				glyph: r.uint16,
				compCount: r.uint16,
				components: new r.Array(r.uint16, function() {
					return this.compCount - 1
				})
			});
			LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);
			GSUBLookup = new r.VersionedStruct("lookupType", {
				1: new r.VersionedStruct(r.uint16, {
					1: {
						coverage: new r.Pointer(r.uint16, Coverage),
						deltaGlyphID: r.int16
					},
					2: {
						coverage: new r.Pointer(r.uint16, Coverage),
						glyphCount: r.uint16,
						substitute: new r.LazyArray(r.uint16, "glyphCount")
					}
				}),
				2: {
					substFormat: r.uint16,
					coverage: new r.Pointer(r.uint16, Coverage),
					count: r.uint16,
					sequences: new r.LazyArray(new r.Pointer(r.uint16, Sequence), "count")
				},
				3: {
					substFormat: r.uint16,
					coverage: new r.Pointer(r.uint16, Coverage),
					count: r.uint16,
					alternateSet: new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), "count")
				},
				4: {
					substFormat: r.uint16,
					coverage: new r.Pointer(r.uint16, Coverage),
					count: r.uint16,
					ligatureSets: new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), "count")
				},
				5: Context,
				6: ChainingContext,
				7: {
					substFormat: r.uint16,
					lookupType: r.uint16,
					extension: new r.Pointer(r.uint32, GSUBLookup)
				},
				8: {
					substFormat: r.uint16,
					coverage: new r.Pointer(r.uint16, Coverage),
					backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "backtrackGlyphCount"),
					lookaheadGlyphCount: r.uint16,
					lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "lookaheadGlyphCount"),
					glyphCount: r.uint16,
					substitutes: new r.Array(r.uint16, "glyphCount")
				}
			});
			GSUBLookup.versions[7].extension.type = GSUBLookup;
			module.exports = new r.Struct({
				version: r.int32,
				scriptList: new r.Pointer(r.uint16, ScriptList),
				featureList: new r.Pointer(r.uint16, FeatureList),
				lookupList: new r.Pointer(r.uint16, new LookupList(GSUBLookup))
			})
		}).call(this)
	}, {
		"./opentype": 109,
		restructure: 3
	}],
	79: [function(require, module, exports) {
		(function() {
			var ClassDef, Coverage, Device, FeatureList, GPOSLookup, JstfGSUBModList, JstfLangSys, JstfLangSysRecord, JstfPriority, JstfScript, JstfScriptRecord, LookupList, ScriptList, r, ref;
			r = require("restructure");
			ref = require("./opentype"), ScriptList = ref.ScriptList, FeatureList = ref.FeatureList, LookupList = ref.LookupList, Coverage = ref.Coverage, ClassDef = ref.ClassDef, Device = ref.Device;
			GPOSLookup = require("./GPOS").GPOSLookup;
			JstfGSUBModList = new r.Array(r.uint16, r.uint16);
			JstfPriority = new r.Struct({
				shrinkageEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
				shrinkageDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
				shrinkageEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
				shrinkageDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
				shrinkageJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup)),
				extensionEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
				extensionDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
				extensionEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
				extensionDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
				extensionJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
			});
			JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);
			JstfLangSysRecord = new r.Struct({
				tag: new r.String(4),
				jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)
			});
			JstfScript = new r.Struct({
				extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)),
				defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),
				langSysCount: r.uint16,
				langSysRecords: new r.Array(JstfLangSysRecord, "langSysCount")
			});
			JstfScriptRecord = new r.Struct({
				tag: new r.String(4),
				script: new r.Pointer(r.uint16, JstfScript, {
					type: "parent"
				})
			});
			module.exports = new r.Struct({
				version: r.uint32,
				scriptCount: r.uint16,
				scriptList: new r.Array(JstfScriptRecord, "scriptCount")
			})
		}).call(this)
	}, {
		"./GPOS": 77,
		"./opentype": 109,
		restructure: 3
	}],
	80: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				version: r.uint16,
				numGlyphs: r.uint16,
				yPels: new r.Array(r.uint8, "numGlyphs")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	81: [function(require, module, exports) {
		(function() {
			var os2, r;
			r = require("restructure");
			module.exports = new r.VersionedStruct(r.uint16, {
				header: {
					xAvgCharWidth: r.int16,
					usWeightClass: r.uint16,
					usWidthClass: r.uint16,
					fsType: new r.Bitfield(r.uint16, [null, "noEmbedding", "viewOnly", "editable", null, null, null, null, "noSubsetting", "bitmapOnly"]),
					ySubscriptXSize: r.int16,
					ySubscriptYSize: r.int16,
					ySubscriptXOffset: r.int16,
					ySubscriptYOffset: r.int16,
					ySuperscriptXSize: r.int16,
					ySuperscriptYSize: r.int16,
					ySuperscriptXOffset: r.int16,
					ySuperscriptYOffset: r.int16,
					yStrikeoutSize: r.int16,
					yStrikeoutPosition: r.int16,
					sFamilyClass: r.int16,
					panose: new r.Array(r.uint8, 10),
					ulCharRange: new r.Array(r.uint32, 4),
					vendorID: new r.String(4),
					fsSelection: new r.Bitfield(r.uint16, ["italic", "underscore", "negative", "outlined", "strikeout", "bold", "regular", "useTypoMetrics", "wws", "oblique"]),
					usFirstCharIndex: r.uint16,
					usLastCharIndex: r.uint16
				},
				0: {},
				1: {
					typoAscender: r.int16,
					typoDescender: r.int16,
					typoLineGap: r.int16,
					winAscent: r.uint16,
					winDescent: r.uint16,
					codePageRange: new r.Array(r.uint32, 2)
				},
				2: {
					typoAscender: r.int16,
					typoDescender: r.int16,
					typoLineGap: r.int16,
					winAscent: r.uint16,
					winDescent: r.uint16,
					codePageRange: new r.Array(r.uint32, 2),
					xHeight: r.int16,
					capHeight: r.int16,
					defaultChar: r.uint16,
					breakChar: r.uint16,
					maxContent: r.uint16
				},
				5: {
					typoAscender: r.int16,
					typoDescender: r.int16,
					typoLineGap: r.int16,
					winAscent: r.uint16,
					winDescent: r.uint16,
					codePageRange: new r.Array(r.uint32, 2),
					xHeight: r.int16,
					capHeight: r.int16,
					defaultChar: r.uint16,
					breakChar: r.uint16,
					maxContent: r.uint16,
					usLowerOpticalPointSize: r.uint16,
					usUpperOpticalPointSize: r.uint16
				}
			});
			os2 = module.exports.versions;
			os2[3] = os2[4] = os2[2]
		}).call(this)
	}, {
		restructure: 3
	}],
	82: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				version: r.uint16,
				fontNumber: r.uint32,
				pitch: r.uint16,
				xHeight: r.uint16,
				style: r.uint16,
				typeFamily: r.uint16,
				capHeight: r.uint16,
				symbolSet: r.uint16,
				typeface: new r.String(16),
				characterComplement: new r.String(8),
				fileName: new r.String(6),
				strokeWeight: new r.String(1),
				widthType: new r.String(1),
				serifStyle: r.uint8,
				reserved: new r.Reserved(r.uint8)
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	83: [function(require, module, exports) {
		(function() {
			var Ratio, VdmxGroup, r, vTable;
			r = require("restructure");
			Ratio = new r.Struct({
				bCharSet: r.uint8,
				xRatio: r.uint8,
				yStartRatio: r.uint8,
				yEndRatio: r.uint8
			});
			vTable = new r.Struct({
				yPelHeight: r.uint16,
				yMax: r.int16,
				yMin: r.int16
			});
			VdmxGroup = new r.Struct({
				recs: r.uint16,
				startsz: r.uint8,
				endsz: r.uint8,
				entries: new r.Array(vTable, "recs")
			});
			module.exports = new r.Struct({
				version: r.uint16,
				numRecs: r.uint16,
				numRatios: r.uint16,
				ratioRanges: new r.Array(Ratio, "numRatios"),
				offsets: new r.Array(r.uint16, "numRatios"),
				groups: new r.Array(VdmxGroup, "numRecs")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	84: [function(require, module, exports) {
		(function() {
			var VerticalOrigin, r;
			r = require("restructure");
			VerticalOrigin = new r.Struct({
				glyphIndex: r.uint16,
				vertOriginY: r.int16
			});
			module.exports = new r.Struct({
				majorVersion: r.uint16,
				minorVersion: r.uint16,
				defaultVertOriginY: r.int16,
				numVertOriginYMetrics: r.uint16,
				metrics: new r.Array(VerticalOrigin, "numVertOriginYMetrics")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	85: [function(require, module, exports) {
		(function() {
			var LookupTable, UnboundedArray, r, extend = function(child, parent) {
					for (var key in parent) {
						if (hasProp.call(parent, key)) child[key] = parent[key]
					}

					function ctor() {
						this.constructor = child
					}
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				hasProp = {}.hasOwnProperty;
			r = require("restructure");
			UnboundedArray = function(superClass) {
				var UnboundedArrayAccessor;
				extend(UnboundedArray, superClass);

				function UnboundedArray(type) {
					this.type = type;
					this.length = 0
				}
				UnboundedArrayAccessor = function() {
					function UnboundedArrayAccessor(type, stream1, parent1) {
						this.type = type;
						this.stream = stream1;
						this.parent = parent1;
						this.base = this.stream.pos;
						this._items = []
					}
					UnboundedArrayAccessor.prototype.getItem = function(index) {
						var pos;
						if (this._items[index] == null) {
							pos = this.stream.pos;
							this.stream.pos = this.base + this.type.size(null, this.parent) * index;
							this._items[index] = this.type.decode(this.stream, this.parent);
							this.stream.pos = pos
						}
						return this._items[index]
					};
					UnboundedArrayAccessor.prototype.inspect = function() {
						return "[UnboundedArray " + this.type.constructor.name + "]"
					};
					return UnboundedArrayAccessor
				}();
				UnboundedArray.prototype.decode = function(stream, parent) {
					return new UnboundedArrayAccessor(this.type, stream, parent)
				};
				return UnboundedArray
			}(r.Array);
			exports.UnboundedArray = UnboundedArray;
			exports.LookupTable = LookupTable = function(ValueType) {
				var BinarySearchHeader, LookupSegmentArray, LookupSegmentSingle, LookupSingle, Shadow;
				if (ValueType == null) {
					ValueType = r.uint16
				}
				Shadow = function() {
					function Shadow(type) {
						this.type = type
					}
					Shadow.prototype.decode = function(stream, ctx) {
						ctx = ctx.parent.parent;
						return this.type.decode(stream, ctx)
					};
					Shadow.prototype.size = function(val, ctx) {
						ctx = ctx.parent.parent;
						return this.type.size(val, ctx)
					};
					Shadow.prototype.encode = function(stream, val, ctx) {
						ctx = ctx.parent.parent;
						return this.type.encode(stream, val, ctx)
					};
					return Shadow
				}();
				ValueType = new Shadow(ValueType);
				BinarySearchHeader = new r.Struct({
					unitSize: r.uint16,
					nUnits: r.uint16,
					searchRange: r.uint16,
					entrySelector: r.uint16,
					rangeShift: r.uint16
				});
				LookupSegmentSingle = new r.Struct({
					lastGlyph: r.uint16,
					firstGlyph: r.uint16,
					value: ValueType
				});
				LookupSegmentArray = new r.Struct({
					lastGlyph: r.uint16,
					firstGlyph: r.uint16,
					values: new r.Pointer(r.uint16, new r.Array(ValueType, function() {
						return this.lastGlyph - this.firstGlyph + 1
					}), {
						type: "parent"
					})
				});
				LookupSingle = new r.Struct({
					glyph: r.uint16,
					value: ValueType
				});
				return new r.VersionedStruct(r.uint16, {
					0: {
						values: new UnboundedArray(ValueType)
					},
					2: {
						binarySearchHeader: BinarySearchHeader,
						segments: new r.Array(LookupSegmentSingle, function() {
							return this.binarySearchHeader.nUnits
						})
					},
					4: {
						binarySearchHeader: BinarySearchHeader,
						segments: new r.Array(LookupSegmentArray, function() {
							return this.binarySearchHeader.nUnits
						})
					},
					6: {
						binarySearchHeader: BinarySearchHeader,
						segments: new r.Array(LookupSingle, function() {
							return this.binarySearchHeader.nUnits
						})
					},
					8: {
						firstGlyph: r.uint16,
						count: r.uint16,
						values: new r.Array(ValueType, "count")
					}
				})
			};
			exports.StateTable = function(entryData, lookupType) {
				var Entry, StateArray, StateHeader, entry, key, val;
				if (entryData == null) {
					entryData = {}
				}
				if (lookupType == null) {
					lookupType = r.uint16
				}
				entry = {
					newState: r.uint16,
					flags: r.uint16
				};
				for (key in entryData) {
					val = entryData[key];
					entry[key] = val
				}
				Entry = new r.Struct(entry);
				StateArray = new UnboundedArray(new r.Array(r.uint16, function() {
					return this.nClasses
				}));
				StateHeader = new r.Struct({
					nClasses: r.uint32,
					classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),
					stateArray: new r.Pointer(r.uint32, StateArray),
					entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))
				});
				return StateHeader
			};
			exports.StateTable1 = function(entryData, lookupType) {
				var ClassLookupTable, Entry, StateArray, StateHeader1, entry, key, val;
				if (entryData == null) {
					entryData = {}
				}
				if (lookupType == null) {
					lookupType = r.uint16
				}
				ClassLookupTable = new r.Struct({
					version: function() {
						return 8
					},
					firstGlyph: r.uint16,
					values: new r.Array(r.uint8, r.uint16)
				});
				entry = {
					newStateOffset: r.uint16,
					newState: function() {
						return (this.newStateOffset - (this.parent.stateArray.base - this.parent._startOffset)) / this.parent.nClasses
					},
					flags: r.uint16
				};
				for (key in entryData) {
					val = entryData[key];
					entry[key] = val
				}
				Entry = new r.Struct(entry);
				StateArray = new UnboundedArray(new r.Array(r.uint8, function() {
					return this.nClasses
				}));
				StateHeader1 = new r.Struct({
					nClasses: r.uint16,
					classTable: new r.Pointer(r.uint16, ClassLookupTable),
					stateArray: new r.Pointer(r.uint16, StateArray),
					entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))
				});
				return StateHeader1
			}
		}).call(this)
	}, {
		restructure: 3
	}],
	86: [function(require, module, exports) {
		(function() {
			var Correspondence, Segment, r, shortFrac;
			r = require("restructure");
			shortFrac = new r.Fixed(16, "BE", 14);
			Correspondence = new r.Struct({
				fromCoord: shortFrac,
				toCoord: shortFrac
			});
			Segment = new r.Struct({
				pairCount: r.uint16,
				correspondence: new r.Array(Correspondence, "pairCount")
			});
			module.exports = new r.Struct({
				version: r.fixed32,
				axisCount: r.uint32,
				segment: new r.Array(Segment, "axisCount")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	87: [function(require, module, exports) {
		(function() {
			var BslnSubtable, LookupTable, r;
			r = require("restructure");
			LookupTable = require("./aat").LookupTable;
			BslnSubtable = new r.VersionedStruct("format", {
				0: {
					deltas: new r.Array(r.int16, 32)
				},
				1: {
					deltas: new r.Array(r.int16, 32),
					mappingData: new LookupTable(r.uint16)
				},
				2: {
					standardGlyph: r.uint16,
					controlPoints: new r.Array(r.uint16, 32)
				},
				3: {
					standardGlyph: r.uint16,
					controlPoints: new r.Array(r.uint16, 32),
					mappingData: new LookupTable(r.uint16)
				}
			});
			module.exports = new r.Struct({
				version: r.fixed32,
				format: r.uint16,
				defaultBaseline: r.uint16,
				subtable: BslnSubtable
			})
		}).call(this)
	}, {
		"./aat": 85,
		restructure: 3
	}],
	88: [function(require, module, exports) {
		(function() {
			var CmapEntry, CmapGroup, CmapSubtable, DefaultUVS, NonDefaultUVS, SubHeader, UVSMapping, UnicodeValueRange, VarSelectorRecord, r;
			r = require("restructure");
			SubHeader = new r.Struct({
				firstCode: r.uint16,
				entryCount: r.uint16,
				idDelta: r.int16,
				idRangeOffset: r.uint16
			});
			CmapGroup = new r.Struct({
				startCharCode: r.uint32,
				endCharCode: r.uint32,
				glyphID: r.uint32
			});
			UnicodeValueRange = new r.Struct({
				startUnicodeValue: r.uint24,
				additionalCount: r.uint8
			});
			UVSMapping = new r.Struct({
				unicodeValue: r.uint24,
				glyphID: r.uint16
			});
			DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);
			NonDefaultUVS = new r.Array(UVSMapping, r.uint32);
			VarSelectorRecord = new r.Struct({
				varSelector: r.uint24,
				defaultUVS: new r.Pointer(r.uint32, DefaultUVS, {
					type: "parent"
				}),
				nonDefaultUVS: new r.Pointer(r.uint32, NonDefaultUVS, {
					type: "parent"
				})
			});
			CmapSubtable = new r.VersionedStruct(r.uint16, {
				0: {
					length: r.uint16,
					language: r.uint16,
					codeMap: new r.LazyArray(r.uint8, 256)
				},
				2: {
					length: r.uint16,
					language: r.uint16,
					subHeaderKeys: new r.Array(r.uint16, 256),
					subHeaderCount: function() {
						return Math.max.apply(Math, this.subHeaderKeys)
					},
					subHeaders: new r.LazyArray(SubHeader, "subHeaderCount"),
					glyphIndexArray: new r.LazyArray(r.uint16, "subHeaderCount")
				},
				4: {
					length: r.uint16,
					language: r.uint16,
					segCountX2: r.uint16,
					segCount: function() {
						return this.segCountX2 >> 1
					},
					searchRange: r.uint16,
					entrySelector: r.uint16,
					rangeShift: r.uint16,
					endCode: new r.LazyArray(r.uint16, "segCount"),
					reservedPad: new r.Reserved(r.uint16),
					startCode: new r.LazyArray(r.uint16, "segCount"),
					idDelta: new r.LazyArray(r.int16, "segCount"),
					idRangeOffset: new r.LazyArray(r.uint16, "segCount"),
					glyphIndexArray: new r.LazyArray(r.uint16, function() {
						return (this.length - this._currentOffset) / 2
					})
				},
				6: {
					length: r.uint16,
					language: r.uint16,
					firstCode: r.uint16,
					entryCount: r.uint16,
					glyphIndices: new r.LazyArray(r.uint16, "entryCount")
				},
				8: {
					reserved: new r.Reserved(r.uint16),
					length: r.uint32,
					language: r.uint16,
					is32: new r.LazyArray(r.uint8, 8192),
					nGroups: r.uint32,
					groups: new r.LazyArray(CmapGroup, "nGroups")
				},
				10: {
					reserved: new r.Reserved(r.uint16),
					length: r.uint32,
					language: r.uint32,
					firstCode: r.uint32,
					entryCount: r.uint32,
					glyphIndices: new r.LazyArray(r.uint16, "numChars")
				},
				12: {
					reserved: new r.Reserved(r.uint16),
					length: r.uint32,
					language: r.uint32,
					nGroups: r.uint32,
					groups: new r.LazyArray(CmapGroup, "nGroups")
				},
				13: {
					reserved: new r.Reserved(r.uint16),
					length: r.uint32,
					language: r.uint32,
					nGroups: r.uint32,
					groups: new r.LazyArray(CmapGroup, "nGroups")
				},
				14: {
					length: r.uint32,
					numRecords: r.uint32,
					varSelectors: new r.LazyArray(VarSelectorRecord, "numRecords")
				}
			});
			CmapEntry = new r.Struct({
				platformID: r.uint16,
				encodingID: r.uint16,
				table: new r.Pointer(r.uint32, CmapSubtable, {
					type: "parent",
					lazy: true
				})
			});
			module.exports = new r.Struct({
				version: r.uint16,
				numSubtables: r.uint16,
				tables: new r.Array(CmapEntry, "numSubtables")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	89: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				controlValues: new r.Array(r.int16)
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	90: [function(require, module, exports) {
		(function() {
			var Directory, TableEntry, Tables, r;
			r = require("restructure");
			Tables = require("./");
			TableEntry = new r.Struct({
				tag: new r.String(4),
				checkSum: r.uint32,
				offset: new r.Pointer(r.uint32, "void", {
					type: "global"
				}),
				length: r.uint32
			});
			Directory = new r.Struct({
				tag: new r.String(4),
				numTables: r.uint16,
				searchRange: r.uint16,
				entrySelector: r.uint16,
				rangeShift: r.uint16,
				tables: new r.Array(TableEntry, "numTables")
			});
			Directory.process = function() {
				var i, len, ref, table, tables;
				tables = {};
				ref = this.tables;
				for (i = 0, len = ref.length; i < len; i++) {
					table = ref[i];
					tables[table.tag] = table
				}
				return this.tables = tables
			};
			Directory.preEncode = function(stream) {
				var ref, table, tables, tag;
				tables = [];
				ref = this.tables;
				for (tag in ref) {
					table = ref[tag];
					if (table != null) {
						tables.push({
							tag: tag,
							checkSum: 0,
							offset: new r.VoidPointer(Tables[tag], table),
							length: Tables[tag].size(table)
						})
					}
				}
				this.tag = "true";
				this.numTables = tables.length;
				this.tables = tables;
				this.searchRange = Math.floor(Math.log(this.numTables) / Math.LN2) * 16;
				this.entrySelector = Math.floor(this.searchRange / Math.LN2);
				return this.rangeShift = this.numTables * 16 - this.searchRange
			};
			module.exports = Directory
		}).call(this)
	}, {
		"./": 101,
		restructure: 3
	}],
	91: [function(require, module, exports) {
		(function() {
			var FeatureName, Setting, r;
			r = require("restructure");
			Setting = new r.Struct({
				setting: r.uint16,
				nameIndex: r.int16,
				name: function() {
					return this.parent.parent.parent.name.records.fontFeatures.English[this.nameIndex]
				}
			});
			FeatureName = new r.Struct({
				feature: r.uint16,
				nSettings: r.uint16,
				settingTable: new r.Pointer(r.uint32, new r.Array(Setting, "nSettings"), {
					type: "parent"
				}),
				featureFlags: new r.Bitfield(r.uint8, [null, null, null, null, null, null, "hasDefault", "exclusive"]),
				defaultSetting: r.uint8,
				nameIndex: r.int16,
				name: function() {
					return this.parent.parent.name.records.fontFeatures.English[this.nameIndex]
				}
			});
			module.exports = new r.Struct({
				version: r.fixed32,
				featureNameCount: r.uint16,
				reserved1: new r.Reserved(r.uint16),
				reserved2: new r.Reserved(r.uint32),
				featureNames: new r.Array(FeatureName, "featureNameCount")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	92: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				instructions: new r.Array(r.uint8)
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	93: [function(require, module, exports) {
		(function() {
			var Axis, Instance, r;
			r = require("restructure");
			Axis = new r.Struct({
				axisTag: new r.String(4),
				minValue: r.fixed32,
				defaultValue: r.fixed32,
				maxValue: r.fixed32,
				flags: r.uint16,
				nameID: r.uint16,
				name: function() {
					var ref, ref1;
					return (ref = this.parent.parent.name.records.fontFeatures) != null ? (ref1 = ref.English) != null ? ref1[this.nameID] : void 0 : void 0
				}
			});
			Instance = new r.Struct({
				nameID: r.uint16,
				name: function() {
					var ref, ref1;
					return (ref = this.parent.parent.name.records.fontFeatures) != null ? (ref1 = ref.English) != null ? ref1[this.nameID] : void 0 : void 0
				},
				flags: r.uint16,
				coord: new r.Array(r.fixed32, function() {
					return this.parent.axisCount
				})
			});
			module.exports = new r.Struct({
				version: r.fixed32,
				offsetToData: r.uint16,
				countSizePairs: r.uint16,
				axisCount: r.uint16,
				axisSize: r.uint16,
				instanceCount: r.uint16,
				instanceSize: r.uint16,
				axis: new r.Array(Axis, "axisCount"),
				instance: new r.Array(Instance, "instanceCount")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	94: [function(require, module, exports) {
		(function() {
			var GaspRange, r;
			r = require("restructure");
			GaspRange = new r.Struct({
				rangeMaxPPEM: r.uint16,
				rangeGaspBehavior: new r.Bitfield(r.uint16, ["grayscale", "gridfit", "symmetricSmoothing", "symmetricGridfit"])
			});
			module.exports = new r.Struct({
				version: r.uint16,
				numRanges: r.uint16,
				gaspRanges: new r.Array(GaspRange, "numRanges")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	95: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Array(new r.Buffer)
		}).call(this)
	}, {
		restructure: 3
	}],
	96: [function(require, module, exports) {
		(function() {
			var r, shortFrac;
			r = require("restructure");
			shortFrac = new r.Fixed(16, "BE", 14);
			module.exports = new r.Struct({
				version: r.uint16,
				reserved: new r.Reserved(r.uint16),
				axisCount: r.uint16,
				globalCoordCount: r.uint16,
				globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac, "axisCount"), "globalCoordCount")),
				glyphCount: r.uint16,
				flags: r.uint16,
				offsetToData: r.uint32
			});
			module.exports.process = function(stream) {
				var i, j, len, offset, ptr, ref, type;
				type = this.flags === 1 ? r.uint32 : r.uint16;
				ptr = new r.Pointer(type, "void", {
					relativeTo: "offsetToData",
					allowNull: false
				});
				this.offsets = new r.Array(ptr, this.glyphCount + 1).decode(stream, this);
				if (this.flags === 0) {
					ref = this.offsets;
					for (i = j = 0, len = ref.length; j < len; i = ++j) {
						offset = ref[i];
						this.offsets[i] = offset * 2
					}
				}
			}
		}).call(this)
	}, {
		restructure: 3
	}],
	97: [function(require, module, exports) {
		(function() {
			var DeviceRecord, r;
			r = require("restructure");
			DeviceRecord = new r.Struct({
				pixelSize: r.uint8,
				maximumWidth: r.uint8,
				widths: new r.Array(r.uint8, function() {
					return this.parent.parent.maxp.numGlyphs
				})
			});
			module.exports = new r.Struct({
				version: r.uint16,
				numRecords: r.int16,
				sizeDeviceRecord: r.int32,
				records: new r.Array(DeviceRecord, "numRecords")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	98: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				version: r.int32,
				revision: r.int32,
				checkSumAdjustment: r.uint32,
				magicNumber: r.uint32,
				flags: r.uint16,
				unitsPerEm: r.uint16,
				created: new r.Array(r.int32, 2),
				modified: new r.Array(r.int32, 2),
				xMin: r.int16,
				yMin: r.int16,
				xMax: r.int16,
				yMax: r.int16,
				macStyle: new r.Bitfield(r.uint16, ["bold", "italic", "underline", "outline", "shadow", "condensed", "extended"]),
				lowestRecPPEM: r.uint16,
				fontDirectionHint: r.int16,
				indexToLocFormat: r.int16,
				glyphDataFormat: r.int16
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	99: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				version: r.int32,
				ascent: r.int16,
				descent: r.int16,
				lineGap: r.int16,
				advanceWidthMax: r.uint16,
				minLeftSideBearing: r.int16,
				minRightSideBearing: r.int16,
				xMaxExtent: r.int16,
				caretSlopeRise: r.int16,
				caretSlopeRun: r.int16,
				caretOffset: r.int16,
				reserved: new r.Reserved(r.int16, 4),
				metricDataFormat: r.int16,
				numberOfMetrics: r.uint16
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	100: [function(require, module, exports) {
		(function() {
			var HmtxEntry, r;
			r = require("restructure");
			HmtxEntry = new r.Struct({
				advance: r.uint16,
				bearing: r.int16
			});
			module.exports = new r.Struct({
				metrics: new r.LazyArray(HmtxEntry, function() {
					return this.parent.hhea.numberOfMetrics
				}),
				bearings: new r.LazyArray(r.int16, function() {
					return this.parent.maxp.numGlyphs - this.parent.hhea.numberOfMetrics
				})
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	101: [function(require, module, exports) {
		(function() {
			exports.cmap = require("./cmap");
			exports.head = require("./head");
			exports.hhea = require("./hhea");
			exports.hmtx = require("./hmtx");
			exports.maxp = require("./maxp");
			exports.name = require("./name");
			exports["OS/2"] = require("./OS2");
			exports.post = require("./post");
			exports["cvt "] = require("./cvt");
			exports.fpgm = require("./fpgm");
			exports.loca = require("./loca");
			exports.prep = require("./prep");
			exports.glyf = require("./glyf");
			exports["CFF "] = require("../CFFFont");
			exports.VORG = require("./VORG");
			exports.EBLC = require("./EBLC");
			exports.CBLC = exports.EBLC;
			exports.sbix = require("./sbix");
			exports.COLR = require("./COLR");
			exports.CPAL = require("./CPAL");
			exports.BASE = require("./BASE");
			exports.GDEF = require("./GDEF");
			exports.GPOS = require("./GPOS");
			exports.GSUB = require("./GSUB");
			exports.JSTF = require("./JSTF");
			exports.DSIG = require("./DSIG");
			exports.gasp = require("./gasp");
			exports.hdmx = require("./hdmx");
			exports.kern = require("./kern");
			exports.LTSH = require("./LTSH");
			exports.PCLT = require("./PCLT");
			exports.VDMX = require("./VDMX");
			exports.vhea = require("./vhea");
			exports.vmtx = require("./vmtx");
			exports.avar = require("./avar");
			exports.bsln = require("./bsln");
			exports.feat = require("./feat");
			exports.fvar = require("./fvar");
			exports.gvar = require("./gvar");
			exports.just = require("./just");
			exports.morx = require("./morx");
			exports.opbd = require("./opbd")
		}).call(this)
	}, {
		"../CFFFont": 24,
		"./BASE": 70,
		"./COLR": 71,
		"./CPAL": 72,
		"./DSIG": 73,
		"./EBLC": 75,
		"./GDEF": 76,
		"./GPOS": 77,
		"./GSUB": 78,
		"./JSTF": 79,
		"./LTSH": 80,
		"./OS2": 81,
		"./PCLT": 82,
		"./VDMX": 83,
		"./VORG": 84,
		"./avar": 86,
		"./bsln": 87,
		"./cmap": 88,
		"./cvt": 89,
		"./feat": 91,
		"./fpgm": 92,
		"./fvar": 93,
		"./gasp": 94,
		"./glyf": 95,
		"./gvar": 96,
		"./hdmx": 97,
		"./head": 98,
		"./hhea": 99,
		"./hmtx": 100,
		"./just": 102,
		"./kern": 103,
		"./loca": 104,
		"./maxp": 105,
		"./morx": 106,
		"./name": 107,
		"./opbd": 108,
		"./post": 110,
		"./prep": 111,
		"./sbix": 112,
		"./vhea": 113,
		"./vmtx": 114
	}],
	102: [function(require, module, exports) {
		(function() {
			var Action, ActionData, ClassTable, JustificationTable, LookupTable, PostCompensationTable, PostcompensationAction, StateTable1, WidthDeltaCluster, WidthDeltaRecord, r, ref;
			r = require("restructure");
			ref = require("./aat"), LookupTable = ref.LookupTable, StateTable1 = ref.StateTable1;
			ClassTable = new r.Struct({
				length: r.uint16,
				coverage: r.uint16,
				subFeatureFlags: r.uint32,
				stateTable: new StateTable1
			});
			WidthDeltaRecord = new r.Struct({
				justClass: r.uint32,
				beforeGrowLimit: r.fixed32,
				beforeShrinkLimit: r.fixed32,
				afterGrowLimit: r.fixed32,
				afterShrinkLimit: r.fixed32,
				growFlags: r.uint16,
				shrinkFlags: r.uint16
			});
			WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);
			ActionData = new r.VersionedStruct("actionType", {
				0: {
					lowerLimit: r.fixed32,
					upperLimit: r.fixed32,
					order: r.uint16,
					glyphs: new r.Array(r.uint16, r.uint16)
				},
				1: {
					addGlyph: r.uint16
				},
				2: {
					substThreshold: r.fixed32,
					addGlyph: r.uint16,
					substGlyph: r.uint16
				},
				3: {},
				4: {
					variationAxis: r.uint32,
					minimumLimit: r.fixed32,
					noStretchValue: r.fixed32,
					maximumLimit: r.fixed32
				},
				5: {
					flags: r.uint16,
					glyph: r.uint16
				}
			});
			Action = new r.Struct({
				actionClass: r.uint16,
				actionType: r.uint16,
				actionLength: r.uint32,
				actionData: ActionData,
				padding: new r.Reserved(r.uint8, function() {
					return this.actionLength - this._currentOffset
				})
			});
			PostcompensationAction = new r.Array(Action, r.uint32);
			PostCompensationTable = new r.Struct({
				lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction))
			});
			JustificationTable = new r.Struct({
				classTable: new r.Pointer(r.uint16, ClassTable, {
					type: "parent"
				}),
				wdcOffset: r.uint16,
				postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, {
					type: "parent"
				}),
				widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, {
					type: "parent",
					relativeTo: "wdcOffset"
				}))
			});
			module.exports = new r.Struct({
				version: r.uint32,
				format: r.uint16,
				horizontal: new r.Pointer(r.uint16, JustificationTable),
				vertical: new r.Pointer(r.uint16, JustificationTable)
			})
		}).call(this)
	}, {
		"./aat": 85,
		restructure: 3
	}],
	103: [function(require, module, exports) {
		(function() {
			var ClassTable, Kern2Array, KernPair, KernSubtable, KernTable, r;
			r = require("restructure");
			KernPair = new r.Struct({
				left: r.uint16,
				right: r.uint16,
				value: r.int16
			});
			ClassTable = new r.Struct({
				firstGlyph: r.uint16,
				nGlyphs: r.uint16,
				offsets: new r.Array(r.uint16, "nGlyphs"),
				max: function() {
					return this.offsets.length && Math.max.apply(Math, this.offsets)
				}
			});
			Kern2Array = new r.Struct({
				off: function() {
					return this._startOffset - this.parent.parent._startOffset
				},
				len: function() {
					return ((this.parent.leftTable.max - this.off) / this.parent.rowWidth + 1) * (this.parent.rowWidth / 2)
				},
				values: new r.LazyArray(r.int16, "len")
			});
			KernSubtable = new r.VersionedStruct("format", {
				0: {
					nPairs: r.uint16,
					searchRange: r.uint16,
					entrySelector: r.uint16,
					rangeShift: r.uint16,
					pairs: new r.Array(KernPair, "nPairs")
				},
				2: {
					rowWidth: r.uint16,
					leftTable: new r.Pointer(r.uint16, ClassTable, {
						type: "parent"
					}),
					rightTable: new r.Pointer(r.uint16, ClassTable, {
						type: "parent"
					}),
					array: new r.Pointer(r.uint16, Kern2Array, {
						type: "parent"
					})
				},
				3: {
					glyphCount: r.uint16,
					kernValueCount: r.uint8,
					leftClassCount: r.uint8,
					rightClassCount: r.uint8,
					flags: r.uint8,
					kernValue: new r.Array(r.int16, "kernValueCount"),
					leftClass: new r.Array(r.uint8, "glyphCount"),
					rightClass: new r.Array(r.uint8, "glyphCount"),
					kernIndex: new r.Array(r.uint8, function() {
						return this.leftClassCount * this.rightClassCount
					})
				}
			});
			KernTable = new r.VersionedStruct("version", {
				0: {
					subVersion: r.uint16,
					length: r.uint16,
					format: r.uint8,
					coverage: new r.Bitfield(r.uint8, ["horizontal", "minimum", "crossStream", "override"]),
					subtable: KernSubtable,
					padding: new r.Reserved(r.uint8, function() {
						return this.length - this._currentOffset
					})
				},
				1: {
					length: r.uint32,
					coverage: new r.Bitfield(r.uint8, [null, null, null, null, null, "variation", "crossStream", "vertical"]),
					format: r.uint8,
					tupleIndex: r.uint16,
					subtable: KernSubtable,
					padding: new r.Reserved(r.uint8, function() {
						return this.length - this._currentOffset
					})
				}
			});
			module.exports = new r.VersionedStruct(r.uint16, {
				0: {
					nTables: r.uint16,
					tables: new r.Array(KernTable, "nTables")
				},
				1: {
					reserved: new r.Reserved(r.uint16),
					nTables: r.uint32,
					tables: new r.Array(KernTable, "nTables")
				}
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	104: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.VersionedStruct("head.indexToLocFormat", {
				0: {
					offsets: new r.Array(r.uint16)
				},
				1: {
					offsets: new r.Array(r.uint32)
				}
			});
			module.exports.process = function() {
				var i, j, ref, results;
				if (this.version !== 0) {
					return
				}
				results = [];
				for (i = j = 0, ref = this.offsets.length; j < ref; i = j += 1) {
					results.push(this.offsets[i] <<= 1)
				}
				return results
			};
			module.exports.preEncode = function() {
				var i, j, ref, results;
				if (this.version != null) {
					return
				}
				this.version = this.offsets[this.offsets.length - 1] > 65535 ? 1 : 0;
				if (this.version !== 0) {
					return
				}
				results = [];
				for (i = j = 0, ref = this.offsets.length; j < ref; i = j += 1) {
					results.push(this.offsets[i] >>>= 1)
				}
				return results
			}
		}).call(this)
	}, {
		restructure: 3
	}],
	105: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				version: r.int32,
				numGlyphs: r.uint16,
				maxPoints: r.uint16,
				maxContours: r.uint16,
				maxComponentPoints: r.uint16,
				maxComponentContours: r.uint16,
				maxZones: r.uint16,
				maxTwilightPoints: r.uint16,
				maxStorage: r.uint16,
				maxFunctionDefs: r.uint16,
				maxInstructionDefs: r.uint16,
				maxStackElements: r.uint16,
				maxSizeOfInstructions: r.uint16,
				maxComponentElements: r.uint16,
				maxComponentDepth: r.uint16
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	106: [function(require, module, exports) {
		(function() {
			var ContextualData, FeatureEntry, InsertionData, LigatureData, LookupTable, MorxChain, StateTable, SubstitutionTable, Subtable, SubtableData, UnboundedArray, r, ref;
			r = require("restructure");
			ref = require("./aat"), UnboundedArray = ref.UnboundedArray, LookupTable = ref.LookupTable, StateTable = ref.StateTable;
			LigatureData = {
				action: r.uint16
			};
			ContextualData = {
				markIndex: r.uint16,
				currentIndex: r.uint16
			};
			InsertionData = {
				currentInsertIndex: r.uint16,
				markedInsertIndex: r.uint16
			};
			SubstitutionTable = new r.Struct({
				items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable))
			});
			SubtableData = new r.VersionedStruct("type", {
				0: {
					stateTable: new StateTable
				},
				1: {
					stateTable: new StateTable(ContextualData),
					substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)
				},
				2: {
					stateTable: new StateTable(LigatureData),
					ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),
					components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),
					ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
				},
				4: {
					lookupTable: new LookupTable
				},
				5: {
					stateTable: new StateTable(InsertionData),
					insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
				}
			});
			Subtable = new r.Struct({
				length: r.uint32,
				coverage: r.uint24,
				type: r.uint8,
				subFeatureFlags: r.uint32,
				table: SubtableData,
				padding: new r.Reserved(r.uint8, function() {
					return this.length - this._currentOffset
				})
			});
			FeatureEntry = new r.Struct({
				featureType: r.uint16,
				featureSetting: r.uint16,
				enableFlags: r.uint32,
				disableFlags: r.uint32
			});
			MorxChain = new r.Struct({
				defaultFlags: r.uint32,
				chainLength: r.uint32,
				nFeatureEntries: r.uint32,
				nSubtables: r.uint32,
				features: new r.Array(FeatureEntry, "nFeatureEntries"),
				subtables: new r.Array(Subtable, "nSubtables")
			});
			module.exports = new r.Struct({
				version: r.uint16,
				unused: new r.Reserved(r.uint16),
				nChains: r.uint32,
				chains: new r.Array(MorxChain, "nChains")
			})
		}).call(this)
	}, {
		"./aat": 85,
		restructure: 3
	}],
	107: [function(require, module, exports) {
		(function(Buffer) {
			(function() {
				var ENCODINGS, LANGUAGES, LangTagRecord, NAMES, NameRecord, r;
				r = require("restructure");
				NameRecord = new r.Struct({
					platformID: r.uint16,
					encodingID: r.uint16,
					languageID: r.uint16,
					nameID: r.uint16,
					length: r.uint16,
					string: new r.Pointer(r.uint16, new r.String("length", function() {
						return ENCODINGS[this.platformID][this.encodingID]
					}), {
						type: "parent",
						relativeTo: "parent.stringOffset",
						allowNull: false
					})
				});
				LangTagRecord = new r.Struct({
					length: r.uint16,
					tag: new r.Pointer(r.uint16, new r.String("length", "utf16be"), {
						type: "parent",
						relativeTo: "stringOffset"
					})
				});
				module.exports = new r.VersionedStruct(r.uint16, {
					0: {
						count: r.uint16,
						stringOffset: r.uint16,
						records: new r.Array(NameRecord, "count")
					},
					1: {
						count: r.uint16,
						stringOffset: r.uint16,
						records: new r.Array(NameRecord, "count"),
						langTagCount: r.uint16,
						langTags: new r.Array(LangTagRecord, "langTagCount")
					}
				});
				NAMES = ["copyright", "fontFamily", "fontSubfamily", "uniqueSubfamily", "fullName", "version", "postscriptName", "trademark", "manufacturer", "designer", "description", "vendorURL", "designerURL", "license", "licenseURL", null, "preferredFamily", "preferredSubfamily", "compatibleFull", "sampleText", "postscriptCIDFontName", "wwsFamilyName", "wwsSubfamilyName"];
				ENCODINGS = [
					["utf16be", "utf16be", "utf16be", "utf16be", "utf16be", "utf16be"],
					["macroman", "shift-jis", "big5", "euc-kr", "iso-8859-6", "iso-8859-8", "macgreek", "maccyrillic", "symbol", "Devanagari", "Gurmukhi", "Gujarati", "Oriya", "Bengali", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhalese", "Burmese", "Khmer", "macthai", "Laotian", "Georgian", "Armenian", "gb-2312-80", "Tibetan", "Mongolian", "Geez", "maccyrillic", "Vietnamese", "Sindhi"],
					["ascii"],
					["symbol", "utf16be", "shift-jis", "gb18030", "big5", "wansung", "johab", null, null, null, "ucs-4"]
				];
				LANGUAGES = [
					[], {
						0: "English",
						59: "Pashto",
						1: "French",
						60: "Kurdish",
						2: "German",
						61: "Kashmiri",
						3: "Italian",
						62: "Sindhi",
						4: "Dutch",
						63: "Tibetan",
						5: "Swedish",
						64: "Nepali",
						6: "Spanish",
						65: "Sanskrit",
						7: "Danish",
						66: "Marathi",
						8: "Portuguese",
						67: "Bengali",
						9: "Norwegian",
						68: "Assamese",
						10: "Hebrew",
						69: "Gujarati",
						11: "Japanese",
						70: "Punjabi",
						12: "Arabic",
						71: "Oriya",
						13: "Finnish",
						72: "Malayalam",
						14: "Greek",
						73: "Kannada",
						15: "Icelandic",
						74: "Tamil",
						16: "Maltese",
						75: "Telugu",
						17: "Turkish",
						76: "Sinhalese",
						18: "Croatian",
						77: "Burmese",
						19: "Chinese (Traditional)",
						78: "Khmer",
						20: "Urdu",
						79: "Lao",
						21: "Hindi",
						80: "Vietnamese",
						22: "Thai",
						81: "Indonesian",
						23: "Korean",
						82: "Tagalong",
						24: "Lithuanian",
						83: "Malay (Roman script)",
						25: "Polish",
						84: "Malay (Arabic script)",
						26: "Hungarian",
						85: "Amharic",
						27: "Estonian",
						86: "Tigrinya",
						28: "Latvian",
						87: "Galla",
						29: "Sami",
						88: "Somali",
						30: "Faroese",
						89: "Swahili",
						31: "Farsi/Persian",
						90: "Kinyarwanda/Ruanda",
						32: "Russian",
						91: "Rundi",
						33: "Chinese (Simplified)",
						92: "Nyanja/Chewa",
						34: "Flemish",
						93: "Malagasy",
						35: "Irish Gaelic",
						94: "Esperanto",
						36: "Albanian",
						128: "Welsh",
						37: "Romanian",
						129: "Basque",
						38: "Czech",
						130: "Catalan",
						39: "Slovak",
						131: "Latin",
						40: "Slovenian",
						132: "Quenchua",
						41: "Yiddish",
						133: "Guarani",
						42: "Serbian",
						134: "Aymara",
						43: "Macedonian",
						135: "Tatar",
						44: "Bulgarian",
						136: "Uighur",
						45: "Ukrainian",
						137: "Dzongkha",
						46: "Byelorussian",
						138: "Javanese (Roman script)",
						47: "Uzbek",
						139: "Sundanese (Roman script)",
						48: "Kazakh",
						140: "Galician",
						49: "Azerbaijani (Cyrillic script)",
						141: "Afrikaans",
						50: "Azerbaijani (Arabic script)",
						142: "Breton",
						51: "Armenian",
						143: "Inuktitut",
						52: "Georgian",
						144: "Scottish Gaelic",
						53: "Moldavian",
						145: "Manx Gaelic",
						54: "Kirghiz",
						146: "Irish Gaelic (with dot above)",
						55: "Tajiki",
						147: "Tongan",
						56: "Turkmen",
						148: "Greek (polytonic)",
						57: "Mongolian (Mongolian script)",
						149: "Greenlandic",
						58: "Mongolian (Cyrillic script)",
						150: "Azerbaijani (Roman script)"
					},
					[], {
						1078: "Afrikaans",
						1107: "Khmer",
						1052: "Albanian",
						1158: "K'iche",
						1156: "Alsatian",
						1159: "Kinyarwanda",
						1118: "Amharic",
						1089: "Kiswahili",
						5121: "Arabic",
						1111: "Konkani",
						15361: "Arabic",
						1042: "Korean",
						3073: "Arabic",
						1088: "Kyrgyz",
						2049: "Arabic",
						1108: "Lao",
						11265: "Arabic",
						1062: "Latvian",
						13313: "Arabic",
						1063: "Lithuanian",
						12289: "Arabic",
						2094: "Lower Sorbian",
						4097: "Arabic",
						1134: "Luxembourgish",
						6145: "Arabic",
						1071: "Macedonian (FYROM)",
						8193: "Arabic",
						2110: "Malay",
						16385: "Arabic",
						1086: "Malay",
						1025: "Arabic",
						1100: "Malayalam",
						10241: "Arabic",
						1082: "Maltese",
						7169: "Arabic",
						1153: "Maori",
						14337: "Arabic",
						1146: "Mapudungun",
						9217: "Arabic",
						1102: "Marathi",
						1067: "Armenian",
						1148: "Mohawk",
						1101: "Assamese",
						1104: "Mongolian (Cyrillic)",
						2092: "Azeri (Cyrillic)",
						2128: "Mongolian (Traditional)",
						1068: "Azeri (Latin)",
						1121: "Nepali",
						1133: "Bashkir",
						1044: "Norwegian (Bokmal)",
						1069: "Basque",
						2068: "Norwegian (Nynorsk)",
						1059: "Belarusian",
						1154: "Occitan",
						2117: "Bengali",
						1096: "Odia (formerly Oriya)",
						1093: "Bengali",
						1123: "Pashto",
						8218: "Bosnian (Cyrillic)",
						1045: "Polish",
						5146: "Bosnian (Latin)",
						1046: "Portuguese",
						1150: "Breton",
						2070: "Portuguese",
						1026: "Bulgarian",
						1094: "Punjabi",
						1027: "Catalan",
						1131: "Quechua",
						3076: "Chinese",
						2155: "Quechua",
						5124: "Chinese",
						3179: "Quechua",
						2052: "Chinese",
						1048: "Romanian",
						4100: "Chinese",
						1047: "Romansh",
						1028: "Chinese",
						1049: "Russian",
						1155: "Corsican",
						9275: "Sami (Inari)",
						1050: "Croatian",
						4155: "Sami (Lule)",
						4122: "Croatian (Latin)",
						5179: "Sami (Lule)",
						1029: "Czech",
						3131: "Sami (Northern)",
						1030: "Danish",
						1083: "Sami (Northern)",
						1164: "Dari",
						2107: "Sami (Northern)",
						1125: "Divehi",
						8251: "Sami (Skolt)",
						2067: "Dutch",
						6203: "Sami (Southern)",
						1043: "Dutch",
						7227: "Sami (Southern)",
						3081: "English",
						1103: "Sanskrit",
						10249: "English",
						7194: "Serbian (Cyrillic)",
						4105: "English",
						3098: "Serbian (Cyrillic)",
						9225: "English",
						6170: "Serbian (Latin)",
						16393: "English",
						2074: "Serbian (Latin)",
						6153: "English",
						1132: "Sesotho sa Leboa",
						8201: "English",
						1074: "Setswana",
						17417: "English",
						1115: "Sinhala",
						5129: "English",
						1051: "Slovak",
						13321: "English",
						1060: "Slovenian",
						18441: "English",
						11274: "Spanish",
						7177: "English",
						16394: "Spanish",
						11273: "English",
						13322: "Spanish",
						2057: "English",
						9226: "Spanish",
						1033: "English",
						5130: "Spanish",
						12297: "English",
						7178: "Spanish",
						1061: "Estonian",
						12298: "Spanish",
						1080: "Faroese",
						17418: "Spanish",
						1124: "Filipino",
						4106: "Spanish",
						1035: "Finnish",
						18442: "Spanish",
						2060: "French",
						2058: "Spanish",
						3084: "French",
						19466: "Spanish",
						1036: "French",
						6154: "Spanish",
						5132: "French",
						15370: "Spanish",
						6156: "French",
						10250: "Spanish",
						4108: "French",
						20490: "Spanish",
						1122: "Frisian",
						3082: "Spanish (Modern Sort)",
						1110: "Galician",
						1034: "Spanish (Traditional Sort)",
						1079: "Georgian",
						21514: "Spanish",
						3079: "German",
						14346: "Spanish",
						1031: "German",
						8202: "Spanish",
						5127: "German",
						2077: "Sweden",
						4103: "German",
						1053: "Swedish",
						2055: "German",
						1114: "Syriac",
						1032: "Greek",
						1064: "Tajik (Cyrillic)",
						1135: "Greenlandic",
						2143: "Tamazight (Latin)",
						1095: "Gujarati",
						1097: "Tamil",
						1128: "Hausa (Latin)",
						1092: "Tatar",
						1037: "Hebrew",
						1098: "Telugu",
						1081: "Hindi",
						1054: "Thai",
						1038: "Hungarian",
						1105: "Tibetan",
						1039: "Icelandic",
						1055: "Turkish",
						1136: "Igbo",
						1090: "Turkmen",
						1057: "Indonesian",
						1152: "Uighur",
						1117: "Inuktitut",
						1058: "Ukrainian",
						2141: "Inuktitut (Latin)",
						1070: "Upper Sorbian",
						2108: "Irish",
						1056: "Urdu",
						1076: "isiXhosa",
						2115: "Uzbek (Cyrillic)",
						1077: "isiZulu",
						1091: "Uzbek (Latin)",
						1040: "Italian",
						1066: "Vietnamese",
						2064: "Italian",
						1106: "Welsh",
						1041: "Japanese",
						1160: "Wolof",
						1099: "Kannada",
						1157: "Yakut",
						1087: "Kazakh",
						1144: "Yi",
						1130: "Yoruba"
					}
				];
				module.exports.process = function(stream) {
					var base, feature, i, key, language, len, record, records, ref;
					records = {};
					ref = this.records;
					for (i = 0, len = ref.length; i < len; i++) {
						record = ref[i];
						language = LANGUAGES[record.platformID][record.languageID];
						if (language == null && this.langTags != null && record.languageID >= 32768) {
							language = this.langTags[record.languageID - 32768].tag
						}
						if (language == null) {
							language = record.platformID + "-" + record.languageID
						}
						if (record.nameID >= 256) {
							if (records.fontFeatures == null) {
								records.fontFeatures = {}
							}
							feature = (base = records.fontFeatures)[language] != null ? base[language] : base[language] = {};
							feature[record.nameID] = record.string
						} else {
							key = NAMES[record.nameID] || record.nameID;
							if (records[key] == null) {
								records[key] = {}
							}
							records[key][language] = record.string
						}
					}
					return this.records = records
				};
				module.exports.preEncode = function() {
					var key, records, ref, val;
					if (Array.isArray(this.records)) {
						return
					}
					this.version = 0;
					records = [];
					ref = this.records;
					for (key in ref) {
						val = ref[key];
						if (key === "fontFeatures") {
							continue
						}
						records.push({
							platformID: 3,
							encodingID: 1,
							languageID: 1033,
							nameID: NAMES.indexOf(key),
							length: Buffer.byteLength(val.English, "utf16le"),
							string: val.English
						});
						if (key === "postscriptName") {
							records.push({
								platformID: 1,
								encodingID: 0,
								languageID: 0,
								nameID: NAMES.indexOf(key),
								length: val.English.length,
								string: val.English
							})
						}
					}
					this.records = records;
					this.count = records.length;
					return this.stringOffset = module.exports.size(this, null, false)
				}
			}).call(this)
		}).call(this, require("buffer").Buffer)
	}, {
		buffer: 116,
		restructure: 3
	}],
	108: [function(require, module, exports) {
		(function() {
			var LookupTable, OpticalBounds, r;
			r = require("restructure");
			LookupTable = require("./aat").LookupTable;
			OpticalBounds = new r.Struct({
				left: r.int16,
				top: r.int16,
				right: r.int16,
				bottom: r.int16
			});
			module.exports = new r.Struct({
				version: r.fixed32,
				format: r.uint16,
				lookupTable: new LookupTable(OpticalBounds)
			})
		}).call(this)
	}, {
		"./aat": 85,
		restructure: 3
	}],
	109: [function(require, module, exports) {
		(function() {
			var ChainRule, ChainRuleSet, ClassDef, ClassRangeRecord, ClassRule, ClassSet, Coverage, Feature, FeatureRecord, LangSysRecord, LangSysTable, LookupFlags, LookupRecord, RangeRecord, Rule, RuleSet, Script, ScriptRecord, r;
			r = require("restructure");
			LangSysTable = new r.Struct({
				reserved: new r.Reserved(r.uint16),
				reqFeatureIndex: r.uint16,
				featureCount: r.uint16,
				featureIndexes: new r.Array(r.uint16, "featureCount")
			});
			LangSysRecord = new r.Struct({
				tag: new r.String(4),
				langSys: new r.Pointer(r.uint16, LangSysTable, {
					type: "parent"
				})
			});
			Script = new r.Struct({
				defaultLangSys: new r.Pointer(r.uint16, LangSysTable),
				count: r.uint16,
				langSysRecords: new r.Array(LangSysRecord, "count")
			});
			ScriptRecord = new r.Struct({
				tag: new r.String(4),
				script: new r.Pointer(r.uint16, Script, {
					type: "parent"
				})
			});
			exports.ScriptList = new r.Array(ScriptRecord, r.uint16);
			Feature = new r.Struct({
				featureParams: r.uint16,
				lookupCount: r.uint16,
				lookupListIndexes: new r.Array(r.uint16, "lookupCount")
			});
			FeatureRecord = new r.Struct({
				tag: new r.String(4),
				feature: new r.Pointer(r.uint16, Feature, {
					type: "parent"
				})
			});
			exports.FeatureList = new r.Array(FeatureRecord, r.uint16);
			LookupFlags = new r.Bitfield(r.uint16, ["rightToLeft", "ignoreBaseGlyphs", "ignoreLigatures", "ignoreMarks", "useMarkFilteringSet", null, "markAttachmentType"]);
			exports.LookupList = function(SubTable) {
				var Lookup;
				Lookup = new r.Struct({
					lookupType: r.uint16,
					flags: LookupFlags,
					subTableCount: r.uint16,
					subTables: new r.Array(new r.Pointer(r.uint16, SubTable), "subTableCount"),
					markFilteringSet: r.uint16
				});
				return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16)
			};
			RangeRecord = new r.Struct({
				start: r.uint16,
				end: r.uint16,
				startCoverageIndex: r.uint16
			});
			Coverage = new r.VersionedStruct(r.uint16, {
				1: {
					glyphCount: r.uint16,
					glyphs: new r.Array(r.uint16, "glyphCount")
				},
				2: {
					rangeCount: r.uint16,
					rangeRecords: new r.Array(RangeRecord, "rangeCount")
				}
			});
			exports.Coverage = Coverage;
			ClassRangeRecord = new r.Struct({
				start: r.uint16,
				end: r.uint16,
				class: r.uint16
			});
			ClassDef = new r.VersionedStruct(r.uint16, {
				1: {
					startGlyph: r.uint16,
					glyphCount: r.uint16,
					classValueArray: new r.Array(r.uint16, "glyphCount")
				},
				2: {
					classRangeCount: r.uint16,
					classRangeRecord: new r.Array(ClassRangeRecord, "classRangeCount")
				}
			});
			exports.ClassDef = ClassDef;
			exports.Device = new r.Struct({
				startSize: r.uint16,
				endSize: r.uint16,
				deltaFormat: r.uint16
			});
			LookupRecord = new r.Struct({
				sequenceIndex: r.uint16,
				lookupListIndex: r.uint16
			});
			Rule = new r.Struct({
				glyphCount: r.uint16,
				lookupCount: r.uint16,
				input: new r.Array(r.uint16, function() {
					return this.glyphCount - 1
				}),
				lookupRecords: new r.Array(LookupRecord, "lookupCount")
			});
			RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);
			ClassRule = new r.Struct({
				glyphCount: r.uint16,
				lookupCount: r.uint16,
				classes: new r.Array(r.uint16, function() {
					return this.glyphCount - 1
				}),
				lookupRecords: new r.Array(LookupRecord, "lookupCount")
			});
			ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);
			exports.Context = new r.VersionedStruct(r.uint16, {
				1: {
					coverage: new r.Pointer(r.uint16, Coverage),
					ruleSetCount: r.uint16,
					ruleSets: new r.Array(new r.Pointer(r.uint16, RuleSet), "ruleSetCount")
				},
				2: {
					coverage: new r.Pointer(r.uint16, Coverage),
					classDef: new r.Pointer(r.uint16, ClassDef),
					classSetCnt: r.uint16,
					classSet: new r.Array(new r.Pointer(r.uint16, ClassSet), "classSetCnt")
				},
				3: {
					glyphCount: r.uint16,
					lookupCount: r.uint16,
					coverages: new r.Array(new r.Pointer(r.uint16, Coverage), "glyphCount"),
					lookupRecords: new r.Array(LookupRecord, "lookupCount")
				}
			});
			ChainRule = new r.Struct({
				backtrackGlyphCount: r.uint16,
				backtrack: new r.Array(r.uint16, "backtrackGlyphCount"),
				inputGlyphCount: r.uint16,
				input: new r.Array(r.uint16, function() {
					return this.inputGlyphCount - 1
				}),
				lookaheadGlyphCount: r.uint16,
				lookahead: new r.Array(r.uint16, "lookaheadGlyphCount"),
				lookupCount: r.uint16,
				lookupRecords: new r.Array(LookupRecord, "lookupCount")
			});
			ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);
			exports.ChainingContext = new r.VersionedStruct(r.uint16, {
				1: {
					coverage: new r.Pointer(r.uint16, Coverage),
					chainCount: r.uint16,
					chainRuleSets: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), "chainCount")
				},
				2: {
					coverage: new r.Pointer(r.uint16, Coverage),
					backtrackClassDef: new r.Pointer(r.uint16, ClassDef),
					inputClassDef: new r.Pointer(r.uint16, ClassDef),
					lookaheadClassDef: new r.Pointer(r.uint16, ClassDef),
					chainCount: r.uint16,
					chainClassSet: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), "chainCount")
				},
				3: {
					backtrackGlyphCount: r.uint16,
					backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "backtrackGlyphCount"),
					inputGlyphCount: r.uint16,
					inputCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "inputGlyphCount"),
					lookaheadGlyphCount: r.uint16,
					lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "lookaheadGlyphCount"),
					lookupCount: r.uint16,
					lookupRecords: new r.Array(LookupRecord, "lookupCount")
				}
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	110: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.VersionedStruct(r.fixed32, {
				header: {
					italicAngle: r.fixed32,
					underlinePosition: r.int16,
					underlineThickness: r.int16,
					isFixedPitch: r.uint32,
					minMemType42: r.uint32,
					maxMemType42: r.uint32,
					minMemType1: r.uint32,
					maxMemType1: r.uint32
				},
				1: {},
				2: {
					numberOfGlyphs: r.uint16,
					glyphNameIndex: new r.Array(r.uint16, "numberOfGlyphs"),
					names: new r.Array(new r.String(r.uint8))
				},
				2.5: {
					numberOfGlyphs: r.uint16,
					offsets: new r.Array(r.int8, "numberOfGlyphs")
				},
				3: {},
				4: {
					map: new r.Array(r.uint32, function() {
						return this.parent.maxp.numGlyphs
					})
				}
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	111: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				controlValueProgram: new r.Array(r.uint8)
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	112: [function(require, module, exports) {
		(function() {
			var ImageTable, r;
			r = require("restructure");
			ImageTable = new r.Struct({
				ppem: r.uint16,
				resolution: r.uint16,
				imageOffsets: new r.Array(new r.Pointer(r.uint32, "void"), function() {
					return this.parent.parent.maxp.numGlyphs + 1
				})
			});
			module.exports = new r.Struct({
				version: r.uint16,
				flags: new r.Bitfield(r.uint16, ["renderOutlines"]),
				numImgTables: r.uint32,
				imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), "numImgTables")
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	113: [function(require, module, exports) {
		(function() {
			var r;
			r = require("restructure");
			module.exports = new r.Struct({
				version: r.uint16,
				ascent: r.int16,
				descent: r.int16,
				lineGap: r.int16,
				advanceHeightMax: r.int16,
				minTopSideBearing: r.int16,
				minBottomSideBearing: r.int16,
				yMaxExtent: r.int16,
				caretSlopeRise: r.int16,
				caretSlopeRun: r.int16,
				caretOffset: r.int16,
				reserved: new r.Reserved(r.int16, 4),
				metricDataFormat: r.int16,
				numberOfMetrics: r.uint16
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	114: [function(require, module, exports) {
		(function() {
			var VmtxEntry, r;
			r = require("restructure");
			VmtxEntry = new r.Struct({
				advance: r.uint16,
				bearing: r.int16
			});
			module.exports = new r.Struct({
				metrics: new r.LazyArray(VmtxEntry, function() {
					return this.parent.vhea.numberOfMetrics
				}),
				bearings: new r.LazyArray(r.int16, function() {
					return this.parent.maxp.numGlyphs - this.parent.vhea.numberOfMetrics
				})
			})
		}).call(this)
	}, {
		restructure: 3
	}],
	115: [function(require, module, exports) {}, {}],
	116: [function(require, module, exports) {
		(function(global) {
			"use strict";
			var base64 = require("base64-js");
			var ieee754 = require("ieee754");
			var isArray = require("isarray");
			exports.Buffer = Buffer;
			exports.SlowBuffer = SlowBuffer;
			exports.INSPECT_MAX_BYTES = 50;
			Buffer.poolSize = 8192;
			var rootParent = {};
			Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

			function typedArraySupport() {
				try {
					var arr = new Uint8Array(1);
					arr.foo = function() {
						return 42
					};
					return arr.foo() === 42 && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0
				} catch (e) {
					return false
				}
			}

			function kMaxLength() {
				return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
			}

			function Buffer(arg) {
				if (!(this instanceof Buffer)) {
					if (arguments.length > 1) return new Buffer(arg, arguments[1]);
					return new Buffer(arg)
				}
				if (!Buffer.TYPED_ARRAY_SUPPORT) {
					this.length = 0;
					this.parent = undefined
				}
				if (typeof arg === "number") {
					return fromNumber(this, arg)
				}
				if (typeof arg === "string") {
					return fromString(this, arg, arguments.length > 1 ? arguments[1] : "utf8")
				}
				return fromObject(this, arg)
			}
			Buffer._augment = function(arr) {
				arr.__proto__ = Buffer.prototype;
				return arr
			};

			function fromNumber(that, length) {
				that = allocate(that, length < 0 ? 0 : checked(length) | 0);
				if (!Buffer.TYPED_ARRAY_SUPPORT) {
					for (var i = 0; i < length; i++) {
						that[i] = 0
					}
				}
				return that
			}

			function fromString(that, string, encoding) {
				if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
				var length = byteLength(string, encoding) | 0;
				that = allocate(that, length);
				that.write(string, encoding);
				return that
			}

			function fromObject(that, object) {
				if (Buffer.isBuffer(object)) return fromBuffer(that, object);
				if (isArray(object)) return fromArray(that, object);
				if (object == null) {
					throw new TypeError("must start with number, buffer, array or string")
				}
				if (typeof ArrayBuffer !== "undefined") {
					if (object.buffer instanceof ArrayBuffer) {
						return fromTypedArray(that, object)
					}
					if (object instanceof ArrayBuffer) {
						return fromArrayBuffer(that, object)
					}
				}
				if (object.length) return fromArrayLike(that, object);
				return fromJsonObject(that, object)
			}

			function fromBuffer(that, buffer) {
				var length = checked(buffer.length) | 0;
				that = allocate(that, length);
				buffer.copy(that, 0, 0, length);
				return that
			}

			function fromArray(that, array) {
				var length = checked(array.length) | 0;
				that = allocate(that, length);
				for (var i = 0; i < length; i += 1) {
					that[i] = array[i] & 255
				}
				return that
			}

			function fromTypedArray(that, array) {
				var length = checked(array.length) | 0;
				that = allocate(that, length);
				for (var i = 0; i < length; i += 1) {
					that[i] = array[i] & 255
				}
				return that
			}

			function fromArrayBuffer(that, array) {
				array.byteLength;
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					that = new Uint8Array(array);
					that.__proto__ = Buffer.prototype
				} else {
					that = fromTypedArray(that, new Uint8Array(array))
				}
				return that
			}

			function fromArrayLike(that, array) {
				var length = checked(array.length) | 0;
				that = allocate(that, length);
				for (var i = 0; i < length; i += 1) {
					that[i] = array[i] & 255
				}
				return that
			}

			function fromJsonObject(that, object) {
				var array;
				var length = 0;
				if (object.type === "Buffer" && isArray(object.data)) {
					array = object.data;
					length = checked(array.length) | 0
				}
				that = allocate(that, length);
				for (var i = 0; i < length; i += 1) {
					that[i] = array[i] & 255
				}
				return that
			}
			if (Buffer.TYPED_ARRAY_SUPPORT) {
				Buffer.prototype.__proto__ = Uint8Array.prototype;
				Buffer.__proto__ = Uint8Array;
				if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
					Object.defineProperty(Buffer, Symbol.species, {
						value: null,
						configurable: true
					})
				}
			} else {
				Buffer.prototype.length = undefined;
				Buffer.prototype.parent = undefined
			}

			function allocate(that, length) {
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					that = new Uint8Array(length);
					that.__proto__ = Buffer.prototype
				} else {
					that.length = length
				}
				var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
				if (fromPool) that.parent = rootParent;
				return that
			}

			function checked(length) {
				if (length >= kMaxLength()) {
					throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes")
				}
				return length | 0
			}

			function SlowBuffer(subject, encoding) {
				if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);
				var buf = new Buffer(subject, encoding);
				delete buf.parent;
				return buf
			}
			Buffer.isBuffer = function isBuffer(b) {
				return !!(b != null && b._isBuffer)
			};
			Buffer.compare = function compare(a, b) {
				if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
					throw new TypeError("Arguments must be Buffers")
				}
				if (a === b) return 0;
				var x = a.length;
				var y = b.length;
				var i = 0;
				var len = Math.min(x, y);
				while (i < len) {
					if (a[i] !== b[i]) break;
					++i
				}
				if (i !== len) {
					x = a[i];
					y = b[i]
				}
				if (x < y) return -1;
				if (y < x) return 1;
				return 0
			};
			Buffer.isEncoding = function isEncoding(encoding) {
				switch (String(encoding).toLowerCase()) {
					case "hex":
					case "utf8":
					case "utf-8":
					case "ascii":
					case "binary":
					case "base64":
					case "raw":
					case "ucs2":
					case "ucs-2":
					case "utf16le":
					case "utf-16le":
						return true;
					default:
						return false
				}
			};
			Buffer.concat = function concat(list, length) {
				if (!isArray(list)) throw new TypeError("list argument must be an Array of Buffers.");
				if (list.length === 0) {
					return new Buffer(0)
				}
				var i;
				if (length === undefined) {
					length = 0;
					for (i = 0; i < list.length; i++) {
						length += list[i].length
					}
				}
				var buf = new Buffer(length);
				var pos = 0;
				for (i = 0; i < list.length; i++) {
					var item = list[i];
					item.copy(buf, pos);
					pos += item.length
				}
				return buf
			};

			function byteLength(string, encoding) {
				if (typeof string !== "string") string = "" + string;
				var len = string.length;
				if (len === 0) return 0;
				var loweredCase = false;
				for (;;) {
					switch (encoding) {
						case "ascii":
						case "binary":
						case "raw":
						case "raws":
							return len;
						case "utf8":
						case "utf-8":
							return utf8ToBytes(string).length;
						case "ucs2":
						case "ucs-2":
						case "utf16le":
						case "utf-16le":
							return len * 2;
						case "hex":
							return len >>> 1;
						case "base64":
							return base64ToBytes(string).length;
						default:
							if (loweredCase) return utf8ToBytes(string).length;
							encoding = ("" + encoding).toLowerCase();
							loweredCase = true
					}
				}
			}
			Buffer.byteLength = byteLength;

			function slowToString(encoding, start, end) {
				var loweredCase = false;
				start = start | 0;
				end = end === undefined || end === Infinity ? this.length : end | 0;
				if (!encoding) encoding = "utf8";
				if (start < 0) start = 0;
				if (end > this.length) end = this.length;
				if (end <= start) return "";
				while (true) {
					switch (encoding) {
						case "hex":
							return hexSlice(this, start, end);
						case "utf8":
						case "utf-8":
							return utf8Slice(this, start, end);
						case "ascii":
							return asciiSlice(this, start, end);
						case "binary":
							return binarySlice(this, start, end);
						case "base64":
							return base64Slice(this, start, end);
						case "ucs2":
						case "ucs-2":
						case "utf16le":
						case "utf-16le":
							return utf16leSlice(this, start, end);
						default:
							if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
							encoding = (encoding + "").toLowerCase();
							loweredCase = true
					}
				}
			}
			Buffer.prototype._isBuffer = true;
			Buffer.prototype.toString = function toString() {
				var length = this.length | 0;
				if (length === 0) return "";
				if (arguments.length === 0) return utf8Slice(this, 0, length);
				return slowToString.apply(this, arguments)
			};
			Buffer.prototype.equals = function equals(b) {
				if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
				if (this === b) return true;
				return Buffer.compare(this, b) === 0
			};
			Buffer.prototype.inspect = function inspect() {
				var str = "";
				var max = exports.INSPECT_MAX_BYTES;
				if (this.length > 0) {
					str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
					if (this.length > max) str += " ... "
				}
				return "<Buffer " + str + ">"
			};
			Buffer.prototype.compare = function compare(b) {
				if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
				if (this === b) return 0;
				return Buffer.compare(this, b)
			};
			Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
				if (byteOffset > 2147483647) byteOffset = 2147483647;
				else if (byteOffset < -2147483648) byteOffset = -2147483648;
				byteOffset >>= 0;
				if (this.length === 0) return -1;
				if (byteOffset >= this.length) return -1;
				if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);
				if (typeof val === "string") {
					if (val.length === 0) return -1;
					return String.prototype.indexOf.call(this, val, byteOffset)
				}
				if (Buffer.isBuffer(val)) {
					return arrayIndexOf(this, val, byteOffset)
				}
				if (typeof val === "number") {
					if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === "function") {
						return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
					}
					return arrayIndexOf(this, [val], byteOffset)
				}

				function arrayIndexOf(arr, val, byteOffset) {
					var foundIndex = -1;
					for (var i = 0; byteOffset + i < arr.length; i++) {
						if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
							if (foundIndex === -1) foundIndex = i;
							if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
						} else {
							foundIndex = -1
						}
					}
					return -1
				}
				throw new TypeError("val must be string, number or Buffer")
			};

			function hexWrite(buf, string, offset, length) {
				offset = Number(offset) || 0;
				var remaining = buf.length - offset;
				if (!length) {
					length = remaining
				} else {
					length = Number(length);
					if (length > remaining) {
						length = remaining
					}
				}
				var strLen = string.length;
				if (strLen % 2 !== 0) throw new Error("Invalid hex string");
				if (length > strLen / 2) {
					length = strLen / 2
				}
				for (var i = 0; i < length; i++) {
					var parsed = parseInt(string.substr(i * 2, 2), 16);
					if (isNaN(parsed)) throw new Error("Invalid hex string");
					buf[offset + i] = parsed
				}
				return i
			}

			function utf8Write(buf, string, offset, length) {
				return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
			}

			function asciiWrite(buf, string, offset, length) {
				return blitBuffer(asciiToBytes(string), buf, offset, length)
			}

			function binaryWrite(buf, string, offset, length) {
				return asciiWrite(buf, string, offset, length)
			}

			function base64Write(buf, string, offset, length) {
				return blitBuffer(base64ToBytes(string), buf, offset, length)
			}

			function ucs2Write(buf, string, offset, length) {
				return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
			}
			Buffer.prototype.write = function write(string, offset, length, encoding) {
				if (offset === undefined) {
					encoding = "utf8";
					length = this.length;
					offset = 0
				} else if (length === undefined && typeof offset === "string") {
					encoding = offset;
					length = this.length;
					offset = 0
				} else if (isFinite(offset)) {
					offset = offset | 0;
					if (isFinite(length)) {
						length = length | 0;
						if (encoding === undefined) encoding = "utf8"
					} else {
						encoding = length;
						length = undefined
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length | 0;
					length = swap
				}
				var remaining = this.length - offset;
				if (length === undefined || length > remaining) length = remaining;
				if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
					throw new RangeError("attempt to write outside buffer bounds")
				}
				if (!encoding) encoding = "utf8";
				var loweredCase = false;
				for (;;) {
					switch (encoding) {
						case "hex":
							return hexWrite(this, string, offset, length);
						case "utf8":
						case "utf-8":
							return utf8Write(this, string, offset, length);
						case "ascii":
							return asciiWrite(this, string, offset, length);
						case "binary":
							return binaryWrite(this, string, offset, length);
						case "base64":
							return base64Write(this, string, offset, length);
						case "ucs2":
						case "ucs-2":
						case "utf16le":
						case "utf-16le":
							return ucs2Write(this, string, offset, length);
						default:
							if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
							encoding = ("" + encoding).toLowerCase();
							loweredCase = true
					}
				}
			};
			Buffer.prototype.toJSON = function toJSON() {
				return {
					type: "Buffer",
					data: Array.prototype.slice.call(this._arr || this, 0)
				}
			};

			function base64Slice(buf, start, end) {
				if (start === 0 && end === buf.length) {
					return base64.fromByteArray(buf)
				} else {
					return base64.fromByteArray(buf.slice(start, end))
				}
			}
			var MAX_ARGUMENTS_LENGTH = 4096;

			function decodeCodePointsArray(codePoints) {
				var len = codePoints.length;
				if (len <= MAX_ARGUMENTS_LENGTH) {
					return String.fromCharCode.apply(String, codePoints)
				}
				var res = "";
				var i = 0;
				while (i < len) {
					res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH))
				}
				return res
			}

			function asciiSlice(buf, start, end) {
				var ret = "";
				end = Math.min(buf.length, end);
				for (var i = start; i < end; i++) {
					ret += String.fromCharCode(buf[i] & 127)
				}
				return ret
			}

			function binarySlice(buf, start, end) {
				var ret = "";
				end = Math.min(buf.length, end);
				for (var i = start; i < end; i++) {
					ret += String.fromCharCode(buf[i])
				}
				return ret
			}

			function hexSlice(buf, start, end) {
				var len = buf.length;
				if (!start || start < 0) start = 0;
				if (!end || end < 0 || end > len) end = len;
				var out = "";
				for (var i = start; i < end; i++) {
					out += toHex(buf[i])
				}
				return out
			}

			function utf16leSlice(buf, start, end) {
				var bytes = buf.slice(start, end);
				var res = "";
				for (var i = 0; i < bytes.length; i += 2) {
					res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
				}
				return res
			}
			Buffer.prototype.slice = function slice(start, end) {
				var len = this.length;
				start = ~~start;
				end = end === undefined ? len : ~~end;
				if (start < 0) {
					start += len;
					if (start < 0) start = 0
				} else if (start > len) {
					start = len
				}
				if (end < 0) {
					end += len;
					if (end < 0) end = 0
				} else if (end > len) {
					end = len
				}
				if (end < start) end = start;
				var newBuf;
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					newBuf = this.subarray(start, end);
					newBuf.__proto__ = Buffer.prototype
				} else {
					var sliceLen = end - start;
					newBuf = new Buffer(sliceLen, undefined);
					for (var i = 0; i < sliceLen; i++) {
						newBuf[i] = this[i + start]
					}
				}
				if (newBuf.length) newBuf.parent = this.parent || this;
				return newBuf
			};

			function checkOffset(offset, ext, length) {
				if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
				if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length")
			}
			Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
				offset = offset | 0;
				byteLength = byteLength | 0;
				if (!noAssert) checkOffset(offset, byteLength, this.length);
				var val = this[offset];
				var mul = 1;
				var i = 0;
				while (++i < byteLength && (mul *= 256)) {
					val += this[offset + i] * mul
				}
				return val
			};
			Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
				offset = offset | 0;
				byteLength = byteLength | 0;
				if (!noAssert) {
					checkOffset(offset, byteLength, this.length)
				}
				var val = this[offset + --byteLength];
				var mul = 1;
				while (byteLength > 0 && (mul *= 256)) {
					val += this[offset + --byteLength] * mul
				}
				return val
			};
			Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 1, this.length);
				return this[offset]
			};
			Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 2, this.length);
				return this[offset] | this[offset + 1] << 8
			};
			Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 2, this.length);
				return this[offset] << 8 | this[offset + 1]
			};
			Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length);
				return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216
			};
			Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length);
				return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
			};
			Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
				offset = offset | 0;
				byteLength = byteLength | 0;
				if (!noAssert) checkOffset(offset, byteLength, this.length);
				var val = this[offset];
				var mul = 1;
				var i = 0;
				while (++i < byteLength && (mul *= 256)) {
					val += this[offset + i] * mul
				}
				mul *= 128;
				if (val >= mul) val -= Math.pow(2, 8 * byteLength);
				return val
			};
			Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
				offset = offset | 0;
				byteLength = byteLength | 0;
				if (!noAssert) checkOffset(offset, byteLength, this.length);
				var i = byteLength;
				var mul = 1;
				var val = this[offset + --i];
				while (i > 0 && (mul *= 256)) {
					val += this[offset + --i] * mul
				}
				mul *= 128;
				if (val >= mul) val -= Math.pow(2, 8 * byteLength);
				return val
			};
			Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 1, this.length);
				if (!(this[offset] & 128)) return this[offset];
				return (255 - this[offset] + 1) * -1
			};
			Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 2, this.length);
				var val = this[offset] | this[offset + 1] << 8;
				return val & 32768 ? val | 4294901760 : val
			};
			Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 2, this.length);
				var val = this[offset + 1] | this[offset] << 8;
				return val & 32768 ? val | 4294901760 : val
			};
			Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length);
				return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
			};
			Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length);
				return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
			};
			Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length);
				return ieee754.read(this, offset, true, 23, 4)
			};
			Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 4, this.length);
				return ieee754.read(this, offset, false, 23, 4)
			};
			Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 8, this.length);
				return ieee754.read(this, offset, true, 52, 8)
			};
			Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
				if (!noAssert) checkOffset(offset, 8, this.length);
				return ieee754.read(this, offset, false, 52, 8)
			};

			function checkInt(buf, value, offset, ext, max, min) {
				if (!Buffer.isBuffer(buf)) throw new TypeError("buffer must be a Buffer instance");
				if (value > max || value < min) throw new RangeError("value is out of bounds");
				if (offset + ext > buf.length) throw new RangeError("index out of range")
			}
			Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
				value = +value;
				offset = offset | 0;
				byteLength = byteLength | 0;
				if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
				var mul = 1;
				var i = 0;
				this[offset] = value & 255;
				while (++i < byteLength && (mul *= 256)) {
					this[offset + i] = value / mul & 255
				}
				return offset + byteLength
			};
			Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
				value = +value;
				offset = offset | 0;
				byteLength = byteLength | 0;
				if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
				var i = byteLength - 1;
				var mul = 1;
				this[offset + i] = value & 255;
				while (--i >= 0 && (mul *= 256)) {
					this[offset + i] = value / mul & 255
				}
				return offset + byteLength
			};
			Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
				if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
				this[offset] = value & 255;
				return offset + 1
			};

			function objectWriteUInt16(buf, value, offset, littleEndian) {
				if (value < 0) value = 65535 + value + 1;
				for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
					buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8
				}
			}
			Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = value & 255;
					this[offset + 1] = value >>> 8
				} else {
					objectWriteUInt16(this, value, offset, true)
				}
				return offset + 2
			};
			Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = value >>> 8;
					this[offset + 1] = value & 255
				} else {
					objectWriteUInt16(this, value, offset, false)
				}
				return offset + 2
			};

			function objectWriteUInt32(buf, value, offset, littleEndian) {
				if (value < 0) value = 4294967295 + value + 1;
				for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
					buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255
				}
			}
			Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset + 3] = value >>> 24;
					this[offset + 2] = value >>> 16;
					this[offset + 1] = value >>> 8;
					this[offset] = value & 255
				} else {
					objectWriteUInt32(this, value, offset, true)
				}
				return offset + 4
			};
			Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = value >>> 24;
					this[offset + 1] = value >>> 16;
					this[offset + 2] = value >>> 8;
					this[offset + 3] = value & 255
				} else {
					objectWriteUInt32(this, value, offset, false)
				}
				return offset + 4
			};
			Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) {
					var limit = Math.pow(2, 8 * byteLength - 1);
					checkInt(this, value, offset, byteLength, limit - 1, -limit)
				}
				var i = 0;
				var mul = 1;
				var sub = value < 0 ? 1 : 0;
				this[offset] = value & 255;
				while (++i < byteLength && (mul *= 256)) {
					this[offset + i] = (value / mul >> 0) - sub & 255
				}
				return offset + byteLength
			};
			Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) {
					var limit = Math.pow(2, 8 * byteLength - 1);
					checkInt(this, value, offset, byteLength, limit - 1, -limit)
				}
				var i = byteLength - 1;
				var mul = 1;
				var sub = value < 0 ? 1 : 0;
				this[offset + i] = value & 255;
				while (--i >= 0 && (mul *= 256)) {
					this[offset + i] = (value / mul >> 0) - sub & 255
				}
				return offset + byteLength
			};
			Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
				if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
				if (value < 0) value = 255 + value + 1;
				this[offset] = value & 255;
				return offset + 1
			};
			Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = value & 255;
					this[offset + 1] = value >>> 8
				} else {
					objectWriteUInt16(this, value, offset, true)
				}
				return offset + 2
			};
			Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = value >>> 8;
					this[offset + 1] = value & 255
				} else {
					objectWriteUInt16(this, value, offset, false)
				}
				return offset + 2
			};
			Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = value & 255;
					this[offset + 1] = value >>> 8;
					this[offset + 2] = value >>> 16;
					this[offset + 3] = value >>> 24
				} else {
					objectWriteUInt32(this, value, offset, true)
				}
				return offset + 4
			};
			Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
				value = +value;
				offset = offset | 0;
				if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
				if (value < 0) value = 4294967295 + value + 1;
				if (Buffer.TYPED_ARRAY_SUPPORT) {
					this[offset] = value >>> 24;
					this[offset + 1] = value >>> 16;
					this[offset + 2] = value >>> 8;
					this[offset + 3] = value & 255
				} else {
					objectWriteUInt32(this, value, offset, false)
				}
				return offset + 4
			};

			function checkIEEE754(buf, value, offset, ext, max, min) {
				if (offset + ext > buf.length) throw new RangeError("index out of range");
				if (offset < 0) throw new RangeError("index out of range")
			}

			function writeFloat(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38)
				}
				ieee754.write(buf, value, offset, littleEndian, 23, 4);
				return offset + 4
			}
			Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
				return writeFloat(this, value, offset, true, noAssert)
			};
			Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
				return writeFloat(this, value, offset, false, noAssert)
			};

			function writeDouble(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308)
				}
				ieee754.write(buf, value, offset, littleEndian, 52, 8);
				return offset + 8
			}
			Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
				return writeDouble(this, value, offset, true, noAssert)
			};
			Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
				return writeDouble(this, value, offset, false, noAssert)
			};
			Buffer.prototype.copy = function copy(target, targetStart, start, end) {
				if (!start) start = 0;
				if (!end && end !== 0) end = this.length;
				if (targetStart >= target.length) targetStart = target.length;
				if (!targetStart) targetStart = 0;
				if (end > 0 && end < start) end = start;
				if (end === start) return 0;
				if (target.length === 0 || this.length === 0) return 0;
				if (targetStart < 0) {
					throw new RangeError("targetStart out of bounds")
				}
				if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
				if (end < 0) throw new RangeError("sourceEnd out of bounds");
				if (end > this.length) end = this.length;
				if (target.length - targetStart < end - start) {
					end = target.length - targetStart + start
				}
				var len = end - start;
				var i;
				if (this === target && start < targetStart && targetStart < end) {
					for (i = len - 1; i >= 0; i--) {
						target[i + targetStart] = this[i + start]
					}
				} else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
					for (i = 0; i < len; i++) {
						target[i + targetStart] = this[i + start]
					}
				} else {
					Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart)
				}
				return len
			};
			Buffer.prototype.fill = function fill(value, start, end) {
				if (!value) value = 0;
				if (!start) start = 0;
				if (!end) end = this.length;
				if (end < start) throw new RangeError("end < start");
				if (end === start) return;
				if (this.length === 0) return;
				if (start < 0 || start >= this.length) throw new RangeError("start out of bounds");
				if (end < 0 || end > this.length) throw new RangeError("end out of bounds");
				var i;
				if (typeof value === "number") {
					for (i = start; i < end; i++) {
						this[i] = value
					}
				} else {
					var bytes = utf8ToBytes(value.toString());
					var len = bytes.length;
					for (i = start; i < end; i++) {
						this[i] = bytes[i % len]
					}
				}
				return this
			};
			var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

			function base64clean(str) {
				str = stringtrim(str).replace(INVALID_BASE64_RE, "");
				if (str.length < 2) return "";
				while (str.length % 4 !== 0) {
					str = str + "="
				}
				return str
			}

			function stringtrim(str) {
				if (str.trim) return str.trim();
				return str.replace(/^\s+|\s+$/g, "")
			}

			function toHex(n) {
				if (n < 16) return "0" + n.toString(16);
				return n.toString(16)
			}

			function utf8ToBytes(string, units) {
				units = units || Infinity;
				var codePoint;
				var length = string.length;
				var leadSurrogate = null;
				var bytes = [];
				for (var i = 0; i < length; i++) {
					codePoint = string.charCodeAt(i);
					if (codePoint > 55295 && codePoint < 57344) {
						if (!leadSurrogate) {
							if (codePoint > 56319) {
								if ((units -= 3) > -1) bytes.push(239, 191, 189);
								continue
							} else if (i + 1 === length) {
								if ((units -= 3) > -1) bytes.push(239, 191, 189);
								continue
							}
							leadSurrogate = codePoint;
							continue
						}
						if (codePoint < 56320) {
							if ((units -= 3) > -1) bytes.push(239, 191, 189);
							leadSurrogate = codePoint;
							continue
						}
						codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536
					} else if (leadSurrogate) {
						if ((units -= 3) > -1) bytes.push(239, 191, 189)
					}
					leadSurrogate = null;
					if (codePoint < 128) {
						if ((units -= 1) < 0) break;
						bytes.push(codePoint)
					} else if (codePoint < 2048) {
						if ((units -= 2) < 0) break;
						bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128)
					} else if (codePoint < 65536) {
						if ((units -= 3) < 0) break;
						bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128)
					} else if (codePoint < 1114112) {
						if ((units -= 4) < 0) break;
						bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128)
					} else {
						throw new Error("Invalid code point")
					}
				}
				return bytes
			}

			function asciiToBytes(str) {
				var byteArray = [];
				for (var i = 0; i < str.length; i++) {
					byteArray.push(str.charCodeAt(i) & 255)
				}
				return byteArray
			}

			function utf16leToBytes(str, units) {
				var c, hi, lo;
				var byteArray = [];
				for (var i = 0; i < str.length; i++) {
					if ((units -= 2) < 0) break;
					c = str.charCodeAt(i);
					hi = c >> 8;
					lo = c % 256;
					byteArray.push(lo);
					byteArray.push(hi)
				}
				return byteArray
			}

			function base64ToBytes(str) {
				return base64.toByteArray(base64clean(str))
			}

			function blitBuffer(src, dst, offset, length) {
				for (var i = 0; i < length; i++) {
					if (i + offset >= dst.length || i >= src.length) break;
					dst[i + offset] = src[i]
				}
				return i
			}
		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {
		"base64-js": 117,
		ieee754: 115,
		isarray: 115
	}],
	117: [function(require, module, exports) {
		(function(exports) {
			"use strict";
			var i;
			var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
			var lookup = [];
			for (i = 0; i < code.length; i++) {
				lookup[i] = code[i]
			}
			var revLookup = [];
			for (i = 0; i < code.length; ++i) {
				revLookup[code.charCodeAt(i)] = i
			}
			revLookup["-".charCodeAt(0)] = 62;
			revLookup["_".charCodeAt(0)] = 63;
			var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;

			function decode(elt) {
				var v = revLookup[elt.charCodeAt(0)];
				return v !== undefined ? v : -1
			}

			function b64ToByteArray(b64) {
				var i, j, l, tmp, placeHolders, arr;
				if (b64.length % 4 > 0) {
					throw new Error("Invalid string. Length must be a multiple of 4")
				}
				var len = b64.length;
				placeHolders = b64.charAt(len - 2) === "=" ? 2 : b64.charAt(len - 1) === "=" ? 1 : 0;
				arr = new Arr(b64.length * 3 / 4 - placeHolders);
				l = placeHolders > 0 ? b64.length - 4 : b64.length;
				var L = 0;

				function push(v) {
					arr[L++] = v
				}
				for (i = 0, j = 0; i < l; i += 4, j += 3) {
					tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
					push((tmp & 16711680) >> 16);
					push((tmp & 65280) >> 8);
					push(tmp & 255)
				}
				if (placeHolders === 2) {
					tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
					push(tmp & 255)
				} else if (placeHolders === 1) {
					tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
					push(tmp >> 8 & 255);
					push(tmp & 255)
				}
				return arr
			}

			function encode(num) {
				return lookup[num]
			}

			function tripletToBase64(num) {
				return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63)
			}

			function encodeChunk(uint8, start, end) {
				var temp;
				var output = [];
				for (var i = start; i < end; i += 3) {
					temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
					output.push(tripletToBase64(temp))
				}
				return output.join("")
			}

			function uint8ToBase64(uint8) {
				var i;
				var extraBytes = uint8.length % 3;
				var output = "";
				var parts = [];
				var temp, length;
				var maxChunkLength = 16383;
				for (i = 0, length = uint8.length - extraBytes; i < length; i += maxChunkLength) {
					parts.push(encodeChunk(uint8, i, i + maxChunkLength > length ? length : i + maxChunkLength))
				}
				switch (extraBytes) {
					case 1:
						temp = uint8[uint8.length - 1];
						output += encode(temp >> 2);
						output += encode(temp << 4 & 63);
						output += "==";
						break;
					case 2:
						temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
						output += encode(temp >> 10);
						output += encode(temp >> 4 & 63);
						output += encode(temp << 2 & 63);
						output += "=";
						break;
					default:
						break
				}
				parts.push(output);
				return parts.join("")
			}
			exports.toByteArray = b64ToByteArray;
			exports.fromByteArray = uint8ToBase64
		})(typeof exports === "undefined" ? this.base64js = {} : exports)
	}, {}],
	118: [function(require, module, exports) {
		var process = module.exports = {};
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;

		function cleanUpNextTick() {
			draining = false;
			if (currentQueue.length) {
				queue = currentQueue.concat(queue)
			} else {
				queueIndex = -1
			}
			if (queue.length) {
				drainQueue()
			}
		}

		function drainQueue() {
			if (draining) {
				return
			}
			var timeout = setTimeout(cleanUpNextTick);
			draining = true;
			var len = queue.length;
			while (len) {
				currentQueue = queue;
				queue = [];
				while (++queueIndex < len) {
					if (currentQueue) {
						currentQueue[queueIndex].run()
					}
				}
				queueIndex = -1;
				len = queue.length
			}
			currentQueue = null;
			draining = false;
			clearTimeout(timeout)
		}
		process.nextTick = function(fun) {
			var args = new Array(arguments.length - 1);
			if (arguments.length > 1) {
				for (var i = 1; i < arguments.length; i++) {
					args[i - 1] = arguments[i]
				}
			}
			queue.push(new Item(fun, args));
			if (queue.length === 1 && !draining) {
				setTimeout(drainQueue, 0)
			}
		};

		function Item(fun, array) {
			this.fun = fun;
			this.array = array
		}
		Item.prototype.run = function() {
			this.fun.apply(null, this.array)
		};
		process.title = "browser";
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = "";
		process.versions = {};

		function noop() {}
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.binding = function(name) {
			throw new Error("process.binding is not supported")
		};
		process.cwd = function() {
			return "/"
		};
		process.chdir = function(dir) {
			throw new Error("process.chdir is not supported")
		};
		process.umask = function() {
			return 0
		}
	}, {}]
}, {}, [1]);